{"primaryContentSections":[{"kind":"content","content":[{"anchor":"The-Problem-That-Opaque-Types-Solve","level":2,"type":"heading","text":"The Problem That Opaque Types Solve"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"suppose you’re writing a module that draws ASCII art shapes."},{"type":"text","text":" "},{"type":"text","text":"The basic characteristic of an ASCII art shape"},{"type":"text","text":" "},{"type":"text","text":"is a "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" function that returns the string representation of that shape,"},{"type":"text","text":" "},{"type":"text","text":"which you can use as the requirement for the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["protocol Shape {","    func draw() -> String","}","","struct Triangle: Shape {","   var size: Int","   func draw() -> String {","       var result: [String] = []","       for length in 1...size {","           result.append(String(repeating: \"*\", count: length))","       }","       return result.joined(separator: \"\\n\")","   }","}","let smallTriangle = Triangle(size: 3)","print(smallTriangle.draw())","\/\/ *","\/\/ **","\/\/ ***"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You could use generics to implement operations like flipping a shape vertically,"},{"type":"text","text":" "},{"type":"text","text":"as shown in the code below."},{"type":"text","text":" "},{"type":"text","text":"However, there’s an important limitation to this approach:"},{"type":"text","text":" "},{"type":"text","text":"The flipped result exposes the exact generic types"},{"type":"text","text":" "},{"type":"text","text":"that were used to create it."}]},{"type":"codeListing","syntax":"swift","code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}","let flippedTriangle = FlippedShape(shape: smallTriangle)","print(flippedTriangle.draw())","\/\/ ***","\/\/ **","\/\/ *"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This approach to defining a "},{"type":"codeVoice","code":"JoinedShape<T: Shape, U: Shape>"},{"type":"text","text":" structure"},{"type":"text","text":" "},{"type":"text","text":"that joins two shapes together vertically, like the code below shows,"},{"type":"text","text":" "},{"type":"text","text":"results in types like "},{"type":"codeVoice","code":"JoinedShape<FlippedShape<Triangle>, Triangle>"},{"type":"text","text":" "},{"type":"text","text":"from joining a flipped triangle with another triangle."}]},{"type":"codeListing","syntax":"swift","code":["struct JoinedShape<T: Shape, U: Shape>: Shape {","   var top: T","   var bottom: U","   func draw() -> String {","       return top.draw() + \"\\n\" + bottom.draw()","   }","}","let joinedTriangles = JoinedShape(top: smallTriangle, bottom: flippedTriangle)","print(joinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Exposing detailed information about the creation of a shape"},{"type":"text","text":" "},{"type":"text","text":"allows types that aren’t meant to be"},{"type":"text","text":" "},{"type":"text","text":"part of the ASCII art module’s public interface"},{"type":"text","text":" "},{"type":"text","text":"to leak out because of the need to state the full return type."},{"type":"text","text":" "},{"type":"text","text":"The code inside the module"},{"type":"text","text":" "},{"type":"text","text":"could build up the same shape in a variety of ways,"},{"type":"text","text":" "},{"type":"text","text":"and other code outside the module"},{"type":"text","text":" "},{"type":"text","text":"that uses the shape shouldn’t have to account for"},{"type":"text","text":" "},{"type":"text","text":"the implementation details about the list of transformations."},{"type":"text","text":" "},{"type":"text","text":"Wrapper types like "},{"type":"codeVoice","code":"JoinedShape"},{"type":"text","text":" and "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":" "},{"type":"text","text":"don’t matter to the module’s users,"},{"type":"text","text":" "},{"type":"text","text":"and they shouldn’t be visible."},{"type":"text","text":" "},{"type":"text","text":"The module’s public interface"},{"type":"text","text":" "},{"type":"text","text":"consists of operations like joining and flipping a shape,"},{"type":"text","text":" "},{"type":"text","text":"and those operations return another "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" value."}]},{"anchor":"Returning-an-Opaque-Type","level":2,"type":"heading","text":"Returning an Opaque Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can think of an opaque type like being the reverse of a generic type."},{"type":"text","text":" "},{"type":"text","text":"Generic types let the code that calls a function"},{"type":"text","text":" "},{"type":"text","text":"pick the type for that function’s parameters and return value"},{"type":"text","text":" "},{"type":"text","text":"in a way that’s abstracted away from the function implementation."},{"type":"text","text":" "},{"type":"text","text":"For example, the function in the following code"},{"type":"text","text":" "},{"type":"text","text":"returns a type that depends on its caller:"}]},{"type":"codeListing","syntax":"swift","code":["func max<T>(_ x: T, _ y: T) -> T where T: Comparable { ... }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code that calls "},{"type":"codeVoice","code":"max(_:_:)"},{"type":"text","text":" chooses the values for "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the type of those values determines the concrete type of "},{"type":"codeVoice","code":"T"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The calling code can use any type"},{"type":"text","text":" "},{"type":"text","text":"that conforms to the "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"The code inside the function is written in a general way"},{"type":"text","text":" "},{"type":"text","text":"so it can handle whatever type the caller provides."},{"type":"text","text":" "},{"type":"text","text":"The implementation of "},{"type":"codeVoice","code":"max(_:_:)"},{"type":"text","text":" uses only functionality"},{"type":"text","text":" "},{"type":"text","text":"that all "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" types share."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Those roles are reversed for a function with an opaque return type."},{"type":"text","text":" "},{"type":"text","text":"An opaque type lets the function implementation"},{"type":"text","text":" "},{"type":"text","text":"pick the type for the value it returns"},{"type":"text","text":" "},{"type":"text","text":"in a way that’s abstracted away from the code that calls the function."},{"type":"text","text":" "},{"type":"text","text":"For example, the function in the following example returns a trapezoid"},{"type":"text","text":" "},{"type":"text","text":"without exposing the underlying type of that shape."}]},{"type":"codeListing","syntax":"swift","code":["struct Square: Shape {","    var size: Int","    func draw() -> String {","        let line = String(repeating: \"*\", count: size)","        let result = Array<String>(repeating: line, count: size)","        return result.joined(separator: \"\\n\")","    }","}","","func makeTrapezoid() -> some Shape {","    let top = Triangle(size: 2)","    let middle = Square(size: 2)","    let bottom = FlippedShape(shape: top)","    let trapezoid = JoinedShape(","        top: top,","        bottom: JoinedShape(top: middle, bottom: bottom)","    )","    return trapezoid","}","let trapezoid = makeTrapezoid()","print(trapezoid.draw())","\/\/ *","\/\/ **","\/\/ **","\/\/ **","\/\/ **","\/\/ *"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":" function in this example"},{"type":"text","text":" "},{"type":"text","text":"declares its return type as "},{"type":"codeVoice","code":"some Shape"},{"type":"text","text":";"},{"type":"text","text":" "},{"type":"text","text":"as a result, the function"},{"type":"text","text":" "},{"type":"text","text":"returns a value of some given type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"without specifying any particular concrete type."},{"type":"text","text":" "},{"type":"text","text":"Writing "},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":" this way lets it express"},{"type":"text","text":" "},{"type":"text","text":"the fundamental aspect of its public interface —"},{"type":"text","text":" "},{"type":"text","text":"the value it returns is a shape —"},{"type":"text","text":" "},{"type":"text","text":"without making the specific types that the shape is made from"},{"type":"text","text":" "},{"type":"text","text":"a part of its public interface."},{"type":"text","text":" "},{"type":"text","text":"This implementation uses two triangles and a square,"},{"type":"text","text":" "},{"type":"text","text":"but the function could be rewritten to draw a trapezoid"},{"type":"text","text":" "},{"type":"text","text":"in a variety of other ways"},{"type":"text","text":" "},{"type":"text","text":"without changing its return type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example highlights the way that an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"is like the reverse of a generic type."},{"type":"text","text":" "},{"type":"text","text":"The code inside "},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":" can return any type it needs to,"},{"type":"text","text":" "},{"type":"text","text":"as long as that type conforms to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"like the calling code does for a generic function."},{"type":"text","text":" "},{"type":"text","text":"The code that calls the function needs to be written in a general way,"},{"type":"text","text":" "},{"type":"text","text":"like the implementation of a generic function,"},{"type":"text","text":" "},{"type":"text","text":"so that it can work with any "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" value"},{"type":"text","text":" "},{"type":"text","text":"that’s returned by "},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also combine opaque return types with generics."},{"type":"text","text":" "},{"type":"text","text":"The functions in the following code both return a value"},{"type":"text","text":" "},{"type":"text","text":"of some type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."}]},{"type":"codeListing","syntax":"swift","code":["func flip<T: Shape>(_ shape: T) -> some Shape {","    return FlippedShape(shape: shape)","}","func join<T: Shape, U: Shape>(_ top: T, _ bottom: U) -> some Shape {","    JoinedShape(top: top, bottom: bottom)","}","","let opaqueJoinedTriangles = join(smallTriangle, flip(smallTriangle))","print(opaqueJoinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of "},{"type":"codeVoice","code":"opaqueJoinedTriangles"},{"type":"text","text":" in this example"},{"type":"text","text":" "},{"type":"text","text":"is the same as "},{"type":"codeVoice","code":"joinedTriangles"},{"type":"text","text":" in the generics example"},{"type":"text","text":" "},{"type":"text","text":"in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve"},{"type":"text","text":" section earlier in this chapter."},{"type":"text","text":" "},{"type":"text","text":"However, unlike the value in that example,"},{"type":"text","text":" "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"join(_:_:)"},{"type":"text","text":" wrap the underlying types"},{"type":"text","text":" "},{"type":"text","text":"that the generic shape operations return"},{"type":"text","text":" "},{"type":"text","text":"in an opaque return type,"},{"type":"text","text":" "},{"type":"text","text":"which prevents those types from being visible."},{"type":"text","text":" "},{"type":"text","text":"Both functions are generic because the types they rely on are generic,"},{"type":"text","text":" "},{"type":"text","text":"and the type parameters to the function"},{"type":"text","text":" "},{"type":"text","text":"pass along the type information needed by "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":" and "},{"type":"codeVoice","code":"JoinedShape"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a function with an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"returns from multiple places,"},{"type":"text","text":" "},{"type":"text","text":"all of the possible return values must have the same type."},{"type":"text","text":" "},{"type":"text","text":"For a generic function,"},{"type":"text","text":" "},{"type":"text","text":"that return type can use the function’s generic type parameters,"},{"type":"text","text":" "},{"type":"text","text":"but it must still be a single type."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"here’s an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"invalid"}]},{"type":"text","text":" version of the shape-flipping function"},{"type":"text","text":" "},{"type":"text","text":"that includes a special case for squares:"}]},{"type":"codeListing","syntax":"swift","code":["func invalidFlip<T: Shape>(_ shape: T) -> some Shape {","    if shape is Square {","        return shape \/\/ Error: return types don't match","    }","    return FlippedShape(shape: shape) \/\/ Error: return types don't match","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you call this function with a "},{"type":"codeVoice","code":"Square"},{"type":"text","text":", it returns a "},{"type":"codeVoice","code":"Square"},{"type":"text","text":";"},{"type":"text","text":" "},{"type":"text","text":"otherwise, it returns a "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This violates the requirement to return values of only one type"},{"type":"text","text":" "},{"type":"text","text":"and makes "},{"type":"codeVoice","code":"invalidFlip(_:)"},{"type":"text","text":" invalid code."},{"type":"text","text":" "},{"type":"text","text":"One way to fix "},{"type":"codeVoice","code":"invalidFlip(_:)"},{"type":"text","text":" is to move the special case for squares"},{"type":"text","text":" "},{"type":"text","text":"into the implementation of "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which lets this function always return a "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":" value:"}]},{"type":"codeListing","syntax":"swift","code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        if shape is Square {","           return shape.draw()","        }","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The requirement to always return a single type"},{"type":"text","text":" "},{"type":"text","text":"doesn’t prevent you from using generics in an opaque return type."},{"type":"text","text":" "},{"type":"text","text":"Here’s an example of a function that incorporates its type parameter"},{"type":"text","text":" "},{"type":"text","text":"into the underlying type of the value it returns:"}]},{"type":"codeListing","syntax":"swift","code":["func `repeat`<T: Shape>(shape: T, count: Int) -> some Collection {","    return Array<T>(repeating: shape, count: count)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case,"},{"type":"text","text":" "},{"type":"text","text":"the underlying type of the return value"},{"type":"text","text":" "},{"type":"text","text":"varies depending on "},{"type":"codeVoice","code":"T"},{"type":"text","text":":"},{"type":"text","text":" "},{"type":"text","text":"Whatever shape is passed it,"},{"type":"text","text":" "},{"type":"codeVoice","code":"repeat(shape:count:)"},{"type":"text","text":" creates and returns an array of that shape."},{"type":"text","text":" "},{"type":"text","text":"Nevertheless,"},{"type":"text","text":" "},{"type":"text","text":"the return value always has the same underlying type of "},{"type":"codeVoice","code":"[T]"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"so it follows the requirement that functions with opaque return types"},{"type":"text","text":" "},{"type":"text","text":"must return values of only a single type."}]},{"anchor":"Differences-Between-Opaque-Types-and-Protocol-Types","level":2,"type":"heading","text":"Differences Between Opaque Types and Protocol Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Returning an opaque type looks very similar"},{"type":"text","text":" "},{"type":"text","text":"to using a protocol type as the return type of a function,"},{"type":"text","text":" "},{"type":"text","text":"but these two kinds of return type differ in"},{"type":"text","text":" "},{"type":"text","text":"whether they preserve type identity."},{"type":"text","text":" "},{"type":"text","text":"An opaque type refers to one specific type,"},{"type":"text","text":" "},{"type":"text","text":"although the caller of the function isn’t able to see which type;"},{"type":"text","text":" "},{"type":"text","text":"a protocol type can refer to any type that conforms to the protocol."},{"type":"text","text":" "},{"type":"text","text":"Generally speaking,"},{"type":"text","text":" "},{"type":"text","text":"protocol types give you more flexibility"},{"type":"text","text":" "},{"type":"text","text":"about the underlying types of the values they store,"},{"type":"text","text":" "},{"type":"text","text":"and opaque types let you make stronger guarantees"},{"type":"text","text":" "},{"type":"text","text":"about those underlying types."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"here’s a version of "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":" "},{"type":"text","text":"that uses a protocol type as its return type"},{"type":"text","text":" "},{"type":"text","text":"instead of an opaque return type:"}]},{"type":"codeListing","syntax":"swift","code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","   return FlippedShape(shape: shape)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This version of "},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" "},{"type":"text","text":"has the same body as "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and it always returns a value of the same type."},{"type":"text","text":" "},{"type":"text","text":"Unlike "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the value that "},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" returns isn’t required"},{"type":"text","text":" "},{"type":"text","text":"to always have the same type —"},{"type":"text","text":" "},{"type":"text","text":"it just has to conform to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"Put another way,"},{"type":"text","text":" "},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" makes a much looser API contract with its caller"},{"type":"text","text":" "},{"type":"text","text":"than "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":" makes."},{"type":"text","text":" "},{"type":"text","text":"It reserves the flexibility to return values of multiple types:"}]},{"type":"codeListing","syntax":"swift","code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","   if shape is Square {","      return shape","   }","","   return FlippedShape(shape: shape)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The revised version of the code returns"},{"type":"text","text":" "},{"type":"text","text":"an instance of "},{"type":"codeVoice","code":"Square"},{"type":"text","text":" or an instance of "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"depending on what shape is passed in."},{"type":"text","text":" "},{"type":"text","text":"Two flipped shapes returned by this function"},{"type":"text","text":" "},{"type":"text","text":"might have completely different types."},{"type":"text","text":" "},{"type":"text","text":"Other valid versions of this function could return values of different types"},{"type":"text","text":" "},{"type":"text","text":"when flipping multiple instances of the same shape."},{"type":"text","text":" "},{"type":"text","text":"The less specific return type information from "},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" means that"},{"type":"text","text":" "},{"type":"text","text":"many operations that depend on type information"},{"type":"text","text":" "},{"type":"text","text":"aren’t available on the returned value."},{"type":"text","text":" "},{"type":"text","text":"For example, it’s not possible to write an "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"comparing results returned by this function."}]},{"type":"codeListing","syntax":"swift","code":["let protoFlippedTriangle = protoFlip(smallTriangle)","let sameThing = protoFlip(smallTriangle)","protoFlippedTriangle == sameThing  \/\/ Error"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The error on the last line of the example occurs for several reasons."},{"type":"text","text":" "},{"type":"text","text":"The immediate issue is that the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" doesn’t include an "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"as part of its protocol requirements."},{"type":"text","text":" "},{"type":"text","text":"If you try adding one, the next issue you’ll encounter"},{"type":"text","text":" "},{"type":"text","text":"is that the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator needs to know"},{"type":"text","text":" "},{"type":"text","text":"the types of its left-hand and right-hand arguments."},{"type":"text","text":" "},{"type":"text","text":"This sort of operator usually takes arguments of type "},{"type":"codeVoice","code":"Self"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"matching whatever concrete type adopts the protocol,"},{"type":"text","text":" "},{"type":"text","text":"but adding a "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" requirement to the protocol"},{"type":"text","text":" "},{"type":"text","text":"doesn’t allow for the type erasure that happens"},{"type":"text","text":" "},{"type":"text","text":"when you use the protocol as a type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using a protocol type as the return type for a function"},{"type":"text","text":" "},{"type":"text","text":"gives you the flexibility to return any type that conforms to the protocol."},{"type":"text","text":" "},{"type":"text","text":"However, the cost of that flexibility"},{"type":"text","text":" "},{"type":"text","text":"is that some operations aren’t possible on the returned values."},{"type":"text","text":" "},{"type":"text","text":"The example shows how the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator isn’t available —"},{"type":"text","text":" "},{"type":"text","text":"it depends on specific type information"},{"type":"text","text":" "},{"type":"text","text":"that isn’t preserved by using a protocol type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another problem with this approach is that the shape transformations don’t nest."},{"type":"text","text":" "},{"type":"text","text":"The result of flipping a triangle is a value of type "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" function takes an argument"},{"type":"text","text":" "},{"type":"text","text":"of some type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"However, a value of a protocol type doesn’t conform to that protocol;"},{"type":"text","text":" "},{"type":"text","text":"the value returned by "},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" doesn’t conform to "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This means code like "},{"type":"codeVoice","code":"protoFlip(protoFlip(smallTriange))"},{"type":"text","text":" "},{"type":"text","text":"that applies multiple transformations is invalid"},{"type":"text","text":" "},{"type":"text","text":"because the flipped shape isn’t a valid argument to "},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In contrast,"},{"type":"text","text":" "},{"type":"text","text":"opaque types preserve the identity of the underlying type."},{"type":"text","text":" "},{"type":"text","text":"Swift can infer associated types,"},{"type":"text","text":" "},{"type":"text","text":"which lets you use an opaque return value"},{"type":"text","text":" "},{"type":"text","text":"in places where a protocol type can’t be used as a return value."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"here’s a version of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol from "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["protocol Container {","    associatedtype Item","    var count: Int { get }","    subscript(i: Int) -> Item { get }","}","extension Array: Container { }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can’t use "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" as the return type of a function"},{"type":"text","text":" "},{"type":"text","text":"because that protocol has an associated type."},{"type":"text","text":" "},{"type":"text","text":"You also can’t use it as constraint in a generic return type"},{"type":"text","text":" "},{"type":"text","text":"because there isn’t enough information outside the function body"},{"type":"text","text":" "},{"type":"text","text":"to infer what the generic type needs to be."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Error: Protocol with associated types can't be used as a return type.","func makeProtocolContainer<T>(item: T) -> Container {","    return [item]","}","","\/\/ Error: Not enough information to infer C.","func makeProtocolContainer<T, C: Container>(item: T) -> C {","    return [item]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using the opaque type "},{"type":"codeVoice","code":"some Container"},{"type":"text","text":" as a return type"},{"type":"text","text":" "},{"type":"text","text":"expresses the desired API contract — the function returns a container,"},{"type":"text","text":" "},{"type":"text","text":"but declines to specify the container’s type:"}]},{"type":"codeListing","syntax":"swift","code":["func makeOpaqueContainer<T>(item: T) -> some Container {","    return [item]","}","let opaqueContainer = makeOpaqueContainer(item: 12)","let twelve = opaqueContainer[0]","print(type(of: twelve))","\/\/ Prints \"Int\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The type of "},{"type":"codeVoice","code":"twelve"},{"type":"text","text":" is inferred to be "},{"type":"codeVoice","code":"Int"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which illustrates the fact that type inference works with opaque types."},{"type":"text","text":" "},{"type":"text","text":"In the implementation of "},{"type":"codeVoice","code":"makeOpaqueContainer(item:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the underlying type of the opaque container is "},{"type":"codeVoice","code":"[T]"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"In this case, "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Int"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"so the return value is an array of integers"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" associated type is inferred to be "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The subscript on "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" returns "},{"type":"codeVoice","code":"Item"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which means that the type of "},{"type":"codeVoice","code":"twelve"},{"type":"text","text":" is also inferred to be "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/opaquetypes"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A function or method with an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"type":"text","text":"Instead of providing a concrete type as the function’s return type,"},{"type":"text","text":" "},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"type":"text","text":"Hiding type information"},{"type":"text","text":" "},{"type":"text","text":"is useful at boundaries between"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"type":"text","text":" "},{"type":"text","text":"because the underlying type of the return value can remain private."},{"type":"text","text":" "},{"type":"text","text":"Unlike returning a value whose type is a protocol type,"},{"type":"text","text":" "},{"type":"text","text":"opaque types preserve type identity —"},{"type":"text","text":" "},{"type":"text","text":"the compiler has access to the type information,"},{"type":"text","text":" "},{"type":"text","text":"but clients of the module don’t."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Opaque Types","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Guide","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"],"generated":true}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols":{"role":"article","title":"Protocols","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol"}]},{"type":"text","text":" defines a blueprint of"},{"type":"text","text":" "},{"type":"text","text":"methods, properties, and other requirements"},{"type":"text","text":" "},{"type":"text","text":"that suit a particular task or piece of functionality."},{"type":"text","text":" "},{"type":"text","text":"The protocol can then be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"adopted"}]},{"type":"text","text":" by a class, structure, or enumeration"},{"type":"text","text":" "},{"type":"text","text":"to provide an actual implementation of those requirements."},{"type":"text","text":" "},{"type":"text","text":"Any type that satisfies the requirements of a protocol is said to"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conform"}]},{"type":"text","text":" to that protocol."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/protocols"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Methods":{"role":"article","title":"Methods","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Methods"}]},{"type":"text","text":" are functions that are associated with a particular type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can all define instance methods,"},{"type":"text","text":" "},{"type":"text","text":"which encapsulate specific tasks and functionality for working with an instance of a given type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can also define type methods,"},{"type":"text","text":" "},{"type":"text","text":"which are associated with the type itself."},{"type":"text","text":" "},{"type":"text","text":"Type methods are similar to class methods in Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes#The-Problem-That-Opaque-Types-Solve":{"abstract":[],"title":"The Problem That Opaque Types Solve","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve","url":"\/documentation\/the-swift-programming-language\/opaquetypes#The-Problem-That-Opaque-Types-Solve"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes":{"role":"article","title":"Tipos de Coleção","abstract":[{"type":"text","text":"Swift oferece três "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos de coleção"}]},{"type":"text","text":" primários, conhecidos como arrays, sets e dicionários, para armazenar coleções de valores. Arrays são coleções ordenadas de valores. Sets são coleções não ordenadas de valores únicos. Os dicionários são coleções não ordenadas de associações chave-valor."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/collectiontypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow":{"role":"article","title":"Control Flow","abstract":[{"type":"text","text":"Swift provides a variety of control flow statements."},{"type":"text","text":" "},{"type":"text","text":"These include "},{"type":"codeVoice","code":"while"},{"type":"text","text":" loops to perform a task multiple times;"},{"type":"text","text":" "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", and "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statements"},{"type":"text","text":" "},{"type":"text","text":"to execute different branches of code based on certain conditions;"},{"type":"text","text":" "},{"type":"text","text":"and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" "},{"type":"text","text":"to transfer the flow of execution to another point in your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/controlflow"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"role":"article","title":"Type Casting","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance,"},{"type":"text","text":" "},{"type":"text","text":"or to treat that instance as a different"},{"type":"text","text":" "},{"type":"text","text":"superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Deinitialization":{"role":"article","title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"deinitializer"}]},{"type":"text","text":" is called immediately before a class instance is deallocated."},{"type":"text","text":" "},{"type":"text","text":"You write deinitializers with the "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"similar to how initializers are written with the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"Deinitializers are only available on class types."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/deinitialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics":{"role":"article","title":"O Básico","abstract":[{"type":"text","text":"Swift é uma linguagem de programação para desenvolvimento de aplicativos iOS, macOS, watchOS e tvOS. Se você tem experiência em desenvolvimento em C ou Objective-C, muitas partes do Swift serão familiares para você."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/thebasics"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance":{"role":"article","title":"Inheritance","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"type":"text","text":" methods, properties, and other characteristics"},{"type":"text","text":" "},{"type":"text","text":"from another class."},{"type":"text","text":" "},{"type":"text","text":"When one class inherits from another,"},{"type":"text","text":" "},{"type":"text","text":"the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Inheritance is a fundamental behavior that differentiates classes"},{"type":"text","text":" "},{"type":"text","text":"from other types in Swift."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/inheritance"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization":{"role":"article","title":"Initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"type":"text","text":" is the process of preparing an instance of"},{"type":"text","text":" "},{"type":"text","text":"a class, structure, or enumeration for use."},{"type":"text","text":" "},{"type":"text","text":"This process involves setting an initial value for each stored property on that instance"},{"type":"text","text":" "},{"type":"text","text":"and performing any other setup or initialization that’s required"},{"type":"text","text":" "},{"type":"text","text":"before the new instance is ready for use."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Extensions":{"role":"article","title":"Extensões","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensões"}]},{"type":"text","text":" adicionam novas funcionalidades a uma classe, estrutura, enumeração ou tipo de protocolo existente. Isso inclui a capacidade de estender tipos para os quais você não tem acesso ao código-fonte original (conhecido como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"modelagem retroativa"}]},{"type":"text","text":"). As extensões são semelhantes às categorias em Objective-C. (Ao contrário das categorias de Objective-C, as extensões Swift não têm nomes.)"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/extensions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Enumerations":{"role":"article","title":"Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values"},{"type":"text","text":" "},{"type":"text","text":"and enables you to work with those values in a type-safe way within your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/enumerations"},"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/StringsAndCharacters":{"role":"article","title":"Strings e Characters","abstract":[{"type":"text","text":"Uma "},{"type":"emphasis","inlineContent":[{"type":"text","text":"string"}]},{"type":"text","text":" é uma série de caracteres,"},{"type":"text","text":" "},{"type":"text","text":"tal como "},{"type":"codeVoice","code":"\"olá, mundo\""},{"type":"text","text":" ou "},{"type":"codeVoice","code":"\"albatroz\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Strings em Swift são representadas pelo tipo "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"O conteúdo de uma "},{"type":"codeVoice","code":"String"},{"type":"text","text":" pode ser acessado de várias maneiras,"},{"type":"text","text":" "},{"type":"text","text":"incluindo como uma coleção de valores "},{"type":"codeVoice","code":"Character"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/stringsandcharacters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting":{"role":"article","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"type":"text","text":" (ARC)"},{"type":"text","text":" "},{"type":"text","text":"to track and manage your app’s memory usage."},{"type":"text","text":" "},{"type":"text","text":"In most cases, this means that memory management “just works” in Swift,"},{"type":"text","text":" "},{"type":"text","text":"and you don’t need to think about memory management yourself."},{"type":"text","text":" "},{"type":"text","text":"ARC automatically frees up the memory used by class instances"},{"type":"text","text":" "},{"type":"text","text":"when those instances are no longer needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures":{"role":"article","title":"Closures","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closures"}]},{"type":"text","text":" are self-contained blocks of functionality"},{"type":"text","text":" "},{"type":"text","text":"that can be passed around and used in your code."},{"type":"text","text":" "},{"type":"text","text":"Closures in Swift are similar to blocks in C and Objective-C"},{"type":"text","text":" "},{"type":"text","text":"and to lambdas in other programming languages."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/closures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators":{"role":"article","title":"Operadores Avançados","abstract":[{"type":"text","text":"Além dos operadores descritos no tópico "},{"type":"text","text":"doc:OperadoresBasicos"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"a linguagem Swift oferece o tópico Operadores Avançados que fazem manipulação de valores mais complexa."},{"type":"text","text":" "},{"type":"text","text":"Lá são incluídos operadores bit a bit e operadores com deslocamento que estamos familiarizados em C e Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/advancedoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/MemorySafety":{"role":"article","title":"Memory Safety","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift ensures that variables are initialized before they’re used,"},{"type":"text","text":" "},{"type":"text","text":"memory isn’t accessed after it’s been deallocated,"},{"type":"text","text":" "},{"type":"text","text":"and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/memorysafety"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AccessControl":{"role":"article","title":"Access Control","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"type":"text","text":" restricts access to parts of your code"},{"type":"text","text":" "},{"type":"text","text":"from code in other source files and modules."},{"type":"text","text":" "},{"type":"text","text":"This feature enables you to hide the implementation details of your code,"},{"type":"text","text":" "},{"type":"text","text":"and to specify a preferred interface through which that code can be accessed and used."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/accesscontrol"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Properties":{"role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Properties"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration."},{"type":"text","text":" "},{"type":"text","text":"Stored properties store constant and variable values as part of an instance,"},{"type":"text","text":" "},{"type":"text","text":"whereas computed properties calculate (rather than store) a value."},{"type":"text","text":" "},{"type":"text","text":"Computed properties are provided by classes, structures, and enumerations."},{"type":"text","text":" "},{"type":"text","text":"Stored properties are provided only by classes and structures."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/properties"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"role":"article","title":"Operadores básicos","abstract":[{"type":"text","text":"Um operador é um símbolo ou frase que você pode usar para verificar, mudar ou combinar valores."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, o operador de adição ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") soma dois números,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"e o operador lógico E ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"AND"}]},{"type":"text","text":" - "},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combina dois valores booleanos,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/basicoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Subscripts":{"role":"article","title":"Subscripts","abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscripts"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which are shortcuts for accessing the member elements of a collection, list, or sequence."},{"type":"text","text":" "},{"type":"text","text":"You use subscripts to set and retrieve values by index without needing"},{"type":"text","text":" "},{"type":"text","text":"separate methods for setting and retrieval."},{"type":"text","text":" "},{"type":"text","text":"For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" "},{"type":"text","text":"and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/subscripts"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures":{"role":"article","title":"Estruturas e Classes","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Estruturas"}]},{"type":"text","text":" e "},{"type":"emphasis","inlineContent":[{"type":"text","text":"classes"}]},{"type":"text","text":" são construções flexíveis de propósito geral que se tornam os blocos de construção do código do seu programa. Você define propriedades e métodos para adicionar funcionalidade às suas estruturas e classes usando a mesma sintaxe usada para definir constantes, variáveis e funções."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/classesandstructures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"role":"article","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task."},{"type":"text","text":" "},{"type":"text","text":"You give a function a name that identifies what it does,"},{"type":"text","text":" "},{"type":"text","text":"and this name is used to “call” the function to perform its task when needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"role":"article","title":"Error Handling","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Error handling"}]},{"type":"text","text":" is the process of responding to"},{"type":"text","text":" "},{"type":"text","text":"and recovering from error conditions in your program."},{"type":"text","text":" "},{"type":"text","text":"Swift provides first-class support for"},{"type":"text","text":" "},{"type":"text","text":"throwing, catching, propagating, and manipulating"},{"type":"text","text":" "},{"type":"text","text":"recoverable errors at runtime."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/errorhandling"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency":{"role":"article","title":"Concorrência","abstract":[{"type":"text","text":"Swift tem suporte por padrão para escrita de código assíncrono e paralelo"},{"type":"text","text":" "},{"type":"text","text":"de forma estruturada."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código assíncrono"}]},{"type":"text","text":" pode ser suspenso e retomado posteriormente,"},{"type":"text","text":" "},{"type":"text","text":"embora apenas uma parte do programa seja executada por vez."},{"type":"text","text":" "},{"type":"text","text":"Suspender e retomar código em seu programa"},{"type":"text","text":" "},{"type":"text","text":"permite que ele continue a progredir"},{"type":"text","text":" "},{"type":"text","text":"em operações de curto prazo, como atualizar a interface do usuário,"},{"type":"text","text":" "},{"type":"text","text":"enquanto continua a trabalhar em operações de longa duração"},{"type":"text","text":" "},{"type":"text","text":"como buscar dados pela rede ou analisar arquivos."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código paralelo"}]},{"type":"text","text":" significa vários pedaços de código executando simultaneamente —"},{"type":"text","text":" "},{"type":"text","text":"por exemplo, um computador com um processador de quatro núcleos"},{"type":"text","text":" "},{"type":"text","text":"pode executar quatro pedaços de código ao mesmo tempo,"},{"type":"text","text":" "},{"type":"text","text":"com cada núcleo realizando uma das tarefas."},{"type":"text","text":" "},{"type":"text","text":"Um programa que usa código paralelo e assíncrono"},{"type":"text","text":" "},{"type":"text","text":"realiza várias operações ao mesmo tempo;"},{"type":"text","text":" "},{"type":"text","text":"suspende as operações que estão à espera de um sistema externo,"},{"type":"text","text":" "},{"type":"text","text":"e torna mais fácil escrever esse código de maneira segura para a memória ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"memory-safe"}]},{"type":"text","text":")."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/concurrency"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/NestedTypes":{"role":"article","title":"Tipos Aninhados","abstract":[{"type":"text","text":"Enumerações são frequentemente criadas para dar suporte a uma funcionalidade especifica de uma classe ou estrutura."},{"type":"text","text":" "},{"type":"text","text":"Similarmente, pode ser conveniente definir classes e estruturas de utilidade"},{"type":"text","text":" "},{"type":"text","text":"puramente para o uso dentro de um contexto de um tipo mais complexo."},{"type":"text","text":" "},{"type":"text","text":"Para fazer isso, o Swift permite que você defina "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos aninhados"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"nos quais você aninha enumerações, classes e estruturas de suporte"},{"type":"text","text":" "},{"type":"text","text":"dentro da definição do tipo que elas suportam."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/nestedtypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OptionalChaining":{"role":"article","title":"Optional Chaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling"},{"type":"text","text":" "},{"type":"text","text":"properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the optional contains a value,"},{"type":"text","text":" "},{"type":"text","text":"the property, method, or subscript call succeeds;"},{"type":"text","text":" "},{"type":"text","text":"if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Multiple queries can be chained together,"},{"type":"text","text":" "},{"type":"text","text":"and the entire chain fails gracefully if any link in the chain is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/optionalchaining"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"role":"article","title":"Generics","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types"},{"type":"text","text":" "},{"type":"text","text":"that can work with any type, subject to requirements that you define."},{"type":"text","text":" "},{"type":"text","text":"You can write code that avoids duplication"},{"type":"text","text":" "},{"type":"text","text":"and expresses its intent in a clear, abstracted manner."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics"}}}