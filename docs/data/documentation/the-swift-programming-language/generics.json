{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Generics are one of the most powerful features of Swift,"},{"type":"text","text":" "},{"type":"text","text":"and much of the Swift standard library is built with generic code."},{"type":"text","text":" "},{"type":"text","text":"In fact, you’ve been using generics throughout the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Language Guide"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"even if you didn’t realize it."},{"type":"text","text":" "},{"type":"text","text":"For example, Swift’s "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" types"},{"type":"text","text":" "},{"type":"text","text":"are both generic collections."},{"type":"text","text":" "},{"type":"text","text":"You can create an array that holds "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"or an array that holds "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"or indeed an array for any other type that can be created in Swift."},{"type":"text","text":" "},{"type":"text","text":"Similarly, you can create a dictionary to store values of any specified type,"},{"type":"text","text":" "},{"type":"text","text":"and there are no limitations on what that type can be."}]},{"anchor":"The-Problem-That-Generics-Solve","level":2,"type":"heading","text":"The Problem That Generics Solve"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a standard, nongeneric function called "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which swaps two "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values:"}]},{"type":"codeListing","syntax":"swift","code":["func swapTwoInts(_ a: inout Int, _ b: inout Int) {","   let temporaryA = a","   a = b","   b = temporaryA","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This function makes use of in-out parameters to swap the values of "},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":" function swaps the original value of "},{"type":"codeVoice","code":"b"},{"type":"text","text":" into "},{"type":"codeVoice","code":"a"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the original value of "},{"type":"codeVoice","code":"a"},{"type":"text","text":" into "},{"type":"codeVoice","code":"b"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"You can call this function to swap the values in two "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" variables:"}]},{"type":"codeListing","syntax":"swift","code":["var someInt = 3","var anotherInt = 107","swapTwoInts(&someInt, &anotherInt)","print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")","\/\/ Prints \"someInt is now 107, and anotherInt is now 3\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":" function is useful, but it can only be used with "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values."},{"type":"text","text":" "},{"type":"text","text":"If you want to swap two "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"or two "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"you have to write more functions,"},{"type":"text","text":" "},{"type":"text","text":"such as the "},{"type":"codeVoice","code":"swapTwoStrings(_:_:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"swapTwoDoubles(_:_:)"},{"type":"text","text":" functions shown below:"}]},{"type":"codeListing","syntax":"swift","code":["func swapTwoStrings(_ a: inout String, _ b: inout String) {","   let temporaryA = a","   a = b","   b = temporaryA","}","","func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {","   let temporaryA = a","   a = b","   b = temporaryA","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You may have noticed that the bodies of"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":", "},{"type":"codeVoice","code":"swapTwoStrings(_:_:)"},{"type":"text","text":", and "},{"type":"codeVoice","code":"swapTwoDoubles(_:_:)"},{"type":"text","text":" functions are identical."},{"type":"text","text":" "},{"type":"text","text":"The only difference is the type of the values that they accept"},{"type":"text","text":" "},{"type":"text","text":"("},{"type":"codeVoice","code":"Int"},{"type":"text","text":", "},{"type":"codeVoice","code":"String"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Double"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s more useful, and considerably more flexible,"},{"type":"text","text":" "},{"type":"text","text":"to write a single function that swaps two values of "},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"Generic code enables you to write such a function."},{"type":"text","text":" "},{"type":"text","text":"(A generic version of these functions is defined below.)"}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In all three functions,"},{"type":"text","text":" "},{"type":"text","text":"the types of "},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"type":"text","text":" must be the same."},{"type":"text","text":" "},{"type":"text","text":"If "},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"type":"text","text":" aren’t of the same type,"},{"type":"text","text":" "},{"type":"text","text":"it isn’t possible to swap their values."},{"type":"text","text":" "},{"type":"text","text":"Swift is a type-safe language,"},{"type":"text","text":" "},{"type":"text","text":"and doesn’t allow (for example) a variable of type "},{"type":"codeVoice","code":"String"},{"type":"text","text":" "},{"type":"text","text":"and a variable of type "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" "},{"type":"text","text":"to swap values with each other."},{"type":"text","text":" "},{"type":"text","text":"Attempting to do so results in a compile-time error."}]}],"type":"aside","name":"Note"},{"anchor":"Generic-Functions","level":2,"type":"heading","text":"Generic Functions"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic functions"}]},{"type":"text","text":" can work with any type."},{"type":"text","text":" "},{"type":"text","text":"Here’s a generic version of the "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":" function from above,"},{"type":"text","text":" "},{"type":"text","text":"called "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["func swapTwoValues<T>(_ a: inout T, _ b: inout T) {","   let temporaryA = a","   a = b","   b = temporaryA","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The body of the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"is identical to the body of the "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":" function."},{"type":"text","text":" "},{"type":"text","text":"However, the first line of "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" "},{"type":"text","text":"is slightly different from "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Here’s how the first lines compare:"}]},{"type":"codeListing","syntax":"swift","code":["func swapTwoInts(_ a: inout Int, _ b: inout Int)","func swapTwoValues<T>(_ a: inout T, _ b: inout T)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The generic version of the function"},{"type":"text","text":" "},{"type":"text","text":"uses a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"placeholder"}]},{"type":"text","text":" type name (called "},{"type":"codeVoice","code":"T"},{"type":"text","text":", in this case)"},{"type":"text","text":" "},{"type":"text","text":"instead of an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"actual"}]},{"type":"text","text":" type name (such as "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", "},{"type":"codeVoice","code":"String"},{"type":"text","text":", or "},{"type":"codeVoice","code":"Double"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"The placeholder type name doesn’t say anything about what "},{"type":"codeVoice","code":"T"},{"type":"text","text":" must be,"},{"type":"text","text":" "},{"type":"text","text":"but it "},{"type":"emphasis","inlineContent":[{"type":"text","text":"does"}]},{"type":"text","text":" say that both "},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"type":"text","text":" must be of the same type "},{"type":"codeVoice","code":"T"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"whatever "},{"type":"codeVoice","code":"T"},{"type":"text","text":" represents."},{"type":"text","text":" "},{"type":"text","text":"The actual type to use in place of "},{"type":"codeVoice","code":"T"},{"type":"text","text":" "},{"type":"text","text":"is determined each time the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function is called."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The other difference between a generic function and a nongeneric function"},{"type":"text","text":" "},{"type":"text","text":"is that the generic function’s name ("},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"is followed by the placeholder type name ("},{"type":"codeVoice","code":"T"},{"type":"text","text":") inside angle brackets ("},{"type":"codeVoice","code":"<T>"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"The brackets tell Swift that "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is a placeholder type name"},{"type":"text","text":" "},{"type":"text","text":"within the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function definition."},{"type":"text","text":" "},{"type":"text","text":"Because "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is a placeholder, Swift doesn’t look for an actual type called "},{"type":"codeVoice","code":"T"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function can now be called in the same way as "},{"type":"codeVoice","code":"swapTwoInts"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"except that it can be passed two values of "},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"type":"text","text":" type,"},{"type":"text","text":" "},{"type":"text","text":"as long as both of those values are of the same type as each other."},{"type":"text","text":" "},{"type":"text","text":"Each time "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" is called,"},{"type":"text","text":" "},{"type":"text","text":"the type to use for "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is inferred from the types of values passed to the function."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the two examples below, "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is inferred to be "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" and "},{"type":"codeVoice","code":"String"},{"type":"text","text":" respectively:"}]},{"type":"codeListing","syntax":"swift","code":["var someInt = 3","var anotherInt = 107","swapTwoValues(&someInt, &anotherInt)","\/\/ someInt is now 107, and anotherInt is now 3","","var someString = \"hello\"","var anotherString = \"world\"","swapTwoValues(&someString, &anotherString)","\/\/ someString is now \"world\", and anotherString is now \"hello\""]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function defined above is inspired by"},{"type":"text","text":" "},{"type":"text","text":"a generic function called "},{"type":"codeVoice","code":"swap"},{"type":"text","text":", which is part of the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"and is automatically made available for you to use in your apps."},{"type":"text","text":" "},{"type":"text","text":"If you need the behavior of the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function in your own code,"},{"type":"text","text":" "},{"type":"text","text":"you can use Swift’s existing "},{"type":"codeVoice","code":"swap(_:_:)"},{"type":"text","text":" function rather than providing your own implementation."}]}],"type":"aside","name":"Note"},{"anchor":"Type-Parameters","level":2,"type":"heading","text":"Type Parameters"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" example above,"},{"type":"text","text":" "},{"type":"text","text":"the placeholder type "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is an example of a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type parameter"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Type parameters specify and name a placeholder type,"},{"type":"text","text":" "},{"type":"text","text":"and are written immediately after the function’s name,"},{"type":"text","text":" "},{"type":"text","text":"between a pair of matching angle brackets (such as "},{"type":"codeVoice","code":"<T>"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once you specify a type parameter,"},{"type":"text","text":" "},{"type":"text","text":"you can use it to define the type of a function’s parameters"},{"type":"text","text":" "},{"type":"text","text":"(such as the "},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"type":"text","text":" parameters of the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function),"},{"type":"text","text":" "},{"type":"text","text":"or as the function’s return type,"},{"type":"text","text":" "},{"type":"text","text":"or as a type annotation within the body of the function."},{"type":"text","text":" "},{"type":"text","text":"In each case, the type parameter"},{"type":"text","text":" "},{"type":"text","text":"is replaced with an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"actual"}]},{"type":"text","text":" type whenever the function is called."},{"type":"text","text":" "},{"type":"text","text":"(In the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" example above,"},{"type":"text","text":" "},{"type":"codeVoice","code":"T"},{"type":"text","text":" was replaced with "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" the first time the function was called,"},{"type":"text","text":" "},{"type":"text","text":"and was replaced with "},{"type":"codeVoice","code":"String"},{"type":"text","text":" the second time it was called.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can provide more than one type parameter"},{"type":"text","text":" "},{"type":"text","text":"by writing multiple type parameter names within the angle brackets,"},{"type":"text","text":" "},{"type":"text","text":"separated by commas."}]},{"anchor":"Naming-Type-Parameters","level":2,"type":"heading","text":"Naming Type Parameters"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In most cases, type parameters have descriptive names,"},{"type":"text","text":" "},{"type":"text","text":"such as "},{"type":"codeVoice","code":"Key"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" in "},{"type":"codeVoice","code":"Dictionary<Key, Value>"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" in "},{"type":"codeVoice","code":"Array<Element>"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which tells the reader about the relationship between the type parameter"},{"type":"text","text":" "},{"type":"text","text":"and the generic type or function it’s used in."},{"type":"text","text":" "},{"type":"text","text":"However, when there isn’t a meaningful relationship between them,"},{"type":"text","text":" "},{"type":"text","text":"it’s traditional to name them using single letters such as "},{"type":"codeVoice","code":"T"},{"type":"text","text":", "},{"type":"codeVoice","code":"U"},{"type":"text","text":", and "},{"type":"codeVoice","code":"V"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"such as "},{"type":"codeVoice","code":"T"},{"type":"text","text":" in the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function above."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Always give type parameters upper camel case names"},{"type":"text","text":" "},{"type":"text","text":"(such as "},{"type":"codeVoice","code":"T"},{"type":"text","text":" and "},{"type":"codeVoice","code":"MyTypeParameter"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"to indicate that they’re a placeholder for a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":", not a value."}]}],"type":"aside","name":"Note"},{"anchor":"Generic-Types","level":2,"type":"heading","text":"Generic Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition to generic functions,"},{"type":"text","text":" "},{"type":"text","text":"Swift enables you to define your own "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic types"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"These are custom classes, structures, and enumerations"},{"type":"text","text":" "},{"type":"text","text":"that can work with "},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"type":"text","text":" type, in a similar way to "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This section shows you how to write a generic collection type called "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"A stack is an ordered set of values, similar to an array,"},{"type":"text","text":" "},{"type":"text","text":"but with a more restricted set of operations than Swift’s "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"An array allows new items to be inserted and removed at any location in the array."},{"type":"text","text":" "},{"type":"text","text":"A stack, however, allows new items to be appended only to the end of the collection"},{"type":"text","text":" "},{"type":"text","text":"(known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pushing"}]},{"type":"text","text":" a new value on to the stack)."},{"type":"text","text":" "},{"type":"text","text":"Similarly, a stack allows items to be removed only from the end of the collection"},{"type":"text","text":" "},{"type":"text","text":"(known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"popping"}]},{"type":"text","text":" a value off the stack)."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The concept of a stack is used by the "},{"type":"codeVoice","code":"UINavigationController"},{"type":"text","text":" class"},{"type":"text","text":" "},{"type":"text","text":"to model the view controllers in its navigation hierarchy."},{"type":"text","text":" "},{"type":"text","text":"You call the "},{"type":"codeVoice","code":"UINavigationController"},{"type":"text","text":" class"},{"type":"text","text":" "},{"type":"codeVoice","code":"pushViewController(_:animated:)"},{"type":"text","text":" method to add (or push)"},{"type":"text","text":" "},{"type":"text","text":"a view controller on to the navigation stack,"},{"type":"text","text":" "},{"type":"text","text":"and its "},{"type":"codeVoice","code":"popViewControllerAnimated(_:)"},{"type":"text","text":" method to remove (or pop)"},{"type":"text","text":" "},{"type":"text","text":"a view controller from the navigation stack."},{"type":"text","text":" "},{"type":"text","text":"A stack is a useful collection model whenever you need a strict"},{"type":"text","text":" "},{"type":"text","text":"“last in, first out” approach to managing a collection."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The illustration below shows the push and pop behavior for a stack:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"stackPushPop"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"There are currently three values on the stack."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A fourth value is pushed onto the top of the stack."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The stack now holds four values, with the most recent one at the top."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The top item in the stack is popped."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"After popping a value, the stack once again holds three values."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how to write a nongeneric version of a stack,"},{"type":"text","text":" "},{"type":"text","text":"in this case for a stack of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values:"}]},{"type":"codeListing","syntax":"swift","code":["struct IntStack {","   var items: [Int] = []","   mutating func push(_ item: Int) {","      items.append(item)","   }","   mutating func pop() -> Int {","      return items.removeLast()","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This structure uses an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" property called "},{"type":"codeVoice","code":"items"},{"type":"text","text":" to store the values in the stack."},{"type":"text","text":" "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" provides two methods, "},{"type":"codeVoice","code":"push"},{"type":"text","text":" and "},{"type":"codeVoice","code":"pop"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"to push and pop values on and off the stack."},{"type":"text","text":" "},{"type":"text","text":"These methods are marked as "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"because they need to modify (or "},{"type":"emphasis","inlineContent":[{"type":"text","text":"mutate"}]},{"type":"text","text":") the structure’s "},{"type":"codeVoice","code":"items"},{"type":"text","text":" array."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" type shown above can only be used with "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values, however."},{"type":"text","text":" "},{"type":"text","text":"It would be much more useful to define a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" structure,"},{"type":"text","text":" "},{"type":"text","text":"that can manage a stack of "},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"type":"text","text":" type of value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a generic version of the same code:"}]},{"type":"codeListing","syntax":"swift","code":["struct Stack<Element> {","   var items: [Element] = []","   mutating func push(_ item: Element) {","      items.append(item)","   }","   mutating func pop() -> Element {","      return items.removeLast()","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note how the generic version of "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" "},{"type":"text","text":"is essentially the same as the nongeneric version,"},{"type":"text","text":" "},{"type":"text","text":"but with a type parameter called "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" "},{"type":"text","text":"instead of an actual type of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This type parameter is written within a pair of angle brackets ("},{"type":"codeVoice","code":"<Element>"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"immediately after the structure’s name."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Element"},{"type":"text","text":" defines a placeholder name for"},{"type":"text","text":" "},{"type":"text","text":"a type to be provided later."},{"type":"text","text":" "},{"type":"text","text":"This future type can be referred to as "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" "},{"type":"text","text":"anywhere within the structure’s definition."},{"type":"text","text":" "},{"type":"text","text":"In this case, "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" is used as a placeholder in three places:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To create a property called "},{"type":"codeVoice","code":"items"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which is initialized with an empty array of values of type "},{"type":"codeVoice","code":"Element"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To specify that the "},{"type":"codeVoice","code":"push(_:)"},{"type":"text","text":" method has a single parameter called "},{"type":"codeVoice","code":"item"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which must be of type "},{"type":"codeVoice","code":"Element"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To specify that the value returned by the "},{"type":"codeVoice","code":"pop()"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"will be a value of type "},{"type":"codeVoice","code":"Element"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because it’s a generic type,"},{"type":"text","text":" "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" can be used to create a stack of "},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"type":"text","text":" valid type in Swift,"},{"type":"text","text":" "},{"type":"text","text":"in a similar manner to "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You create a new "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" instance by writing"},{"type":"text","text":" "},{"type":"text","text":"the type to be stored in the stack within angle brackets."},{"type":"text","text":" "},{"type":"text","text":"For example, to create a new stack of strings,"},{"type":"text","text":" "},{"type":"text","text":"you write "},{"type":"codeVoice","code":"Stack<String>()"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["var stackOfStrings = Stack<String>()","stackOfStrings.push(\"uno\")","stackOfStrings.push(\"dos\")","stackOfStrings.push(\"tres\")","stackOfStrings.push(\"cuatro\")","\/\/ the stack now contains 4 strings"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how "},{"type":"codeVoice","code":"stackOfStrings"},{"type":"text","text":" looks after pushing these four values on to the stack:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"stackPushedFourStrings"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Popping a value from the stack removes and returns the top value, "},{"type":"codeVoice","code":"\"cuatro\""},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let fromTheTop = stackOfStrings.pop()","\/\/ fromTheTop is equal to \"cuatro\", and the stack now contains 3 strings"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how the stack looks after popping its top value:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"stackPoppedOneString"}]},{"anchor":"Extending-a-Generic-Type","level":2,"type":"heading","text":"Extending a Generic Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you extend a generic type,"},{"type":"text","text":" "},{"type":"text","text":"you don’t provide a type parameter list as part of the extension’s definition."},{"type":"text","text":" "},{"type":"text","text":"Instead, the type parameter list from the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"original"}]},{"type":"text","text":" type definition"},{"type":"text","text":" "},{"type":"text","text":"is available within the body of the extension,"},{"type":"text","text":" "},{"type":"text","text":"and the original type parameter names are used to refer to"},{"type":"text","text":" "},{"type":"text","text":"the type parameters from the original definition."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example extends the generic "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" type to add"},{"type":"text","text":" "},{"type":"text","text":"a read-only computed property called "},{"type":"codeVoice","code":"topItem"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which returns the top item on the stack without popping it from the stack:"}]},{"type":"codeListing","syntax":"swift","code":["extension Stack {","   var topItem: Element? {","      return items.isEmpty ? nil : items[items.count - 1]","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"topItem"},{"type":"text","text":" property returns an optional value of type "},{"type":"codeVoice","code":"Element"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the stack is empty, "},{"type":"codeVoice","code":"topItem"},{"type":"text","text":" returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":";"},{"type":"text","text":" "},{"type":"text","text":"if the stack isn’t empty, "},{"type":"codeVoice","code":"topItem"},{"type":"text","text":" returns the final item in the "},{"type":"codeVoice","code":"items"},{"type":"text","text":" array."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that this extension doesn’t define a type parameter list."},{"type":"text","text":" "},{"type":"text","text":"Instead, the "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" type’s existing type parameter name, "},{"type":"codeVoice","code":"Element"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"is used within the extension to indicate the optional type of"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"topItem"},{"type":"text","text":" computed property."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"topItem"},{"type":"text","text":" computed property can now be used with any "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" instance"},{"type":"text","text":" "},{"type":"text","text":"to access and query its top item without removing it."}]},{"type":"codeListing","syntax":"swift","code":["if let topItem = stackOfStrings.topItem {","   print(\"The top item on the stack is \\(topItem).\")","}","\/\/ Prints \"The top item on the stack is tres.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions of a generic type can also include requirements"},{"type":"text","text":" "},{"type":"text","text":"that instances of the extended type must satisfy"},{"type":"text","text":" "},{"type":"text","text":"in order to gain the new functionality,"},{"type":"text","text":" "},{"type":"text","text":"as discussed in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Extensions-with-a-Generic-Where-Clause"},{"type":"text","text":" below."}]},{"anchor":"Type-Constraints","level":2,"type":"heading","text":"Type Constraints"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function and the "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" type can work with any type."},{"type":"text","text":" "},{"type":"text","text":"However, it’s sometimes useful to enforce"},{"type":"text","text":" "},{"type":"text","text":"certain "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type constraints"}]},{"type":"text","text":" on the types that can be used with"},{"type":"text","text":" "},{"type":"text","text":"generic functions and generic types."},{"type":"text","text":" "},{"type":"text","text":"Type constraints specify that a type parameter must"},{"type":"text","text":" "},{"type":"text","text":"inherit from a specific class,"},{"type":"text","text":" "},{"type":"text","text":"or conform to a particular protocol or protocol composition."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift’s "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" type places a limitation on"},{"type":"text","text":" "},{"type":"text","text":"the types that can be used as keys for a dictionary."},{"type":"text","text":" "},{"type":"text","text":"As described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Dictionaries"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the type of a dictionary’s keys must be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"hashable"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"That is, it must provide a way to make itself uniquely representable."},{"type":"text","text":" "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" needs its keys to be hashable so that it can"},{"type":"text","text":" "},{"type":"text","text":"check whether it already contains a value for a particular key."},{"type":"text","text":" "},{"type":"text","text":"Without this requirement, "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" couldn’t tell"},{"type":"text","text":" "},{"type":"text","text":"whether it should insert or replace a value for a particular key,"},{"type":"text","text":" "},{"type":"text","text":"nor would it be able to find a value for a given key that’s already in the dictionary."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This requirement is enforced by a type constraint on the key type for "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which specifies that the key type must conform to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"a special protocol defined in the Swift standard library."},{"type":"text","text":" "},{"type":"text","text":"All of Swift’s basic types (such as "},{"type":"codeVoice","code":"String"},{"type":"text","text":", "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", "},{"type":"codeVoice","code":"Double"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"are hashable by default."},{"type":"text","text":" "},{"type":"text","text":"For information about"},{"type":"text","text":" "},{"type":"text","text":"making your own custom types conform to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/hashable#2849490"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can define your own type constraints when creating custom generic types,"},{"type":"text","text":" "},{"type":"text","text":"and these constraints provide much of the power of generic programming."},{"type":"text","text":" "},{"type":"text","text":"Abstract concepts like "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" "},{"type":"text","text":"characterize types in terms of their conceptual characteristics,"},{"type":"text","text":" "},{"type":"text","text":"rather than their concrete type."}]},{"anchor":"Type-Constraint-Syntax","level":3,"type":"heading","text":"Type Constraint Syntax"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You write type constraints by placing a single class or protocol constraint"},{"type":"text","text":" "},{"type":"text","text":"after a type parameter’s name, separated by a colon,"},{"type":"text","text":" "},{"type":"text","text":"as part of the type parameter list."},{"type":"text","text":" "},{"type":"text","text":"The basic syntax for type constraints on a generic function is shown below"},{"type":"text","text":" "},{"type":"text","text":"(although the syntax is the same for generic types):"}]},{"type":"codeListing","syntax":"swift","code":["func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {","   \/\/ function body goes here","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The hypothetical function above has two type parameters."},{"type":"text","text":" "},{"type":"text","text":"The first type parameter, "},{"type":"codeVoice","code":"T"},{"type":"text","text":", has a type constraint"},{"type":"text","text":" "},{"type":"text","text":"that requires "},{"type":"codeVoice","code":"T"},{"type":"text","text":" to be a subclass of "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The second type parameter, "},{"type":"codeVoice","code":"U"},{"type":"text","text":", has a type constraint"},{"type":"text","text":" "},{"type":"text","text":"that requires "},{"type":"codeVoice","code":"U"},{"type":"text","text":" to conform to the protocol "},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":"."}]},{"anchor":"Type-Constraints-in-Action","level":3,"type":"heading","text":"Type Constraints in Action"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a nongeneric function called "},{"type":"codeVoice","code":"findIndex(ofString:in:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which is given a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value to find"},{"type":"text","text":" "},{"type":"text","text":"and an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values within which to find it."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"findIndex(ofString:in:)"},{"type":"text","text":" function returns an optional "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value,"},{"type":"text","text":" "},{"type":"text","text":"which will be the index of the first matching string in the array if it’s found,"},{"type":"text","text":" "},{"type":"text","text":"or "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" if the string can’t be found:"}]},{"type":"codeListing","syntax":"swift","code":["func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {","   for (index, value) in array.enumerated() {","      if value == valueToFind {","         return index","      }","   }","   return nil","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"findIndex(ofString:in:)"},{"type":"text","text":" function can be used to find a string value in an array of strings:"}]},{"type":"codeListing","syntax":"swift","code":["let strings = [\"cat\", \"dog\", \"llama\", \"parakeet\", \"terrapin\"]","if let foundIndex = findIndex(ofString: \"llama\", in: strings) {","   print(\"The index of llama is \\(foundIndex)\")","}","\/\/ Prints \"The index of llama is 2\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The principle of finding the index of a value in an array isn’t useful only for strings, however."},{"type":"text","text":" "},{"type":"text","text":"You can write the same functionality as a generic function"},{"type":"text","text":" "},{"type":"text","text":"by replacing any mention of strings with values of some type "},{"type":"codeVoice","code":"T"},{"type":"text","text":" instead."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how you might expect a generic version of "},{"type":"codeVoice","code":"findIndex(ofString:in:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"called "},{"type":"codeVoice","code":"findIndex(of:in:)"},{"type":"text","text":", to be written."},{"type":"text","text":" "},{"type":"text","text":"Note that the return type of this function is still "},{"type":"codeVoice","code":"Int?"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"because the function returns an optional index number,"},{"type":"text","text":" "},{"type":"text","text":"not an optional value from the array."},{"type":"text","text":" "},{"type":"text","text":"Be warned, though — this function doesn’t compile,"},{"type":"text","text":" "},{"type":"text","text":"for reasons explained after the example:"}]},{"type":"codeListing","syntax":"swift","code":["func findIndex<T>(of valueToFind: T, in array:[T]) -> Int? {","   for (index, value) in array.enumerated() {","      if value == valueToFind {","         return index","      }","   }","   return nil","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This function doesn’t compile as written above."},{"type":"text","text":" "},{"type":"text","text":"The problem lies with the equality check, “"},{"type":"codeVoice","code":"if value == valueToFind"},{"type":"text","text":"”."},{"type":"text","text":" "},{"type":"text","text":"Not every type in Swift can be compared with the equal to operator ("},{"type":"codeVoice","code":"=="},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"If you create your own class or structure to represent a complex data model, for example,"},{"type":"text","text":" "},{"type":"text","text":"then the meaning of “equal to” for that class or structure"},{"type":"text","text":" "},{"type":"text","text":"isn’t something that Swift can guess for you."},{"type":"text","text":" "},{"type":"text","text":"Because of this, it isn’t possible to guarantee that this code will work"},{"type":"text","text":" "},{"type":"text","text":"for "},{"type":"emphasis","inlineContent":[{"type":"text","text":"every"}]},{"type":"text","text":" possible type "},{"type":"codeVoice","code":"T"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and an appropriate error is reported when you try to compile the code."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All is not lost, however."},{"type":"text","text":" "},{"type":"text","text":"The Swift standard library defines a protocol called "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which requires any conforming type to implement"},{"type":"text","text":" "},{"type":"text","text":"the equal to operator ("},{"type":"codeVoice","code":"=="},{"type":"text","text":") and the not equal to operator ("},{"type":"codeVoice","code":"!="},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"to compare any two values of that type."},{"type":"text","text":" "},{"type":"text","text":"All of Swift’s standard types automatically support the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any type that’s "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" can be used safely with the "},{"type":"codeVoice","code":"findIndex(of:in:)"},{"type":"text","text":" function,"},{"type":"text","text":" "},{"type":"text","text":"because it’s guaranteed to support the equal to operator."},{"type":"text","text":" "},{"type":"text","text":"To express this fact, you write a type constraint of "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" "},{"type":"text","text":"as part of the type parameter’s definition when you define the function:"}]},{"type":"codeListing","syntax":"swift","code":["func findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -> Int? {","   for (index, value) in array.enumerated() {","      if value == valueToFind {","         return index","      }","   }","   return nil","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The single type parameter for "},{"type":"codeVoice","code":"findIndex(of:in:)"},{"type":"text","text":" is written as "},{"type":"codeVoice","code":"T: Equatable"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which means “any type "},{"type":"codeVoice","code":"T"},{"type":"text","text":" that conforms to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol.”"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"findIndex(of:in:)"},{"type":"text","text":" function now compiles successfully"},{"type":"text","text":" "},{"type":"text","text":"and can be used with any type that’s "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":", such as "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" or "},{"type":"codeVoice","code":"String"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])","\/\/ doubleIndex is an optional Int with no value, because 9.3 isn't in the array","let stringIndex = findIndex(of: \"Andrea\", in: [\"Mike\", \"Malcolm\", \"Andrea\"])","\/\/ stringIndex is an optional Int containing a value of 2"]},{"anchor":"Associated-Types","level":2,"type":"heading","text":"Associated Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When defining a protocol,"},{"type":"text","text":" "},{"type":"text","text":"it’s sometimes useful to declare one or more associated types"},{"type":"text","text":" "},{"type":"text","text":"as part of the protocol’s definition."},{"type":"text","text":" "},{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"associated type"}]},{"type":"text","text":" gives a placeholder name"},{"type":"text","text":" "},{"type":"text","text":"to a type that’s used as part of the protocol."},{"type":"text","text":" "},{"type":"text","text":"The actual type to use for that associated type"},{"type":"text","text":" "},{"type":"text","text":"isn’t specified until the protocol is adopted."},{"type":"text","text":" "},{"type":"text","text":"Associated types are specified with the "},{"type":"codeVoice","code":"associatedtype"},{"type":"text","text":" keyword."}]},{"anchor":"Associated-Types-in-Action","level":3,"type":"heading","text":"Associated Types in Action"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a protocol called "},{"type":"codeVoice","code":"Container"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which declares an associated type called "},{"type":"codeVoice","code":"Item"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["protocol Container {","   associatedtype Item","   mutating func append(_ item: Item)","   var count: Int { get }","   subscript(i: Int) -> Item { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol defines three required capabilities"},{"type":"text","text":" "},{"type":"text","text":"that any container must provide:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It must be possible to add a new item to the container with an "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It must be possible to access a count of the items in the container"},{"type":"text","text":" "},{"type":"text","text":"through a "},{"type":"codeVoice","code":"count"},{"type":"text","text":" property that returns an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It must be possible to retrieve each item in the container with a subscript"},{"type":"text","text":" "},{"type":"text","text":"that takes an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" index value."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This protocol doesn’t specify how the items in the container should be stored"},{"type":"text","text":" "},{"type":"text","text":"or what type they’re allowed to be."},{"type":"text","text":" "},{"type":"text","text":"The protocol only specifies the three bits of functionality"},{"type":"text","text":" "},{"type":"text","text":"that any type must provide in order to be considered a "},{"type":"codeVoice","code":"Container"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"A conforming type can provide additional functionality,"},{"type":"text","text":" "},{"type":"text","text":"as long as it satisfies these three requirements."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any type that conforms to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol must be able to specify"},{"type":"text","text":" "},{"type":"text","text":"the type of values it stores."},{"type":"text","text":" "},{"type":"text","text":"Specifically, it must ensure that only items of the right type"},{"type":"text","text":" "},{"type":"text","text":"are added to the container,"},{"type":"text","text":" "},{"type":"text","text":"and it must be clear about the type of the items returned by its subscript."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To define these requirements,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol needs a way to refer to"},{"type":"text","text":" "},{"type":"text","text":"the type of the elements that a container will hold,"},{"type":"text","text":" "},{"type":"text","text":"without knowing what that type is for a specific container."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol needs to specify that"},{"type":"text","text":" "},{"type":"text","text":"any value passed to the "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"must have the same type as the container’s element type,"},{"type":"text","text":" "},{"type":"text","text":"and that the value returned by the container’s subscript"},{"type":"text","text":" "},{"type":"text","text":"will be of the same type as the container’s element type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To achieve this,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol declares an associated type called "},{"type":"codeVoice","code":"Item"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"written as  "},{"type":"codeVoice","code":"associatedtype Item"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The protocol doesn’t define what "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" is —"},{"type":"text","text":" "},{"type":"text","text":"that information is left for any conforming type to provide."},{"type":"text","text":" "},{"type":"text","text":"Nonetheless, the "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" alias provides a way to refer to"},{"type":"text","text":" "},{"type":"text","text":"the type of the items in a "},{"type":"codeVoice","code":"Container"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and to define a type for use with the "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method and subscript,"},{"type":"text","text":" "},{"type":"text","text":"to ensure that the expected behavior of any "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" is enforced."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a version of the nongeneric "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" type"},{"type":"text","text":" "},{"type":"text","text":"from "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Types"},{"type":"text","text":" above,"},{"type":"text","text":" "},{"type":"text","text":"adapted to conform to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["struct IntStack: Container {","   \/\/ original IntStack implementation","   var items: [Int] = []","   mutating func push(_ item: Int) {","      items.append(item)","   }","   mutating func pop() -> Int {","      return items.removeLast()","   }","   \/\/ conformance to the Container protocol","   typealias Item = Int","   mutating func append(_ item: Int) {","      self.push(item)","   }","   var count: Int {","      return items.count","   }","   subscript(i: Int) -> Int {","      return items[i]","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" type implements all three of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol’s requirements,"},{"type":"text","text":" "},{"type":"text","text":"and in each case wraps part of the "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" type’s existing functionality"},{"type":"text","text":" "},{"type":"text","text":"to satisfy these requirements."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Moreover, "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" specifies that for this implementation of "},{"type":"codeVoice","code":"Container"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the appropriate "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" to use is a type of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The definition of "},{"type":"codeVoice","code":"typealias Item = Int"},{"type":"text","text":" turns the abstract type of "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" "},{"type":"text","text":"into a concrete type of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" for this implementation of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Thanks to Swift’s type inference,"},{"type":"text","text":" "},{"type":"text","text":"you don’t actually need to declare a concrete "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" "},{"type":"text","text":"as part of the definition of "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Because "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" conforms to all of the requirements of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"Swift can infer the appropriate "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" to use,"},{"type":"text","text":" "},{"type":"text","text":"simply by looking at the type of the "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method’s "},{"type":"codeVoice","code":"item"},{"type":"text","text":" parameter"},{"type":"text","text":" "},{"type":"text","text":"and the return type of the subscript."},{"type":"text","text":" "},{"type":"text","text":"Indeed, if you delete the "},{"type":"codeVoice","code":"typealias Item = Int"},{"type":"text","text":" line from the code above,"},{"type":"text","text":" "},{"type":"text","text":"everything still works, because it’s clear what type should be used for "},{"type":"codeVoice","code":"Item"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also make the generic "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" type conform to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["struct Stack<Element>: Container {","   \/\/ original Stack<Element> implementation","   var items: [Element] = []","   mutating func push(_ item: Element) {","      items.append(item)","   }","   mutating func pop() -> Element {","      return items.removeLast()","   }","   \/\/ conformance to the Container protocol","   mutating func append(_ item: Element) {","      self.push(item)","   }","   var count: Int {","      return items.count","   }","   subscript(i: Int) -> Element {","      return items[i]","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This time, the type parameter "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" is used as"},{"type":"text","text":" "},{"type":"text","text":"the type of the "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method’s "},{"type":"codeVoice","code":"item"},{"type":"text","text":" parameter"},{"type":"text","text":" "},{"type":"text","text":"and the return type of the subscript."},{"type":"text","text":" "},{"type":"text","text":"Swift can therefore infer that "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" is the appropriate type to use"},{"type":"text","text":" "},{"type":"text","text":"as the "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" for this particular container."}]},{"anchor":"Extending-an-Existing-Type-to-Specify-an-Associated-Type","level":3,"type":"heading","text":"Extending an Existing Type to Specify an Associated Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can extend an existing type to add conformance to a protocol,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adding-Protocol-Conformance-with-an-Extension"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This includes a protocol with an associated type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift’s "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" type already provides an "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method,"},{"type":"text","text":" "},{"type":"text","text":"a "},{"type":"codeVoice","code":"count"},{"type":"text","text":" property, and a subscript with an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" index to retrieve its elements."},{"type":"text","text":" "},{"type":"text","text":"These three capabilities match the requirements of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"This means that you can extend "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" to conform to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"simply by declaring that "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" adopts the protocol."},{"type":"text","text":" "},{"type":"text","text":"You do this with an empty extension,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Declaring-Protocol-Adoption-with-an-Extension"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["extension Array: Container {}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Array’s existing "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method and subscript enable Swift to infer"},{"type":"text","text":" "},{"type":"text","text":"the appropriate type to use for "},{"type":"codeVoice","code":"Item"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"just as for the generic "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" type above."},{"type":"text","text":" "},{"type":"text","text":"After defining this extension, you can use any "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" as a "},{"type":"codeVoice","code":"Container"},{"type":"text","text":"."}]},{"anchor":"Adding-Constraints-to-an-Associated-Type","level":3,"type":"heading","text":"Adding Constraints to an Associated Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can add type constraints to an associated type in a protocol"},{"type":"text","text":" "},{"type":"text","text":"to require that conforming types satisfy those constraints."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the following code defines a version of "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" "},{"type":"text","text":"that requires the items in the container to be equatable."}]},{"type":"codeListing","syntax":"swift","code":["protocol Container {","   associatedtype Item: Equatable","   mutating func append(_ item: Item)","   var count: Int { get }","   subscript(i: Int) -> Item { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To conform to this version of "},{"type":"codeVoice","code":"Container"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the container’s "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type has to conform to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol."}]},{"anchor":"Using-a-Protocol-in-Its-Associated-Types-Constraints","level":3,"type":"heading","text":"Using a Protocol in Its Associated Type’s Constraints"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A protocol can appear as part of its own requirements."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"here’s a protocol that refines the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"adding the requirement of a "},{"type":"codeVoice","code":"suffix(_:)"},{"type":"text","text":" method."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"suffix(_:)"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"returns a given number of elements from the end of the container,"},{"type":"text","text":" "},{"type":"text","text":"storing them in an instance of the "},{"type":"codeVoice","code":"Suffix"},{"type":"text","text":" type."}]},{"type":"codeListing","syntax":"swift","code":["protocol SuffixableContainer: Container {","    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item","    func suffix(_ size: Int) -> Suffix","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this protocol,"},{"type":"text","text":" "},{"type":"codeVoice","code":"Suffix"},{"type":"text","text":" is an associated type,"},{"type":"text","text":" "},{"type":"text","text":"like the "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type in the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" example above."},{"type":"text","text":" "},{"type":"codeVoice","code":"Suffix"},{"type":"text","text":" has two constraints:"},{"type":"text","text":" "},{"type":"text","text":"It must conform to the "},{"type":"codeVoice","code":"SuffixableContainer"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"(the protocol currently being defined),"},{"type":"text","text":" "},{"type":"text","text":"and its "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type must be the same"},{"type":"text","text":" "},{"type":"text","text":"as the container’s "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"The constraint on "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" is a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause,"},{"type":"text","text":" "},{"type":"text","text":"which is discussed in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Associated-Types-with-a-Generic-Where-Clause"},{"type":"text","text":" below."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an extension of the "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" type"},{"type":"text","text":" "},{"type":"text","text":"from "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Types"},{"type":"text","text":" above"},{"type":"text","text":" "},{"type":"text","text":"that adds conformance to the "},{"type":"codeVoice","code":"SuffixableContainer"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["extension Stack: SuffixableContainer {","    func suffix(_ size: Int) -> Stack {","        var result = Stack()","        for index in (count-size)..<count {","            result.append(self[index])","        }","        return result","    }","    \/\/ Inferred that Suffix is Stack.","}","var stackOfInts = Stack<Int>()","stackOfInts.append(10)","stackOfInts.append(20)","stackOfInts.append(30)","let suffix = stackOfInts.suffix(2)","\/\/ suffix contains 20 and 30"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Suffix"},{"type":"text","text":" associated type for "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" is also "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"so the suffix operation on "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" returns another "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Alternatively,"},{"type":"text","text":" "},{"type":"text","text":"a type that conforms to "},{"type":"codeVoice","code":"SuffixableContainer"},{"type":"text","text":" "},{"type":"text","text":"can have a "},{"type":"codeVoice","code":"Suffix"},{"type":"text","text":" type that’s different from itself —"},{"type":"text","text":" "},{"type":"text","text":"meaning the suffix operation can return a different type."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"here’s an extension to the nongeneric "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" type"},{"type":"text","text":" "},{"type":"text","text":"that adds "},{"type":"codeVoice","code":"SuffixableContainer"},{"type":"text","text":" conformance,"},{"type":"text","text":" "},{"type":"text","text":"using "},{"type":"codeVoice","code":"Stack<Int>"},{"type":"text","text":" as its suffix type instead of "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["extension IntStack: SuffixableContainer {","    func suffix(_ size: Int) -> Stack<Int> {","        var result = Stack<Int>()","        for index in (count-size)..<count {","            result.append(self[index])","        }","        return result","    }","    \/\/ Inferred that Suffix is Stack<Int>.","}"]},{"anchor":"Generic-Where-Clauses","level":2,"type":"heading","text":"Generic Where Clauses"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Type constraints, as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Type-Constraints"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"enable you to define requirements on the type parameters associated with"},{"type":"text","text":" "},{"type":"text","text":"a generic function, subscript, or type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It can also be useful to define requirements for associated types."},{"type":"text","text":" "},{"type":"text","text":"You do this by defining a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic where clause"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"A generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause enables you to require that"},{"type":"text","text":" "},{"type":"text","text":"an associated type must conform to a certain protocol,"},{"type":"text","text":" "},{"type":"text","text":"or that certain type parameters and associated types must be the same."},{"type":"text","text":" "},{"type":"text","text":"A generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause starts with the "},{"type":"codeVoice","code":"where"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"followed by constraints for associated types"},{"type":"text","text":" "},{"type":"text","text":"or equality relationships between types and associated types."},{"type":"text","text":" "},{"type":"text","text":"You write a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause right before the opening curly brace"},{"type":"text","text":" "},{"type":"text","text":"of a type or function’s body."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below defines a generic function called "},{"type":"codeVoice","code":"allItemsMatch"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which checks to see if two "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" instances contain"},{"type":"text","text":" "},{"type":"text","text":"the same items in the same order."},{"type":"text","text":" "},{"type":"text","text":"The function returns a Boolean value of "},{"type":"codeVoice","code":"true"},{"type":"text","text":" if all items match"},{"type":"text","text":" "},{"type":"text","text":"and a value of "},{"type":"codeVoice","code":"false"},{"type":"text","text":" if they don’t."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The two containers to be checked don’t have to be"},{"type":"text","text":" "},{"type":"text","text":"the same type of container (although they can be),"},{"type":"text","text":" "},{"type":"text","text":"but they do have to hold the same type of items."},{"type":"text","text":" "},{"type":"text","text":"This requirement is expressed through a combination of type constraints"},{"type":"text","text":" "},{"type":"text","text":"and a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause:"}]},{"type":"codeListing","syntax":"swift","code":["func allItemsMatch<C1: Container, C2: Container>","      (_ someContainer: C1, _ anotherContainer: C2) -> Bool","      where C1.Item == C2.Item, C1.Item: Equatable {","","   \/\/ Check that both containers contain the same number of items.","   if someContainer.count != anotherContainer.count {","      return false","   }","","   \/\/ Check each pair of items to see if they're equivalent.","   for i in 0..<someContainer.count {","      if someContainer[i] != anotherContainer[i] {","         return false","      }","   }","","   \/\/ All items match, so return true.","   return true","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This function takes two arguments called"},{"type":"text","text":" "},{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" and "},{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" argument is of type "},{"type":"codeVoice","code":"C1"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":" argument is of type "},{"type":"codeVoice","code":"C2"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Both "},{"type":"codeVoice","code":"C1"},{"type":"text","text":" and "},{"type":"codeVoice","code":"C2"},{"type":"text","text":" are type parameters"},{"type":"text","text":" "},{"type":"text","text":"for two container types to be determined when the function is called."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following requirements are placed on the function’s two type parameters:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"C1"},{"type":"text","text":" must conform to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol (written as "},{"type":"codeVoice","code":"C1: Container"},{"type":"text","text":")."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"C2"},{"type":"text","text":" must also conform to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol (written as "},{"type":"codeVoice","code":"C2: Container"},{"type":"text","text":")."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" for "},{"type":"codeVoice","code":"C1"},{"type":"text","text":" must be the same as the "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" for "},{"type":"codeVoice","code":"C2"},{"type":"text","text":" "},{"type":"text","text":"(written as "},{"type":"codeVoice","code":"C1.Item == C2.Item"},{"type":"text","text":")."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" for "},{"type":"codeVoice","code":"C1"},{"type":"text","text":" must conform to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"(written as "},{"type":"codeVoice","code":"C1.Item: Equatable"},{"type":"text","text":")."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The first and second requirements are defined in the function’s type parameter list,"},{"type":"text","text":" "},{"type":"text","text":"and the third and fourth requirements are defined in the function’s generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"These requirements mean:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" is a container of type "},{"type":"codeVoice","code":"C1"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":" is a container of type "},{"type":"codeVoice","code":"C2"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" and "},{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":" contain the same type of items."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The items in "},{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" can be checked with the not equal operator ("},{"type":"codeVoice","code":"!="},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"to see if they’re different from each other."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The third and fourth requirements combine to mean that"},{"type":"text","text":" "},{"type":"text","text":"the items in "},{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":" can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"also"}]},{"type":"text","text":" be checked with the "},{"type":"codeVoice","code":"!="},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"because they’re exactly the same type as the items in "},{"type":"codeVoice","code":"someContainer"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"These requirements enable the "},{"type":"codeVoice","code":"allItemsMatch(_:_:)"},{"type":"text","text":" function to compare the two containers,"},{"type":"text","text":" "},{"type":"text","text":"even if they’re of a different container type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"allItemsMatch(_:_:)"},{"type":"text","text":" function starts by checking that"},{"type":"text","text":" "},{"type":"text","text":"both containers contain the same number of items."},{"type":"text","text":" "},{"type":"text","text":"If they contain a different number of items, there’s no way that they can match,"},{"type":"text","text":" "},{"type":"text","text":"and the function returns "},{"type":"codeVoice","code":"false"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"After making this check, the function iterates over all of the items in "},{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" "},{"type":"text","text":"with a "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" loop and the half-open range operator ("},{"type":"codeVoice","code":"..<"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"For each item, the function checks whether the item from "},{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" isn’t equal to"},{"type":"text","text":" "},{"type":"text","text":"the corresponding item in "},{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the two items aren’t equal, then the two containers don’t match,"},{"type":"text","text":" "},{"type":"text","text":"and the function returns "},{"type":"codeVoice","code":"false"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the loop finishes without finding a mismatch,"},{"type":"text","text":" "},{"type":"text","text":"the two containers match, and the function returns "},{"type":"codeVoice","code":"true"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how the "},{"type":"codeVoice","code":"allItemsMatch(_:_:)"},{"type":"text","text":" function looks in action:"}]},{"type":"codeListing","syntax":"swift","code":["var stackOfStrings = Stack<String>()","stackOfStrings.push(\"uno\")","stackOfStrings.push(\"dos\")","stackOfStrings.push(\"tres\")","","var arrayOfStrings = [\"uno\", \"dos\", \"tres\"]","","if allItemsMatch(stackOfStrings, arrayOfStrings) {","   print(\"All items match.\")","} else {","   print(\"Not all items match.\")","}","\/\/ Prints \"All items match.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above creates a "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" instance to store "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"and pushes three strings onto the stack."},{"type":"text","text":" "},{"type":"text","text":"The example also creates an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance initialized with"},{"type":"text","text":" "},{"type":"text","text":"an array literal containing the same three strings as the stack."},{"type":"text","text":" "},{"type":"text","text":"Even though the stack and the array are of a different type,"},{"type":"text","text":" "},{"type":"text","text":"they both conform to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"and both contain the same type of values."},{"type":"text","text":" "},{"type":"text","text":"You can therefore call the "},{"type":"codeVoice","code":"allItemsMatch(_:_:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"with these two containers as its arguments."},{"type":"text","text":" "},{"type":"text","text":"In the example above, the "},{"type":"codeVoice","code":"allItemsMatch(_:_:)"},{"type":"text","text":" function correctly reports that"},{"type":"text","text":" "},{"type":"text","text":"all of the items in the two containers match."}]},{"anchor":"Extensions-with-a-Generic-Where-Clause","level":2,"type":"heading","text":"Extensions with a Generic Where Clause"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also use a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause as part of an extension."},{"type":"text","text":" "},{"type":"text","text":"The example below"},{"type":"text","text":" "},{"type":"text","text":"extends the generic "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" structure from the previous examples"},{"type":"text","text":" "},{"type":"text","text":"to add an "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method."}]},{"type":"codeListing","syntax":"swift","code":["extension Stack where Element: Equatable {","    func isTop(_ item: Element) -> Bool {","        guard let topItem = items.last else {","            return false","        }","        return topItem == item","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This new "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"first checks that the stack isn’t empty,"},{"type":"text","text":" "},{"type":"text","text":"and then compares the given item"},{"type":"text","text":" "},{"type":"text","text":"against the stack’s topmost item."},{"type":"text","text":" "},{"type":"text","text":"If you tried to do this without a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause,"},{"type":"text","text":" "},{"type":"text","text":"you would have a problem:"},{"type":"text","text":" "},{"type":"text","text":"The implementation of "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" uses the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"but the definition of "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" doesn’t require"},{"type":"text","text":" "},{"type":"text","text":"its items to be equatable,"},{"type":"text","text":" "},{"type":"text","text":"so using the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator results in a compile-time error."},{"type":"text","text":" "},{"type":"text","text":"Using a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause"},{"type":"text","text":" "},{"type":"text","text":"lets you add a new requirement to the extension,"},{"type":"text","text":" "},{"type":"text","text":"so that the extension adds the "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"only when the items in the stack are equatable."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how the "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method looks in action:"}]},{"type":"codeListing","syntax":"swift","code":["if stackOfStrings.isTop(\"tres\") {","   print(\"Top element is tres.\")","} else {","   print(\"Top element is something else.\")","}","\/\/ Prints \"Top element is tres.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you try to call the "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"on a stack whose elements aren’t equatable,"},{"type":"text","text":" "},{"type":"text","text":"you’ll get a compile-time error."}]},{"type":"codeListing","syntax":"swift","code":["struct NotEquatable { }","var notEquatableStack = Stack<NotEquatable>()","let notEquatableValue = NotEquatable()","notEquatableStack.push(notEquatableValue)","notEquatableStack.isTop(notEquatableValue)  \/\/ Error"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause with extensions to a protocol."},{"type":"text","text":" "},{"type":"text","text":"The example below extends the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol from the previous examples"},{"type":"text","text":" "},{"type":"text","text":"to add a "},{"type":"codeVoice","code":"startsWith(_:)"},{"type":"text","text":" method."}]},{"type":"codeListing","syntax":"swift","code":["extension Container where Item: Equatable {","   func startsWith(_ item: Item) -> Bool {","      return count >= 1 && self[0] == item","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"startsWith(_:)"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"first makes sure that the container has at least one item,"},{"type":"text","text":" "},{"type":"text","text":"and then it checks"},{"type":"text","text":" "},{"type":"text","text":"whether the first item in the container matches the given item."},{"type":"text","text":" "},{"type":"text","text":"This new "},{"type":"codeVoice","code":"startsWith(_:)"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"can be used with any type that conforms to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"including the stacks and arrays used above,"},{"type":"text","text":" "},{"type":"text","text":"as long as the container’s items are equatable."}]},{"type":"codeListing","syntax":"swift","code":["if [9, 9, 9].startsWith(42) {","   print(\"Starts with 42.\")","} else {","   print(\"Starts with something else.\")","}","\/\/ Prints \"Starts with something else.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause in the example above"},{"type":"text","text":" "},{"type":"text","text":"requires "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" to conform to a protocol,"},{"type":"text","text":" "},{"type":"text","text":"but you can also write a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses that require "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" "},{"type":"text","text":"to be a specific type."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["extension Container where Item == Double {","    func average() -> Double {","        var sum = 0.0","        for index in 0..<count {","            sum += self[index]","        }","        return sum \/ Double(count)","    }","}","print([1260.0, 1200.0, 98.6, 37.0].average())","\/\/ Prints \"648.9\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example adds an "},{"type":"codeVoice","code":"average()"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"to containers whose "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type is "},{"type":"codeVoice","code":"Double"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"It iterates over the items in the container to add them up,"},{"type":"text","text":" "},{"type":"text","text":"and divides by the container’s count to compute the average."},{"type":"text","text":" "},{"type":"text","text":"It explicitly converts the count from "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" to "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" "},{"type":"text","text":"to be able to do floating-point division."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can include multiple requirements in a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause"},{"type":"text","text":" "},{"type":"text","text":"that’s part of an extension,"},{"type":"text","text":" "},{"type":"text","text":"just like you can for a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause that you write elsewhere."},{"type":"text","text":" "},{"type":"text","text":"Separate each requirement in the list with a comma."}]},{"anchor":"Contextual-Where-Clauses","level":2,"type":"heading","text":"Contextual Where Clauses"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can write a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause"},{"type":"text","text":" "},{"type":"text","text":"as part of a declaration that doesn’t have its own generic type constraints,"},{"type":"text","text":" "},{"type":"text","text":"when you’re already working in the context of generic types."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"you can write a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause"},{"type":"text","text":" "},{"type":"text","text":"on a subscript of a generic type"},{"type":"text","text":" "},{"type":"text","text":"or on a method in an extension to a generic type."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" structure is generic,"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses in the example below"},{"type":"text","text":" "},{"type":"text","text":"specify what type constraints have to be satisfied"},{"type":"text","text":" "},{"type":"text","text":"to make these new  methods available on a container."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    func average() -> Double where Item == Int {","        var sum = 0.0","        for index in 0..<count {","            sum += Double(self[index])","        }","        return sum \/ Double(count)","    }","    func endsWith(_ item: Item) -> Bool where Item: Equatable {","        return count >= 1 && self[count-1] == item","    }","}","let numbers = [1260, 1200, 98, 37]","print(numbers.average())","\/\/ Prints \"648.75\"","print(numbers.endsWith(37))","\/\/ Prints \"true\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example"},{"type":"text","text":" "},{"type":"text","text":"adds an "},{"type":"codeVoice","code":"average()"},{"type":"text","text":" method to "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" when the items are integers,"},{"type":"text","text":" "},{"type":"text","text":"and it adds an "},{"type":"codeVoice","code":"endsWith(_:)"},{"type":"text","text":" method when the items are equatable."},{"type":"text","text":" "},{"type":"text","text":"Both functions include a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause"},{"type":"text","text":" "},{"type":"text","text":"that adds type constraints to the generic "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type parameter"},{"type":"text","text":" "},{"type":"text","text":"from the original declaration of "},{"type":"codeVoice","code":"Container"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you want to write this code without using contextual "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses,"},{"type":"text","text":" "},{"type":"text","text":"you write two extensions,"},{"type":"text","text":" "},{"type":"text","text":"one for each generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause."},{"type":"text","text":" "},{"type":"text","text":"The example above and the example below have the same behavior."}]},{"type":"codeListing","syntax":"swift","code":["extension Container where Item == Int {","    func average() -> Double {","        var sum = 0.0","        for index in 0..<count {","            sum += Double(self[index])","        }","        return sum \/ Double(count)","    }","}","extension Container where Item: Equatable {","    func endsWith(_ item: Item) -> Bool {","        return count >= 1 && self[count-1] == item","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the version of this example that uses contextual "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses,"},{"type":"text","text":" "},{"type":"text","text":"the implementation of "},{"type":"codeVoice","code":"average()"},{"type":"text","text":" and "},{"type":"codeVoice","code":"endsWith(_:)"},{"type":"text","text":" "},{"type":"text","text":"are both in the same extension"},{"type":"text","text":" "},{"type":"text","text":"because each method’s generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause"},{"type":"text","text":" "},{"type":"text","text":"states the requirements that need to be satisfied"},{"type":"text","text":" "},{"type":"text","text":"to make that method available."},{"type":"text","text":" "},{"type":"text","text":"Moving those requirements to the extensions’ generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses"},{"type":"text","text":" "},{"type":"text","text":"makes the methods available in the same situations,"},{"type":"text","text":" "},{"type":"text","text":"but requires one extension per requirement."}]},{"anchor":"Associated-Types-with-a-Generic-Where-Clause","level":2,"type":"heading","text":"Associated Types with a Generic Where Clause"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can include a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause on an associated type."},{"type":"text","text":" "},{"type":"text","text":"For example, suppose you want to make a version of "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" "},{"type":"text","text":"that includes an iterator,"},{"type":"text","text":" "},{"type":"text","text":"like what the "},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" protocol uses in the standard library."},{"type":"text","text":" "},{"type":"text","text":"Here’s how you write that:"}]},{"type":"codeListing","syntax":"swift","code":["protocol Container {","   associatedtype Item","   mutating func append(_ item: Item)","   var count: Int { get }","   subscript(i: Int) -> Item { get }","","   associatedtype Iterator: IteratorProtocol where Iterator.Element == Item","   func makeIterator() -> Iterator","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause on "},{"type":"codeVoice","code":"Iterator"},{"type":"text","text":" requires that"},{"type":"text","text":" "},{"type":"text","text":"the iterator must traverse over elements"},{"type":"text","text":" "},{"type":"text","text":"of the same item type as the container’s items,"},{"type":"text","text":" "},{"type":"text","text":"regardless of the iterator’s type."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"makeIterator()"},{"type":"text","text":" function provides access to a container’s iterator."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For a protocol that inherits from another protocol,"},{"type":"text","text":" "},{"type":"text","text":"you add a constraint to an inherited associated type"},{"type":"text","text":" "},{"type":"text","text":"by including the generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause in the protocol declaration."},{"type":"text","text":" "},{"type":"text","text":"For example, the following code"},{"type":"text","text":" "},{"type":"text","text":"declares a "},{"type":"codeVoice","code":"ComparableContainer"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"that requires "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" to conform to "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["protocol ComparableContainer: Container where Item: Comparable { }"]},{"anchor":"Generic-Subscripts","level":2,"type":"heading","text":"Generic Subscripts"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Subscripts can be generic,"},{"type":"text","text":" "},{"type":"text","text":"and they can include generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses."},{"type":"text","text":" "},{"type":"text","text":"You write the placeholder type name inside angle brackets after "},{"type":"codeVoice","code":"subscript"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and you write a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause right before the opening curly brace"},{"type":"text","text":" "},{"type":"text","text":"of the subscript’s body."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    subscript<Indices: Sequence>(indices: Indices) -> [Item]","            where Indices.Iterator.Element == Int {","        var result: [Item] = []","        for index in indices {","            result.append(self[index])","        }","        return result","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This extension to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"adds a subscript that takes a sequence of indices"},{"type":"text","text":" "},{"type":"text","text":"and returns an array containing the items at each given index."},{"type":"text","text":" "},{"type":"text","text":"This generic subscript is constrained as follows:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The generic parameter "},{"type":"codeVoice","code":"Indices"},{"type":"text","text":" in angle brackets"},{"type":"text","text":" "},{"type":"text","text":"has to be a type that conforms to the "},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"from the standard library."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The subscript takes a single parameter, "},{"type":"codeVoice","code":"indices"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which is an instance of that "},{"type":"codeVoice","code":"Indices"},{"type":"text","text":" type."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause requires"},{"type":"text","text":" "},{"type":"text","text":"that the iterator for the sequence"},{"type":"text","text":" "},{"type":"text","text":"must traverse over elements of type "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This ensures that the indices in the sequence"},{"type":"text","text":" "},{"type":"text","text":"are the same type as the indices used for a container."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Taken together, these constraints mean that"},{"type":"text","text":" "},{"type":"text","text":"the value passed for the "},{"type":"codeVoice","code":"indices"},{"type":"text","text":" parameter"},{"type":"text","text":" "},{"type":"text","text":"is a sequence of integers."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/generics"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","interfaceLanguage":"swift"},"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types"},{"type":"text","text":" "},{"type":"text","text":"that can work with any type, subject to requirements that you define."},{"type":"text","text":" "},{"type":"text","text":"You can write code that avoids duplication"},{"type":"text","text":" "},{"type":"text","text":"and expresses its intent in a clear, abstracted manner."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Generics","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Guide","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"],"generated":true}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures":{"role":"article","title":"Estruturas e Classes","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Estruturas"}]},{"type":"text","text":" e "},{"type":"emphasis","inlineContent":[{"type":"text","text":"classes"}]},{"type":"text","text":" são construções flexíveis de propósito geral que se tornam os blocos de construção do código do seu programa. Você define propriedades e métodos para adicionar funcionalidade às suas estruturas e classes usando a mesma sintaxe usada para definir constantes, variáveis e funções."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/classesandstructures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Subscripts":{"role":"article","title":"Subscripts","abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscripts"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which are shortcuts for accessing the member elements of a collection, list, or sequence."},{"type":"text","text":" "},{"type":"text","text":"You use subscripts to set and retrieve values by index without needing"},{"type":"text","text":" "},{"type":"text","text":"separate methods for setting and retrieval."},{"type":"text","text":" "},{"type":"text","text":"For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" "},{"type":"text","text":"and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/subscripts"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Properties":{"role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Properties"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration."},{"type":"text","text":" "},{"type":"text","text":"Stored properties store constant and variable values as part of an instance,"},{"type":"text","text":" "},{"type":"text","text":"whereas computed properties calculate (rather than store) a value."},{"type":"text","text":" "},{"type":"text","text":"Computed properties are provided by classes, structures, and enumerations."},{"type":"text","text":" "},{"type":"text","text":"Stored properties are provided only by classes and structures."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/properties"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators":{"role":"article","title":"Operadores Avançados","abstract":[{"type":"text","text":"Além dos operadores descritos no tópico "},{"type":"text","text":"doc:OperadoresBasicos"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"a linguagem Swift oferece o tópico Operadores Avançados que fazem manipulação de valores mais complexa."},{"type":"text","text":" "},{"type":"text","text":"Lá são incluídos operadores bit a bit e operadores com deslocamento que estamos familiarizados em C e Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/advancedoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting":{"role":"article","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"type":"text","text":" (ARC)"},{"type":"text","text":" "},{"type":"text","text":"to track and manage your app’s memory usage."},{"type":"text","text":" "},{"type":"text","text":"In most cases, this means that memory management “just works” in Swift,"},{"type":"text","text":" "},{"type":"text","text":"and you don’t need to think about memory management yourself."},{"type":"text","text":" "},{"type":"text","text":"ARC automatically frees up the memory used by class instances"},{"type":"text","text":" "},{"type":"text","text":"when those instances are no longer needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Methods":{"role":"article","title":"Methods","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Methods"}]},{"type":"text","text":" are functions that are associated with a particular type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can all define instance methods,"},{"type":"text","text":" "},{"type":"text","text":"which encapsulate specific tasks and functionality for working with an instance of a given type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can also define type methods,"},{"type":"text","text":" "},{"type":"text","text":"which are associated with the type itself."},{"type":"text","text":" "},{"type":"text","text":"Type methods are similar to class methods in Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow":{"role":"article","title":"Control Flow","abstract":[{"type":"text","text":"Swift provides a variety of control flow statements."},{"type":"text","text":" "},{"type":"text","text":"These include "},{"type":"codeVoice","code":"while"},{"type":"text","text":" loops to perform a task multiple times;"},{"type":"text","text":" "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", and "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statements"},{"type":"text","text":" "},{"type":"text","text":"to execute different branches of code based on certain conditions;"},{"type":"text","text":" "},{"type":"text","text":"and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" "},{"type":"text","text":"to transfer the flow of execution to another point in your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/controlflow"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OptionalChaining":{"role":"article","title":"Optional Chaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling"},{"type":"text","text":" "},{"type":"text","text":"properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the optional contains a value,"},{"type":"text","text":" "},{"type":"text","text":"the property, method, or subscript call succeeds;"},{"type":"text","text":" "},{"type":"text","text":"if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Multiple queries can be chained together,"},{"type":"text","text":" "},{"type":"text","text":"and the entire chain fails gracefully if any link in the chain is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/optionalchaining"},"stackPushPop":{"alt":null,"type":"image","identifier":"stackPushPop","variants":[{"url":"\/images\/stackPushPop@2x.png","traits":["2x","light"]},{"url":"\/images\/stackPushPop~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Deinitialization":{"role":"article","title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"deinitializer"}]},{"type":"text","text":" is called immediately before a class instance is deallocated."},{"type":"text","text":" "},{"type":"text","text":"You write deinitializers with the "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"similar to how initializers are written with the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"Deinitializers are only available on class types."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/deinitialization"},"stackPushedFourStrings":{"alt":null,"type":"image","identifier":"stackPushedFourStrings","variants":[{"url":"\/images\/stackPushedFourStrings@2x.png","traits":["2x","light"]},{"url":"\/images\/stackPushedFourStrings~dark@2x.png","traits":["2x","dark"]}]},"https://developer.apple.com/documentation/swift/hashable#2849490":{"title":"Conforming to the Hashable Protocol","titleInlineContent":[{"type":"text","text":"Conforming to the Hashable Protocol"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/hashable#2849490","url":"https:\/\/developer.apple.com\/documentation\/swift\/hashable#2849490"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"role":"article","title":"Error Handling","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Error handling"}]},{"type":"text","text":" is the process of responding to"},{"type":"text","text":" "},{"type":"text","text":"and recovering from error conditions in your program."},{"type":"text","text":" "},{"type":"text","text":"Swift provides first-class support for"},{"type":"text","text":" "},{"type":"text","text":"throwing, catching, propagating, and manipulating"},{"type":"text","text":" "},{"type":"text","text":"recoverable errors at runtime."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/errorhandling"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Extensions":{"role":"article","title":"Extensões","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensões"}]},{"type":"text","text":" adicionam novas funcionalidades a uma classe, estrutura, enumeração ou tipo de protocolo existente. Isso inclui a capacidade de estender tipos para os quais você não tem acesso ao código-fonte original (conhecido como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"modelagem retroativa"}]},{"type":"text","text":"). As extensões são semelhantes às categorias em Objective-C. (Ao contrário das categorias de Objective-C, as extensões Swift não têm nomes.)"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/extensions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics":{"role":"article","title":"O Básico","abstract":[{"type":"text","text":"Swift é uma linguagem de programação para desenvolvimento de aplicativos iOS, macOS, watchOS e tvOS. Se você tem experiência em desenvolvimento em C ou Objective-C, muitas partes do Swift serão familiares para você."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/thebasics"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/MemorySafety":{"role":"article","title":"Memory Safety","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift ensures that variables are initialized before they’re used,"},{"type":"text","text":" "},{"type":"text","text":"memory isn’t accessed after it’s been deallocated,"},{"type":"text","text":" "},{"type":"text","text":"and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/memorysafety"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/NestedTypes":{"role":"article","title":"Tipos Aninhados","abstract":[{"type":"text","text":"Enumerações são frequentemente criadas para dar suporte a uma funcionalidade especifica de uma classe ou estrutura."},{"type":"text","text":" "},{"type":"text","text":"Similarmente, pode ser conveniente definir classes e estruturas de utilidade"},{"type":"text","text":" "},{"type":"text","text":"puramente para o uso dentro de um contexto de um tipo mais complexo."},{"type":"text","text":" "},{"type":"text","text":"Para fazer isso, o Swift permite que você defina "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos aninhados"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"nos quais você aninha enumerações, classes e estruturas de suporte"},{"type":"text","text":" "},{"type":"text","text":"dentro da definição do tipo que elas suportam."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/nestedtypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency":{"role":"article","title":"Concorrência","abstract":[{"type":"text","text":"Swift tem suporte por padrão para escrita de código assíncrono e paralelo"},{"type":"text","text":" "},{"type":"text","text":"de forma estruturada."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código assíncrono"}]},{"type":"text","text":" pode ser suspenso e retomado posteriormente,"},{"type":"text","text":" "},{"type":"text","text":"embora apenas uma parte do programa seja executada por vez."},{"type":"text","text":" "},{"type":"text","text":"Suspender e retomar código em seu programa"},{"type":"text","text":" "},{"type":"text","text":"permite que ele continue a progredir"},{"type":"text","text":" "},{"type":"text","text":"em operações de curto prazo, como atualizar a interface do usuário,"},{"type":"text","text":" "},{"type":"text","text":"enquanto continua a trabalhar em operações de longa duração"},{"type":"text","text":" "},{"type":"text","text":"como buscar dados pela rede ou analisar arquivos."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código paralelo"}]},{"type":"text","text":" significa vários pedaços de código executando simultaneamente —"},{"type":"text","text":" "},{"type":"text","text":"por exemplo, um computador com um processador de quatro núcleos"},{"type":"text","text":" "},{"type":"text","text":"pode executar quatro pedaços de código ao mesmo tempo,"},{"type":"text","text":" "},{"type":"text","text":"com cada núcleo realizando uma das tarefas."},{"type":"text","text":" "},{"type":"text","text":"Um programa que usa código paralelo e assíncrono"},{"type":"text","text":" "},{"type":"text","text":"realiza várias operações ao mesmo tempo;"},{"type":"text","text":" "},{"type":"text","text":"suspende as operações que estão à espera de um sistema externo,"},{"type":"text","text":" "},{"type":"text","text":"e torna mais fácil escrever esse código de maneira segura para a memória ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"memory-safe"}]},{"type":"text","text":")."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/concurrency"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance":{"role":"article","title":"Inheritance","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"type":"text","text":" methods, properties, and other characteristics"},{"type":"text","text":" "},{"type":"text","text":"from another class."},{"type":"text","text":" "},{"type":"text","text":"When one class inherits from another,"},{"type":"text","text":" "},{"type":"text","text":"the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Inheritance is a fundamental behavior that differentiates classes"},{"type":"text","text":" "},{"type":"text","text":"from other types in Swift."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/inheritance"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"role":"article","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task."},{"type":"text","text":" "},{"type":"text","text":"You give a function a name that identifies what it does,"},{"type":"text","text":" "},{"type":"text","text":"and this name is used to “call” the function to perform its task when needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Type-Constraints":{"abstract":[],"title":"Type Constraints","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Type-Constraints","url":"\/documentation\/the-swift-programming-language\/generics#Type-Constraints"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Adding-Protocol-Conformance-with-an-Extension":{"abstract":[],"title":"Adding Protocol Conformance with an Extension","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adding-Protocol-Conformance-with-an-Extension","url":"\/documentation\/the-swift-programming-language\/protocols#Adding-Protocol-Conformance-with-an-Extension"},"stackPoppedOneString":{"alt":null,"type":"image","identifier":"stackPoppedOneString","variants":[{"url":"\/images\/stackPoppedOneString@2x.png","traits":["2x","light"]},{"url":"\/images\/stackPoppedOneString~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Generic-Types":{"abstract":[],"title":"Generic Types","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Types","url":"\/documentation\/the-swift-programming-language\/generics#Generic-Types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Enumerations":{"role":"article","title":"Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values"},{"type":"text","text":" "},{"type":"text","text":"and enables you to work with those values in a type-safe way within your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/enumerations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Declaring-Protocol-Adoption-with-an-Extension":{"abstract":[],"title":"Declaring Protocol Adoption with an Extension","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Declaring-Protocol-Adoption-with-an-Extension","url":"\/documentation\/the-swift-programming-language\/protocols#Declaring-Protocol-Adoption-with-an-Extension"},"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Associated-Types-with-a-Generic-Where-Clause":{"abstract":[],"title":"Associated Types with a Generic Where Clause","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Associated-Types-with-a-Generic-Where-Clause","url":"\/documentation\/the-swift-programming-language\/generics#Associated-Types-with-a-Generic-Where-Clause"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes":{"role":"article","title":"Tipos de Coleção","abstract":[{"type":"text","text":"Swift oferece três "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos de coleção"}]},{"type":"text","text":" primários, conhecidos como arrays, sets e dicionários, para armazenar coleções de valores. Arrays são coleções ordenadas de valores. Sets são coleções não ordenadas de valores únicos. Os dicionários são coleções não ordenadas de associações chave-valor."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/collectiontypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"role":"article","title":"Type Casting","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance,"},{"type":"text","text":" "},{"type":"text","text":"or to treat that instance as a different"},{"type":"text","text":" "},{"type":"text","text":"superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Extensions-with-a-Generic-Where-Clause":{"abstract":[],"title":"Extensions with a Generic Where Clause","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Extensions-with-a-Generic-Where-Clause","url":"\/documentation\/the-swift-programming-language\/generics#Extensions-with-a-Generic-Where-Clause"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes":{"role":"article","title":"Opaque Types","abstract":[{"type":"text","text":"A function or method with an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"type":"text","text":"Instead of providing a concrete type as the function’s return type,"},{"type":"text","text":" "},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"type":"text","text":"Hiding type information"},{"type":"text","text":" "},{"type":"text","text":"is useful at boundaries between"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"type":"text","text":" "},{"type":"text","text":"because the underlying type of the return value can remain private."},{"type":"text","text":" "},{"type":"text","text":"Unlike returning a value whose type is a protocol type,"},{"type":"text","text":" "},{"type":"text","text":"opaque types preserve type identity —"},{"type":"text","text":" "},{"type":"text","text":"the compiler has access to the type information,"},{"type":"text","text":" "},{"type":"text","text":"but clients of the module don’t."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/opaquetypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes#Dictionaries":{"abstract":[],"title":"Dictionaries","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Dictionaries","url":"\/documentation\/the-swift-programming-language\/collectiontypes#Dictionaries"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization":{"role":"article","title":"Initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"type":"text","text":" is the process of preparing an instance of"},{"type":"text","text":" "},{"type":"text","text":"a class, structure, or enumeration for use."},{"type":"text","text":" "},{"type":"text","text":"This process involves setting an initial value for each stored property on that instance"},{"type":"text","text":" "},{"type":"text","text":"and performing any other setup or initialization that’s required"},{"type":"text","text":" "},{"type":"text","text":"before the new instance is ready for use."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/StringsAndCharacters":{"role":"article","title":"Strings e Characters","abstract":[{"type":"text","text":"Uma "},{"type":"emphasis","inlineContent":[{"type":"text","text":"string"}]},{"type":"text","text":" é uma série de caracteres,"},{"type":"text","text":" "},{"type":"text","text":"tal como "},{"type":"codeVoice","code":"\"olá, mundo\""},{"type":"text","text":" ou "},{"type":"codeVoice","code":"\"albatroz\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Strings em Swift são representadas pelo tipo "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"O conteúdo de uma "},{"type":"codeVoice","code":"String"},{"type":"text","text":" pode ser acessado de várias maneiras,"},{"type":"text","text":" "},{"type":"text","text":"incluindo como uma coleção de valores "},{"type":"codeVoice","code":"Character"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/stringsandcharacters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"role":"article","title":"Operadores básicos","abstract":[{"type":"text","text":"Um operador é um símbolo ou frase que você pode usar para verificar, mudar ou combinar valores."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, o operador de adição ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") soma dois números,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"e o operador lógico E ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"AND"}]},{"type":"text","text":" - "},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combina dois valores booleanos,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/basicoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AccessControl":{"role":"article","title":"Access Control","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"type":"text","text":" restricts access to parts of your code"},{"type":"text","text":" "},{"type":"text","text":"from code in other source files and modules."},{"type":"text","text":" "},{"type":"text","text":"This feature enables you to hide the implementation details of your code,"},{"type":"text","text":" "},{"type":"text","text":"and to specify a preferred interface through which that code can be accessed and used."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/accesscontrol"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols":{"role":"article","title":"Protocols","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol"}]},{"type":"text","text":" defines a blueprint of"},{"type":"text","text":" "},{"type":"text","text":"methods, properties, and other requirements"},{"type":"text","text":" "},{"type":"text","text":"that suit a particular task or piece of functionality."},{"type":"text","text":" "},{"type":"text","text":"The protocol can then be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"adopted"}]},{"type":"text","text":" by a class, structure, or enumeration"},{"type":"text","text":" "},{"type":"text","text":"to provide an actual implementation of those requirements."},{"type":"text","text":" "},{"type":"text","text":"Any type that satisfies the requirements of a protocol is said to"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conform"}]},{"type":"text","text":" to that protocol."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/protocols"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures":{"role":"article","title":"Closures","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closures"}]},{"type":"text","text":" are self-contained blocks of functionality"},{"type":"text","text":" "},{"type":"text","text":"that can be passed around and used in your code."},{"type":"text","text":" "},{"type":"text","text":"Closures in Swift are similar to blocks in C and Objective-C"},{"type":"text","text":" "},{"type":"text","text":"and to lambdas in other programming languages."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/closures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#In-Out-Parameters":{"abstract":[],"title":"In-Out Parameters","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters","url":"\/documentation\/the-swift-programming-language\/functions#In-Out-Parameters"}}}