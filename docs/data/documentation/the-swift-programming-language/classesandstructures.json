{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Ao contrário de outras linguagens de programação, Swift não exige que você crie arquivos separados de interface e implementação para estruturas e classes personalizadas. Em Swift, você define uma estrutura ou classe em um único arquivo, e a interface externa para essa classe ou estrutura é automaticamente disponibilizada para outro código usar."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Uma instância de uma classe é tradicionalmente conhecida como um "},{"type":"emphasis","inlineContent":[{"type":"text","text":"objeto"}]},{"type":"text","text":". No entanto, as estruturas e classes do Swift são muito mais próximas em funcionalidade do que em outras linguagens, e muito deste capítulo descreve a funcionalidade que se aplica a instâncias de um "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipo"}]},{"type":"text","text":", seja uma classe ou uma estrutura. Por causa disso, o termo mais geral "},{"type":"emphasis","inlineContent":[{"type":"text","text":"instância"}]},{"type":"text","text":" é usado."}]}],"type":"aside","name":"Nota"},{"anchor":"Comparando-Estruturas-e-Classes","level":2,"type":"heading","text":"Comparando Estruturas e Classes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Estruturas e classes em Swift têm muitas coisas em comum. Ambas podem:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Definir propriedades para armazenar valores"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Definir métodos para fornecer funcionalidade"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Definir subscritos para fornecer acesso a seus valores usando a sintaxe de subscritos"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Definir inicializadores para configurar seu estado inicial"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Ser estendido para expandir sua funcionalidade além de uma implementação padrão"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Conformar com protocolos para fornecer funcionalidade padrão de um determinado tipo"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Para mais informações, veja "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions"},{"type":"text","text":", e "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As classes têm recursos adicionais que as estruturas não possuem:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A herança permite que uma classe herde as características de outra."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A conversão de tipo permite que você verifique e interprete o tipo de uma instância de classe em tempo de execução."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Desinicializadores permitem que uma instância de uma classe libere todos os recursos atribuídos a ela."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A contagem de referências permite mais de uma referência a uma instância de classe."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Para mais informações, veja "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization"},{"type":"text","text":", e "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Os recursos adicionais que as classes suportam vêm com o custo de maior complexidade. Como diretriz geral, prefira estruturas porque são mais fáceis de raciocinar sobre elas e use classes quando forem apropriadas ou necessárias. Na prática, isso significa que a maioria dos tipos de dados personalizados que você definir serão estruturas e enumerações."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Para uma comparação mais detalhada, consulte "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/choosing_between_structures_and_classes"},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Classes e atores compartilham muitas das mesmas características e comportamentos. Para obter informações sobre atores, consulte "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency"},{"type":"text","text":"."}]}],"type":"aside","name":"Nota"},{"anchor":"Sintaxe-de-Definição","level":3,"type":"heading","text":"Sintaxe de Definição"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Estruturas e classes têm uma sintaxe de definição semelhante. Você introduz estruturas com a palavra-chave "},{"type":"codeVoice","code":"struct"},{"type":"text","text":" e classes com a palavra-chave "},{"type":"codeVoice","code":"class"},{"type":"text","text":". Ambas colocam toda a sua definição dentro de um par de chaves:"}]},{"type":"codeListing","syntax":"swift","code":["struct SomeStructure {","   \/\/ definição da estrutura vai aqui","}","class SomeClass {","   \/\/ definição de classe vai aqui","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Sempre que você define uma nova estrutura ou classe, você define um novo tipo de Swift. Dê nomes aos tipos "},{"type":"codeVoice","code":"UpperCamelCase"},{"type":"text","text":" (como "},{"type":"codeVoice","code":"SomeStructure"},{"type":"text","text":" e "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" aqui) para corresponder à capitalização dos tipos Swift padrão (como "},{"type":"codeVoice","code":"String"},{"type":"text","text":", "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" e "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":"). Dê nomes às propriedades e métodos "},{"type":"codeVoice","code":"lowerCamelCase"},{"type":"text","text":" (como "},{"type":"codeVoice","code":"frameRate"},{"type":"text","text":" e "},{"type":"codeVoice","code":"incrementCount"},{"type":"text","text":") para diferenciá-los dos nomes de tipo."}]}],"type":"aside","name":"Nota"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Aqui está um exemplo de uma definição de estrutura e uma definição de classe:"}]},{"type":"codeListing","syntax":"swift","code":["struct Resolution {","   var width = 0","   var height = 0","}","class VideoMode {","   var resolution = Resolution()","   var interlaced = false","   var frameRate = 0.0","   var name: String?","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O exemplo acima define uma nova estrutura chamada "},{"type":"codeVoice","code":"Resolution"},{"type":"text","text":", para descrever uma resolução de exibição baseada em pixels. Esta estrutura tem duas propriedades armazenadas chamadas "},{"type":"codeVoice","code":"width"},{"type":"text","text":" e "},{"type":"codeVoice","code":"height"},{"type":"text","text":". Propriedades armazenadas são constantes ou variáveis agrupadas e armazenadas como parte da estrutura ou classe. Essas duas propriedades são inferidas como sendo do tipo "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" definindo-as como um valor inteiro inicial de "},{"type":"codeVoice","code":"0"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O exemplo acima também define uma nova classe chamada "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":", para descrever um modo de vídeo específico para exibição de vídeo. Essa classe tem quatro propriedades armazenadas variáveis. A primeira, "},{"type":"codeVoice","code":"resolution"},{"type":"text","text":", é inicializada com uma nova instância da estrutura "},{"type":"codeVoice","code":"Resolution"},{"type":"text","text":", que infere um tipo de propriedade de "},{"type":"codeVoice","code":"Resolution"},{"type":"text","text":". Para as outras três propriedades, as novas instâncias "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" serão inicializadas com uma configuração "},{"type":"codeVoice","code":"interlaced"},{"type":"text","text":" de "},{"type":"codeVoice","code":"false"},{"type":"text","text":" (que significa “vídeo não entrelaçado”), uma propriedade frameRate"},{"type":"codeVoice","code":"de"},{"type":"text","text":"0,0"},{"type":"codeVoice","code":"e um valor"},{"type":"text","text":"String"},{"type":"codeVoice","code":"opcional chamado "},{"type":"text","text":"name"},{"type":"codeVoice","code":". A propriedade "},{"type":"text","text":"name"},{"type":"codeVoice","code":"recebe automaticamente um valor padrão de"},{"type":"text","text":"nil"},{"type":"codeVoice","code":", ou “nenhum valor "},{"type":"text","text":"name`”, porque é de um tipo opcional."}]},{"anchor":"Instâncias-de-Estruturas-e-Classes","level":3,"type":"heading","text":"Instâncias de Estruturas e Classes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A definição da estrutura "},{"type":"codeVoice","code":"Resolution"},{"type":"text","text":" e a definição da classe "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" descrevem apenas como será a aparência de um instancia do tipo "},{"type":"codeVoice","code":"Resolution"},{"type":"text","text":" ou "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":". Elas próprias não descrevem uma resolução específica ou modo de vídeo. Para fazer isso, você precisa criar uma instância da estrutura ou classe."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A sintaxe para criar instâncias é muito semelhante para estruturas e classes:"}]},{"type":"codeListing","syntax":"swift","code":["let someResolution = Resolution()","let someVideoMode = VideoMode()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Estruturas e classes usam sintaxe inicializadora para novas instâncias. A forma mais simples de sintaxe do inicializador usa o nome do tipo da classe ou estrutura"},{"type":"text","text":" "},{"type":"text","text":"seguido por parênteses vazios, como "},{"type":"codeVoice","code":"Resolution()"},{"type":"text","text":" ou "},{"type":"codeVoice","code":"VideoMode()"},{"type":"text","text":". Isso cria uma nova instância da classe ou estrutura, com todas as propriedades inicializadas com seus valores padrão. A inicialização de classe e estrutura é descrita com mais detalhes em "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization"},{"type":"text","text":"."}]},{"anchor":"Acessando-Propriedades","level":3,"type":"heading","text":"Acessando Propriedades"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Você pode acessar as propriedades de uma instância usando a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"sintaxe de ponto"}]},{"type":"text","text":". Na sintaxe de ponto, você escreve o nome da propriedade imediatamente após o nome da instância, separado por um ponto ("},{"type":"codeVoice","code":"."},{"type":"text","text":"), sem espaços:"}]},{"type":"codeListing","syntax":"swift","code":["print(\"The width of someResolution is \\(someResolution.width)\")","\/\/ Imprime \"The width of someResolution is 0\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Neste exemplo, "},{"type":"codeVoice","code":"someResolution.width"},{"type":"text","text":" refere-se à propriedade "},{"type":"codeVoice","code":"width"},{"type":"text","text":" de "},{"type":"codeVoice","code":"someResolution"},{"type":"text","text":" e retorna seu valor inicial padrão de "},{"type":"codeVoice","code":"0"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Você pode acessar as subpropriedades, como a propriedade "},{"type":"codeVoice","code":"width"},{"type":"text","text":" na propriedade "},{"type":"codeVoice","code":"resolution"},{"type":"text","text":" de um "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["print(\"The width of someVideoMode is \\(someVideoMode.resolution.width)\")","\/\/ Imprime \"The width of someVideoMode is 0\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Você também pode usar a sintaxe de ponto para atribuir um novo valor a uma propriedade variável:"}]},{"type":"codeListing","syntax":"swift","code":["someVideoMode.resolution.width = 1280","print(\"The width of someVideoMode is now \\(someVideoMode.resolution.width)\")","\/\/ Imprime \"The width of someVideoMode is now 1280\""]},{"anchor":"Inicializadores-de-Membros-para-Tipos-de-Estrutura","level":3,"type":"heading","text":"Inicializadores de Membros para Tipos de Estrutura"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Todas as estruturas têm um "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inicializador de membros"}]},{"type":"text","text":" gerado automaticamente, que você pode usar para inicializar as propriedades de membro de novas instâncias de estrutura. Os valores iniciais para as propriedades da nova instância podem ser passados para o inicializador de membro por nome:"}]},{"type":"codeListing","syntax":"swift","code":["let vga = Resolution(width: 640, height: 480)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Ao contrário das estruturas, as instâncias de classe não recebem um inicializador de membros padrão. Os inicializadores são descritos com mais detalhes em "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization"},{"type":"text","text":"."}]},{"anchor":"Estruturas-e-Enumerações-São-Tipos-de-Valor","level":2,"type":"heading","text":"Estruturas e Enumerações São Tipos de Valor"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Um "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipo de valor"}]},{"type":"text","text":" é um tipo cujo valor é "},{"type":"emphasis","inlineContent":[{"type":"text","text":"copiado"}]},{"type":"text","text":" quando é atribuído a uma variável ou constante, ou quando é passado para uma função."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Na verdade, você usou tipos de valor extensivamente nos capítulos anteriores. Na verdade, todos os tipos básicos em Swift — inteiros, números de ponto flutuante, booleanos, strings, arrays e dicionários — são tipos de valor e são implementados como estruturas."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Todas as estruturas e enumerações são tipos de valor em Swift. Isso significa que qualquer instância de estrutura e enumeração que você criar — e quaisquer tipos de valor que eles tenham como propriedades — são sempre copiados quando são passados em seu código."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"as coleções definidas pela biblioteca padrão, como arrays, dicionários e strings, usam uma otimização para reduzir o custo de desempenho ao fazer cópias. Em vez de fazer uma cópia imediatamente, essas coleções compartilham a memória onde os elementos são armazenados entre a instância original e quaisquer cópias. Se uma das cópias da coleção for modificada, os elementos são copiados imediatamente antes da modificação. O comportamento que você vê em seu código é sempre como se uma cópia ocorresse imediatamente."}]}],"type":"aside","name":"Nota"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Considere este exemplo, que usa a estrutura "},{"type":"codeVoice","code":"Resolution"},{"type":"text","text":" do exemplo anterior:"}]},{"type":"codeListing","syntax":"swift","code":["let hd = Resolution(width: 1920, height: 1080)","var cinema = hd"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Este exemplo declara uma constante chamada "},{"type":"codeVoice","code":"hd"},{"type":"text","text":" e a define como uma instância "},{"type":"codeVoice","code":"Resolution"},{"type":"text","text":" inicializada com a largura e a altura do vídeo full HD (1920 pixels de largura por 1080 pixels de altura)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Em seguida, é declarada uma variável chamada "},{"type":"codeVoice","code":"cinema"},{"type":"text","text":" e definida com o valor atual de "},{"type":"codeVoice","code":"hd"},{"type":"text","text":". Como "},{"type":"codeVoice","code":"Resolution"},{"type":"text","text":" é uma estrutura, uma "},{"type":"emphasis","inlineContent":[{"type":"text","text":"cópia"}]},{"type":"text","text":" da instância existente é feita e esta nova cópia é atribuída a "},{"type":"codeVoice","code":"cinema"},{"type":"text","text":". Mesmo que "},{"type":"codeVoice","code":"hd"},{"type":"text","text":" e "},{"type":"codeVoice","code":"cinema"},{"type":"text","text":" agora tenham a mesma largura e altura, eles são duas instâncias completamente diferentes nos bastidores."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Em seguida, a propriedade "},{"type":"codeVoice","code":"width"},{"type":"text","text":" de "},{"type":"codeVoice","code":"cinema"},{"type":"text","text":" é alterada para ser a largura do padrão 2K ligeiramente mais amplo usado para projeção de cinema digital (2048 pixels de largura e 1080 pixels de altura):"}]},{"type":"codeListing","syntax":"swift","code":["cinema.width = 2048"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Verificar a propriedade "},{"type":"codeVoice","code":"width"},{"type":"text","text":" de "},{"type":"codeVoice","code":"cinema"},{"type":"text","text":" mostra que ela realmente mudou para "},{"type":"codeVoice","code":"2048"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["print(\"cinema is now \\(cinema.width) pixels wide\")","\/\/ Imprime \"cinema is now 2048 pixels wide\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"No entanto, a propriedade "},{"type":"codeVoice","code":"width"},{"type":"text","text":" da instância "},{"type":"codeVoice","code":"hd"},{"type":"text","text":" original ainda tem o valor antigo de "},{"type":"codeVoice","code":"1920"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["print(\"hd is still \\(hd.width) pixels wide\")","\/\/ Imprime \"hd is still 1920 pixels wide\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Quando "},{"type":"codeVoice","code":"cinema"},{"type":"text","text":" recebeu o valor atual de "},{"type":"codeVoice","code":"hd"},{"type":"text","text":", os "},{"type":"emphasis","inlineContent":[{"type":"text","text":"valores"}]},{"type":"text","text":" armazenados em "},{"type":"codeVoice","code":"hd"},{"type":"text","text":" foram copiados para a nova instância "},{"type":"codeVoice","code":"cinema"},{"type":"text","text":". O resultado final foram duas instâncias completamente separadas que continham os mesmos valores numéricos. No entanto, por serem instâncias separadas, definir a largura de "},{"type":"codeVoice","code":"cinema"},{"type":"text","text":" para "},{"type":"codeVoice","code":"2048"},{"type":"text","text":" não afeta a largura armazenada em "},{"type":"codeVoice","code":"hd"},{"type":"text","text":", conforme mostrado na figura abaixo:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"sharedStateStruct"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O mesmo comportamento se aplica a enumerações:"}]},{"type":"codeListing","syntax":"swift","code":["enum CompassPoint {","   case north, south, east, west","   mutating func turnNorth() {","      self = .north","   }","}","var currentDirection = CompassPoint.west","let rememberedDirection = currentDirection","currentDirection.turnNorth()","","print(\"The current direction is \\(currentDirection)\")","print(\"The remembered direction is \\(rememberedDirection)\")","\/\/ Imprime \"The current direction is north\"","\/\/ Imprime \"The remembered direction is west\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Quando "},{"type":"codeVoice","code":"rememberedDirection"},{"type":"text","text":" recebe o valor de "},{"type":"codeVoice","code":"currentDirection"},{"type":"text","text":", ele é definido como uma cópia desse valor. Alterar o valor de "},{"type":"codeVoice","code":"currentDirection"},{"type":"text","text":" posteriormente não afeta a cópia do valor original que foi armazenado em "},{"type":"codeVoice","code":"rememberedDirection"},{"type":"text","text":"."}]},{"anchor":"Classes-são-Tipos-de-Referência","level":2,"type":"heading","text":"Classes são Tipos de Referência"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Ao contrário dos tipos de valor, os "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos de referência"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"não"}]},{"type":"text","text":" são copiados quando são atribuídos a uma variável ou constante, ou quando são passados para uma função. Em vez de uma cópia, é usada uma referência à mesma instância existente."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Aqui está um exemplo, usando a classe "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" definida acima:"}]},{"type":"codeListing","syntax":"swift","code":["let tenEighty = VideoMode()","tenEighty.resolution = hd","tenEighty.interlaced = true","tenEighty.name = \"1080i\"","tenEighty.frameRate = 25.0"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Esse exemplo declara uma nova constante chamada "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" e a define para se referir a uma nova instância da classe "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":". A propriedade "},{"type":"codeVoice","code":"resolution"},{"type":"text","text":" recebe uma cópia da instância "},{"type":"codeVoice","code":"hd"},{"type":"text","text":" de "},{"type":"codeVoice","code":"1920"},{"type":"text","text":" por "},{"type":"codeVoice","code":"1080"},{"type":"text","text":" definida anteriormente. A propriedade "},{"type":"codeVoice","code":"interlaced"},{"type":"text","text":" é configurada para "},{"type":"codeVoice","code":"true"},{"type":"text","text":", "},{"type":"codeVoice","code":"name"},{"type":"text","text":" é definido como "},{"type":"codeVoice","code":"\"1080i\""},{"type":"text","text":" e "},{"type":"codeVoice","code":"frameRate"},{"type":"text","text":" é definida como "},{"type":"codeVoice","code":"25,0"},{"type":"text","text":" quadros por segundo."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Em seguida, "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" é atribuído a uma nova constante, chamada "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":", e a taxa de quadros de "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":" é modificada:"}]},{"type":"codeListing","syntax":"swift","code":["let alsoTenEighty = tenEighty","alsoTenEighty.frameRate = 30.0"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Como as classes são tipos de referência, "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" e "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":" na verdade se referem à "},{"type":"emphasis","inlineContent":[{"type":"text","text":"mesma"}]},{"type":"text","text":" instância "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":". Efetivamente, eles são apenas dois nomes diferentes para a mesma instância, conforme mostrado na figura abaixo:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"sharedStateClass"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Verificar a propriedade "},{"type":"codeVoice","code":"frameRate"},{"type":"text","text":" de "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" mostra que ela retorna corretamente a nova taxa de quadros de "},{"type":"codeVoice","code":"30.0"},{"type":"text","text":" da instância "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" subjacente:"}]},{"type":"codeListing","syntax":"swift","code":["print(\"The frameRate property of tenEighty is now \\(tenEighty.frameRate)\")","\/\/ Imprime \"The frameRate property of tenEighty is now 30.0\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Esse exemplo também mostra como os tipos de referência podem ser mais difíceis de raciocinar. Se "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" e "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":" estiverem muito distantes no código do seu programa, pode ser difícil encontrar todas as maneiras pelas quais o modo de vídeo é alterado. Onde quer que você use "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":", você também deve pensar no código que usa "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":", e vice versa. Em contraste, os tipos de valor são mais fáceis de raciocinar porque todo o código que interage com o mesmo valor está próximo em seus arquivos de origem."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note que "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" e "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":" são declarados como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"constantes"}]},{"type":"text","text":", em vez de variáveis. No entanto, você ainda pode alterar "},{"type":"codeVoice","code":"tenEighty.frameRate"},{"type":"text","text":" e "},{"type":"codeVoice","code":"alsoTenEighty.frameRate"},{"type":"text","text":" porque os valores das constantes "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" e "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":" não mudam. "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" e "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":" não “armazenam” a instância "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" — em vez disso, ambos "},{"type":"emphasis","inlineContent":[{"type":"text","text":"referem-se"}]},{"type":"text","text":" a uma instância "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" nos bastidores. É a propriedade "},{"type":"codeVoice","code":"frameRate"},{"type":"text","text":" do "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" subjacente que foi alterada, não os valores das referências constantes a esse "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":"."}]},{"anchor":"Operadores-de-Identidade","level":3,"type":"heading","text":"Operadores de Identidade"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Como as classes são tipos de referência, é possível que várias constantes e variáveis se refiram à mesma instância única de uma classe. (O mesmo não é verdade para estruturas e enumerações, porque elas sempre são copiadas quando são atribuídas a uma constante ou variável ou passadas para uma função.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Às vezes pode ser útil descobrir se duas constantes ou variáveis se referem exatamente à mesma instância de uma classe. Para permitir isso, o Swift fornece dois operadores de identidade:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Idêntico a ("},{"type":"codeVoice","code":"==="},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Não idêntico a ("},{"type":"codeVoice","code":"!=="},{"type":"text","text":")"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use esses operadores para verificar se duas constantes ou variáveis se referem à mesma instância única:"}]},{"type":"codeListing","syntax":"swift","code":["if tenEighty === alsoTenEighty {","   print(\"tenEighty and alsoTenEighty refer to the same VideoMode instance.\")","}","\/\/ Imprime \"tenEighty and alsoTenEighty refer to the same VideoMode instance.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note que "},{"type":"emphasis","inlineContent":[{"type":"text","text":"idêntico a"}]},{"type":"text","text":" (representado por três sinais de igual, ou "},{"type":"codeVoice","code":"==="},{"type":"text","text":") não significa a mesma coisa que "},{"type":"emphasis","inlineContent":[{"type":"text","text":"igual a"}]},{"type":"text","text":" (representado por dois sinais de igual, ou "},{"type":"codeVoice","code":"=="},{"type":"text","text":"). "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Idêntico a"}]},{"type":"text","text":" significa que duas constantes ou variáveis do tipo de classe referem-se exatamente à mesma instância de classe. "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Igual a"}]},{"type":"text","text":" significa que duas instâncias são consideradas iguais ou equivalentes em valor, para algum significado apropriado de "},{"type":"emphasis","inlineContent":[{"type":"text","text":"igual"}]},{"type":"text","text":", conforme definido pelo designer do tipo."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Ao definir suas próprias estruturas e classes personalizadas, é sua responsabilidade decidir o que se qualifica como duas instâncias iguais. O processo de definir suas próprias implementações dos operadores "},{"type":"codeVoice","code":"=="},{"type":"text","text":" e "},{"type":"codeVoice","code":"!="},{"type":"text","text":" é descrito em "},{"type":"text","text":"doc:AdvancedOperators#Equivalence-Operators"},{"type":"text","text":"."}]},{"anchor":"Ponteiros","level":3,"type":"heading","text":"Ponteiros"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Se você tiver experiência com C, C++ ou Objective-C, talvez saiba que essas linguagens usam "},{"type":"emphasis","inlineContent":[{"type":"text","text":"ponteiros"}]},{"type":"text","text":" para se referir a endereços na memória. Uma constante ou variável Swift que se refere a uma instância de algum tipo de referência é semelhante a um ponteiro em C, mas não é um ponteiro direto para um endereço na memória e não exige que você escreva um asterisco ("},{"type":"codeVoice","code":"*"},{"type":"text","text":") para indicar que você está criando uma referência. Em vez disso, essas referências são definidas como qualquer outra constante ou variável no Swift. A biblioteca padrão fornece tipos de ponteiro e buffer que você pode usar se precisar interagir diretamente com os ponteiros — consulte "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/swift_standard_library\/manual_memory_management"},{"type":"text","text":"."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/classesandstructures"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","interfaceLanguage":"swift"},"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Estruturas"}]},{"type":"text","text":" e "},{"type":"emphasis","inlineContent":[{"type":"text","text":"classes"}]},{"type":"text","text":" são construções flexíveis de propósito geral que se tornam os blocos de construção do código do seu programa. Você define propriedades e métodos para adicionar funcionalidade às suas estruturas e classes usando a mesma sintaxe usada para definir constantes, variáveis e funções."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Estruturas e Classes","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Guide","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"],"generated":true}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes":{"role":"article","title":"Opaque Types","abstract":[{"type":"text","text":"A function or method with an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"type":"text","text":"Instead of providing a concrete type as the function’s return type,"},{"type":"text","text":" "},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"type":"text","text":"Hiding type information"},{"type":"text","text":" "},{"type":"text","text":"is useful at boundaries between"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"type":"text","text":" "},{"type":"text","text":"because the underlying type of the return value can remain private."},{"type":"text","text":" "},{"type":"text","text":"Unlike returning a value whose type is a protocol type,"},{"type":"text","text":" "},{"type":"text","text":"opaque types preserve type identity —"},{"type":"text","text":" "},{"type":"text","text":"the compiler has access to the type information,"},{"type":"text","text":" "},{"type":"text","text":"but clients of the module don’t."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/opaquetypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Enumerations":{"role":"article","title":"Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values"},{"type":"text","text":" "},{"type":"text","text":"and enables you to work with those values in a type-safe way within your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/enumerations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/NestedTypes":{"role":"article","title":"Tipos Aninhados","abstract":[{"type":"text","text":"Enumerações são frequentemente criadas para dar suporte a uma funcionalidade especifica de uma classe ou estrutura."},{"type":"text","text":" "},{"type":"text","text":"Similarmente, pode ser conveniente definir classes e estruturas de utilidade"},{"type":"text","text":" "},{"type":"text","text":"puramente para o uso dentro de um contexto de um tipo mais complexo."},{"type":"text","text":" "},{"type":"text","text":"Para fazer isso, o Swift permite que você defina "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos aninhados"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"nos quais você aninha enumerações, classes e estruturas de suporte"},{"type":"text","text":" "},{"type":"text","text":"dentro da definição do tipo que elas suportam."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/nestedtypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures":{"role":"article","title":"Closures","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closures"}]},{"type":"text","text":" are self-contained blocks of functionality"},{"type":"text","text":" "},{"type":"text","text":"that can be passed around and used in your code."},{"type":"text","text":" "},{"type":"text","text":"Closures in Swift are similar to blocks in C and Objective-C"},{"type":"text","text":" "},{"type":"text","text":"and to lambdas in other programming languages."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/closures"},"sharedStateClass":{"alt":null,"type":"image","identifier":"sharedStateClass","variants":[{"url":"\/images\/sharedStateClass@2x.png","traits":["2x","light"]},{"url":"\/images\/sharedStateClass~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization":{"role":"article","title":"Initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"type":"text","text":" is the process of preparing an instance of"},{"type":"text","text":" "},{"type":"text","text":"a class, structure, or enumeration for use."},{"type":"text","text":" "},{"type":"text","text":"This process involves setting an initial value for each stored property on that instance"},{"type":"text","text":" "},{"type":"text","text":"and performing any other setup or initialization that’s required"},{"type":"text","text":" "},{"type":"text","text":"before the new instance is ready for use."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization"},"https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management":{"title":"Manual Memory Management","titleInlineContent":[{"type":"text","text":"Manual Memory Management"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/swift_standard_library\/manual_memory_management","url":"https:\/\/developer.apple.com\/documentation\/swift\/swift_standard_library\/manual_memory_management"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes":{"role":"article","title":"Tipos de Coleção","abstract":[{"type":"text","text":"Swift oferece três "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos de coleção"}]},{"type":"text","text":" primários, conhecidos como arrays, sets e dicionários, para armazenar coleções de valores. Arrays são coleções ordenadas de valores. Sets são coleções não ordenadas de valores únicos. Os dicionários são coleções não ordenadas de associações chave-valor."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/collectiontypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow":{"role":"article","title":"Control Flow","abstract":[{"type":"text","text":"Swift provides a variety of control flow statements."},{"type":"text","text":" "},{"type":"text","text":"These include "},{"type":"codeVoice","code":"while"},{"type":"text","text":" loops to perform a task multiple times;"},{"type":"text","text":" "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", and "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statements"},{"type":"text","text":" "},{"type":"text","text":"to execute different branches of code based on certain conditions;"},{"type":"text","text":" "},{"type":"text","text":"and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" "},{"type":"text","text":"to transfer the flow of execution to another point in your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/controlflow"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators":{"role":"article","title":"Operadores Avançados","abstract":[{"type":"text","text":"Além dos operadores descritos no tópico "},{"type":"text","text":"doc:OperadoresBasicos"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"a linguagem Swift oferece o tópico Operadores Avançados que fazem manipulação de valores mais complexa."},{"type":"text","text":" "},{"type":"text","text":"Lá são incluídos operadores bit a bit e operadores com deslocamento que estamos familiarizados em C e Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/advancedoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics":{"role":"article","title":"O Básico","abstract":[{"type":"text","text":"Swift é uma linguagem de programação para desenvolvimento de aplicativos iOS, macOS, watchOS e tvOS. Se você tem experiência em desenvolvimento em C ou Objective-C, muitas partes do Swift serão familiares para você."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/thebasics"},"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"role":"article","title":"Error Handling","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Error handling"}]},{"type":"text","text":" is the process of responding to"},{"type":"text","text":" "},{"type":"text","text":"and recovering from error conditions in your program."},{"type":"text","text":" "},{"type":"text","text":"Swift provides first-class support for"},{"type":"text","text":" "},{"type":"text","text":"throwing, catching, propagating, and manipulating"},{"type":"text","text":" "},{"type":"text","text":"recoverable errors at runtime."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/errorhandling"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Deinitialization":{"role":"article","title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"deinitializer"}]},{"type":"text","text":" is called immediately before a class instance is deallocated."},{"type":"text","text":" "},{"type":"text","text":"You write deinitializers with the "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"similar to how initializers are written with the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"Deinitializers are only available on class types."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/deinitialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OptionalChaining":{"role":"article","title":"Optional Chaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling"},{"type":"text","text":" "},{"type":"text","text":"properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the optional contains a value,"},{"type":"text","text":" "},{"type":"text","text":"the property, method, or subscript call succeeds;"},{"type":"text","text":" "},{"type":"text","text":"if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Multiple queries can be chained together,"},{"type":"text","text":" "},{"type":"text","text":"and the entire chain fails gracefully if any link in the chain is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/optionalchaining"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Extensions":{"role":"article","title":"Extensões","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensões"}]},{"type":"text","text":" adicionam novas funcionalidades a uma classe, estrutura, enumeração ou tipo de protocolo existente. Isso inclui a capacidade de estender tipos para os quais você não tem acesso ao código-fonte original (conhecido como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"modelagem retroativa"}]},{"type":"text","text":"). As extensões são semelhantes às categorias em Objective-C. (Ao contrário das categorias de Objective-C, as extensões Swift não têm nomes.)"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/extensions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Properties":{"role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Properties"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration."},{"type":"text","text":" "},{"type":"text","text":"Stored properties store constant and variable values as part of an instance,"},{"type":"text","text":" "},{"type":"text","text":"whereas computed properties calculate (rather than store) a value."},{"type":"text","text":" "},{"type":"text","text":"Computed properties are provided by classes, structures, and enumerations."},{"type":"text","text":" "},{"type":"text","text":"Stored properties are provided only by classes and structures."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/properties"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Subscripts":{"role":"article","title":"Subscripts","abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscripts"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which are shortcuts for accessing the member elements of a collection, list, or sequence."},{"type":"text","text":" "},{"type":"text","text":"You use subscripts to set and retrieve values by index without needing"},{"type":"text","text":" "},{"type":"text","text":"separate methods for setting and retrieval."},{"type":"text","text":" "},{"type":"text","text":"For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" "},{"type":"text","text":"and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/subscripts"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols":{"role":"article","title":"Protocols","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol"}]},{"type":"text","text":" defines a blueprint of"},{"type":"text","text":" "},{"type":"text","text":"methods, properties, and other requirements"},{"type":"text","text":" "},{"type":"text","text":"that suit a particular task or piece of functionality."},{"type":"text","text":" "},{"type":"text","text":"The protocol can then be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"adopted"}]},{"type":"text","text":" by a class, structure, or enumeration"},{"type":"text","text":" "},{"type":"text","text":"to provide an actual implementation of those requirements."},{"type":"text","text":" "},{"type":"text","text":"Any type that satisfies the requirements of a protocol is said to"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conform"}]},{"type":"text","text":" to that protocol."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/protocols"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AccessControl":{"role":"article","title":"Access Control","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"type":"text","text":" restricts access to parts of your code"},{"type":"text","text":" "},{"type":"text","text":"from code in other source files and modules."},{"type":"text","text":" "},{"type":"text","text":"This feature enables you to hide the implementation details of your code,"},{"type":"text","text":" "},{"type":"text","text":"and to specify a preferred interface through which that code can be accessed and used."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/accesscontrol"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Methods":{"role":"article","title":"Methods","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Methods"}]},{"type":"text","text":" are functions that are associated with a particular type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can all define instance methods,"},{"type":"text","text":" "},{"type":"text","text":"which encapsulate specific tasks and functionality for working with an instance of a given type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can also define type methods,"},{"type":"text","text":" "},{"type":"text","text":"which are associated with the type itself."},{"type":"text","text":" "},{"type":"text","text":"Type methods are similar to class methods in Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/methods"},"https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes":{"title":"Choosing Between Structures and Classes","titleInlineContent":[{"type":"text","text":"Choosing Between Structures and Classes"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/choosing_between_structures_and_classes","url":"https:\/\/developer.apple.com\/documentation\/swift\/choosing_between_structures_and_classes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"role":"article","title":"Generics","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types"},{"type":"text","text":" "},{"type":"text","text":"that can work with any type, subject to requirements that you define."},{"type":"text","text":" "},{"type":"text","text":"You can write code that avoids duplication"},{"type":"text","text":" "},{"type":"text","text":"and expresses its intent in a clear, abstracted manner."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics"},"sharedStateStruct":{"alt":null,"type":"image","identifier":"sharedStateStruct","variants":[{"url":"\/images\/sharedStateStruct@2x.png","traits":["2x","light"]},{"url":"\/images\/sharedStateStruct~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"role":"article","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task."},{"type":"text","text":" "},{"type":"text","text":"You give a function a name that identifies what it does,"},{"type":"text","text":" "},{"type":"text","text":"and this name is used to “call” the function to perform its task when needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"role":"article","title":"Operadores básicos","abstract":[{"type":"text","text":"Um operador é um símbolo ou frase que você pode usar para verificar, mudar ou combinar valores."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, o operador de adição ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") soma dois números,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"e o operador lógico E ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"AND"}]},{"type":"text","text":" - "},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combina dois valores booleanos,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/basicoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/StringsAndCharacters":{"role":"article","title":"Strings e Characters","abstract":[{"type":"text","text":"Uma "},{"type":"emphasis","inlineContent":[{"type":"text","text":"string"}]},{"type":"text","text":" é uma série de caracteres,"},{"type":"text","text":" "},{"type":"text","text":"tal como "},{"type":"codeVoice","code":"\"olá, mundo\""},{"type":"text","text":" ou "},{"type":"codeVoice","code":"\"albatroz\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Strings em Swift são representadas pelo tipo "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"O conteúdo de uma "},{"type":"codeVoice","code":"String"},{"type":"text","text":" pode ser acessado de várias maneiras,"},{"type":"text","text":" "},{"type":"text","text":"incluindo como uma coleção de valores "},{"type":"codeVoice","code":"Character"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/stringsandcharacters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"role":"article","title":"Type Casting","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance,"},{"type":"text","text":" "},{"type":"text","text":"or to treat that instance as a different"},{"type":"text","text":" "},{"type":"text","text":"superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting":{"role":"article","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"type":"text","text":" (ARC)"},{"type":"text","text":" "},{"type":"text","text":"to track and manage your app’s memory usage."},{"type":"text","text":" "},{"type":"text","text":"In most cases, this means that memory management “just works” in Swift,"},{"type":"text","text":" "},{"type":"text","text":"and you don’t need to think about memory management yourself."},{"type":"text","text":" "},{"type":"text","text":"ARC automatically frees up the memory used by class instances"},{"type":"text","text":" "},{"type":"text","text":"when those instances are no longer needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance":{"role":"article","title":"Inheritance","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"type":"text","text":" methods, properties, and other characteristics"},{"type":"text","text":" "},{"type":"text","text":"from another class."},{"type":"text","text":" "},{"type":"text","text":"When one class inherits from another,"},{"type":"text","text":" "},{"type":"text","text":"the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Inheritance is a fundamental behavior that differentiates classes"},{"type":"text","text":" "},{"type":"text","text":"from other types in Swift."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/inheritance"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency":{"role":"article","title":"Concorrência","abstract":[{"type":"text","text":"Swift tem suporte por padrão para escrita de código assíncrono e paralelo"},{"type":"text","text":" "},{"type":"text","text":"de forma estruturada."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código assíncrono"}]},{"type":"text","text":" pode ser suspenso e retomado posteriormente,"},{"type":"text","text":" "},{"type":"text","text":"embora apenas uma parte do programa seja executada por vez."},{"type":"text","text":" "},{"type":"text","text":"Suspender e retomar código em seu programa"},{"type":"text","text":" "},{"type":"text","text":"permite que ele continue a progredir"},{"type":"text","text":" "},{"type":"text","text":"em operações de curto prazo, como atualizar a interface do usuário,"},{"type":"text","text":" "},{"type":"text","text":"enquanto continua a trabalhar em operações de longa duração"},{"type":"text","text":" "},{"type":"text","text":"como buscar dados pela rede ou analisar arquivos."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código paralelo"}]},{"type":"text","text":" significa vários pedaços de código executando simultaneamente —"},{"type":"text","text":" "},{"type":"text","text":"por exemplo, um computador com um processador de quatro núcleos"},{"type":"text","text":" "},{"type":"text","text":"pode executar quatro pedaços de código ao mesmo tempo,"},{"type":"text","text":" "},{"type":"text","text":"com cada núcleo realizando uma das tarefas."},{"type":"text","text":" "},{"type":"text","text":"Um programa que usa código paralelo e assíncrono"},{"type":"text","text":" "},{"type":"text","text":"realiza várias operações ao mesmo tempo;"},{"type":"text","text":" "},{"type":"text","text":"suspende as operações que estão à espera de um sistema externo,"},{"type":"text","text":" "},{"type":"text","text":"e torna mais fácil escrever esse código de maneira segura para a memória ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"memory-safe"}]},{"type":"text","text":")."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/concurrency"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/MemorySafety":{"role":"article","title":"Memory Safety","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift ensures that variables are initialized before they’re used,"},{"type":"text","text":" "},{"type":"text","text":"memory isn’t accessed after it’s been deallocated,"},{"type":"text","text":" "},{"type":"text","text":"and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/memorysafety"}}}