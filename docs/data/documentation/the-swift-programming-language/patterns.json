{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, there are two basic kinds of patterns:"},{"type":"text","text":" "},{"type":"text","text":"those that successfully match any kind of value,"},{"type":"text","text":" "},{"type":"text","text":"and those that may fail to match a specified value at runtime."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The first kind of pattern is used for destructuring values"},{"type":"text","text":" "},{"type":"text","text":"in simple variable, constant, and optional bindings."},{"type":"text","text":" "},{"type":"text","text":"These include wildcard patterns, identifier patterns,"},{"type":"text","text":" "},{"type":"text","text":"and any value binding or tuple patterns containing"},{"type":"text","text":" "},{"type":"text","text":"them. You can specify a type annotation for these patterns"},{"type":"text","text":" "},{"type":"text","text":"to constrain them to match only values of a certain type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The second kind of pattern is used for full pattern matching,"},{"type":"text","text":" "},{"type":"text","text":"where the values you’re trying to match against may not be there at runtime."},{"type":"text","text":" "},{"type":"text","text":"These include enumeration case patterns, optional patterns, expression patterns,"},{"type":"text","text":" "},{"type":"text","text":"and type-casting patterns. You use these patterns in a case label of a "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" "},{"type":"text","text":"statement, a "},{"type":"codeVoice","code":"catch"},{"type":"text","text":" clause of a "},{"type":"codeVoice","code":"do"},{"type":"text","text":" statement,"},{"type":"text","text":" "},{"type":"text","text":"or in the case condition of an "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"while"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", or "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" statement."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a pattern","","pattern --> wildcard-pattern type-annotation-OPT","pattern --> identifier-pattern type-annotation-OPT","pattern --> value-binding-pattern","pattern --> tuple-pattern type-annotation-OPT","pattern --> enum-case-pattern","pattern --> optional-pattern","pattern --> type-casting-pattern","pattern --> expression-pattern"]},{"anchor":"Wildcard-Pattern","level":2,"type":"heading","text":"Wildcard Pattern"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"wildcard pattern"}]},{"type":"text","text":" matches and ignores any value and consists of an underscore"},{"type":"text","text":" "},{"type":"text","text":"("},{"type":"codeVoice","code":"_"},{"type":"text","text":"). Use a wildcard pattern when you don’t care about the values being"},{"type":"text","text":" "},{"type":"text","text":"matched against. For example, the following code iterates through the closed range "},{"type":"codeVoice","code":"1...3"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"ignoring the current value of the range on each iteration of the loop:"}]},{"type":"codeListing","syntax":"swift","code":["for _ in 1...3 {","   \/\/ Do something three times.","}"]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a wildcard pattern","","wildcard-pattern --> ``_``"]},{"anchor":"Identifier-Pattern","level":2,"type":"heading","text":"Identifier Pattern"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier pattern"}]},{"type":"text","text":" matches any value and binds the matched value to a"},{"type":"text","text":" "},{"type":"text","text":"variable or constant name."},{"type":"text","text":" "},{"type":"text","text":"For example, in the following constant declaration, "},{"type":"codeVoice","code":"someValue"},{"type":"text","text":" is an identifier pattern"},{"type":"text","text":" "},{"type":"text","text":"that matches the value "},{"type":"codeVoice","code":"42"},{"type":"text","text":" of type "},{"type":"codeVoice","code":"Int"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let someValue = 42"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the match succeeds, the value "},{"type":"codeVoice","code":"42"},{"type":"text","text":" is bound (assigned)"},{"type":"text","text":" "},{"type":"text","text":"to the constant name "},{"type":"codeVoice","code":"someValue"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the pattern on the left-hand side of a variable or constant declaration"},{"type":"text","text":" "},{"type":"text","text":"is an identifier pattern,"},{"type":"text","text":" "},{"type":"text","text":"the identifier pattern is implicitly a subpattern of a value-binding pattern."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an identifier pattern","","identifier-pattern --> identifier"]},{"anchor":"Value-Binding-Pattern","level":2,"type":"heading","text":"Value-Binding Pattern"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"value-binding pattern"}]},{"type":"text","text":" binds matched values to variable or constant names."},{"type":"text","text":" "},{"type":"text","text":"Value-binding patterns that bind a matched value to the name of a constant"},{"type":"text","text":" "},{"type":"text","text":"begin with the "},{"type":"codeVoice","code":"let"},{"type":"text","text":" keyword; those that bind to the name of variable"},{"type":"text","text":" "},{"type":"text","text":"begin with the "},{"type":"codeVoice","code":"var"},{"type":"text","text":" keyword."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Identifiers patterns within a value-binding pattern"},{"type":"text","text":" "},{"type":"text","text":"bind new named variables or constants to their matching values. For example,"},{"type":"text","text":" "},{"type":"text","text":"you can decompose the elements of a tuple and bind the value of each element to a"},{"type":"text","text":" "},{"type":"text","text":"corresponding identifier pattern."}]},{"type":"codeListing","syntax":"swift","code":["let point = (3, 2)","switch point {","   \/\/ Bind x and y to the elements of point.","   case let (x, y):","      print(\"The point is at (\\(x), \\(y)).\")","}","\/\/ Prints \"The point is at (3, 2).\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above, "},{"type":"codeVoice","code":"let"},{"type":"text","text":" distributes to each identifier pattern in the"},{"type":"text","text":" "},{"type":"text","text":"tuple pattern "},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":". Because of this behavior, the "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" cases"},{"type":"text","text":" "},{"type":"codeVoice","code":"case let (x, y):"},{"type":"text","text":" and "},{"type":"codeVoice","code":"case (let x, let y):"},{"type":"text","text":" match the same values."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a value-binding pattern","","value-binding-pattern --> ``var`` pattern | ``let`` pattern"]},{"anchor":"Tuple-Pattern","level":2,"type":"heading","text":"Tuple Pattern"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple pattern"}]},{"type":"text","text":" is a comma-separated list of zero or more patterns, enclosed in"},{"type":"text","text":" "},{"type":"text","text":"parentheses. Tuple patterns match values of corresponding tuple types."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can constrain a tuple pattern to match certain kinds of tuple types"},{"type":"text","text":" "},{"type":"text","text":"by using type annotations."},{"type":"text","text":" "},{"type":"text","text":"For example, the tuple pattern "},{"type":"codeVoice","code":"(x, y): (Int, Int)"},{"type":"text","text":" in the constant declaration"},{"type":"text","text":" "},{"type":"codeVoice","code":"let (x, y): (Int, Int) = (1, 2)"},{"type":"text","text":" matches only tuple types in which"},{"type":"text","text":" "},{"type":"text","text":"both elements are of type "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When a tuple pattern is used as the pattern in a "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"type":"text","text":"or in a variable or constant declaration, it can contain only wildcard patterns,"},{"type":"text","text":" "},{"type":"text","text":"identifier patterns, optional patterns, or other tuple patterns that contain those."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the following code isn’t valid because the element "},{"type":"codeVoice","code":"0"},{"type":"text","text":" in the tuple pattern "},{"type":"codeVoice","code":"(x, 0)"},{"type":"text","text":" is"},{"type":"text","text":" "},{"type":"text","text":"an expression pattern:"}]},{"type":"codeListing","syntax":"swift","code":["let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]","\/\/ This code isn't valid.","for (x, 0) in points {","   \/* ... *\/","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The parentheses around a tuple pattern that contains a single element have no effect."},{"type":"text","text":" "},{"type":"text","text":"The pattern matches values of that single element’s type. For example, the following are"},{"type":"text","text":" "},{"type":"text","text":"equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["let a = 2        \/\/ a: Int = 2","let (a) = 2      \/\/ a: Int = 2","let (a): Int = 2 \/\/ a: Int = 2"]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a tuple pattern","","tuple-pattern --> ``(`` tuple-pattern-element-list-OPT ``)``","tuple-pattern-element-list --> tuple-pattern-element | tuple-pattern-element ``,`` tuple-pattern-element-list","tuple-pattern-element --> pattern | identifier ``:`` pattern"]},{"anchor":"Enumeration-Case-Pattern","level":2,"type":"heading","text":"Enumeration Case Pattern"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration case pattern"}]},{"type":"text","text":" matches a case of an existing enumeration type."},{"type":"text","text":" "},{"type":"text","text":"Enumeration case patterns appear in "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"type":"text","text":"case labels and in the case conditions of "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"while"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", and "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" "},{"type":"text","text":"statements."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the enumeration case you’re trying to match has any associated values,"},{"type":"text","text":" "},{"type":"text","text":"the corresponding enumeration case pattern must specify a tuple pattern that contains"},{"type":"text","text":" "},{"type":"text","text":"one element for each associated value. For an example that uses a "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"type":"text","text":"to match enumeration cases containing associated values,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations#Associated-Values"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An enumeration case pattern also matches"},{"type":"text","text":" "},{"type":"text","text":"values of that case wrapped in an optional."},{"type":"text","text":" "},{"type":"text","text":"This simplified syntax lets you omit an optional pattern."},{"type":"text","text":" "},{"type":"text","text":"Note that,"},{"type":"text","text":" "},{"type":"text","text":"because "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" is implemented as an enumeration,"},{"type":"text","text":" "},{"type":"codeVoice","code":".none"},{"type":"text","text":" and "},{"type":"codeVoice","code":".some"},{"type":"text","text":" can appear"},{"type":"text","text":" "},{"type":"text","text":"in the same switch as the cases of the enumeration type."}]},{"type":"codeListing","syntax":"swift","code":["enum SomeEnum { case left, right }","let x: SomeEnum? = .left","switch x {","case .left:","    print(\"Turn left\")","case .right:","    print(\"Turn right\")","case nil:","    print(\"Keep going straight\")","}","\/\/ Prints \"Turn left\""]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an enumeration case pattern","","enum-case-pattern --> type-identifier-OPT ``.`` enum-case-name tuple-pattern-OPT"]},{"anchor":"Optional-Pattern","level":2,"type":"heading","text":"Optional Pattern"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional pattern"}]},{"type":"text","text":" matches values wrapped in a "},{"type":"codeVoice","code":"some(Wrapped)"},{"type":"text","text":" case"},{"type":"text","text":" "},{"type":"text","text":"of an "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" enumeration."},{"type":"text","text":" "},{"type":"text","text":"Optional patterns consist of an identifier pattern followed immediately by a question mark"},{"type":"text","text":" "},{"type":"text","text":"and appear in the same places as enumeration case patterns."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because optional patterns are syntactic sugar for "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" "},{"type":"text","text":"enumeration case patterns,"},{"type":"text","text":" "},{"type":"text","text":"the following are equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["let someOptional: Int? = 42","\/\/ Match using an enumeration case pattern.","if case .some(let x) = someOptional {","   print(x)","}","","\/\/ Match using an optional pattern.","if case let x? = someOptional {","   print(x)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The optional pattern provides a convenient way to"},{"type":"text","text":" "},{"type":"text","text":"iterate over an array of optional values in a "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" statement,"},{"type":"text","text":" "},{"type":"text","text":"executing the body of the loop only for non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" elements."}]},{"type":"codeListing","syntax":"swift","code":["let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]","\/\/ Match only non-nil values.","for case let number? in arrayOfOptionalInts {","   print(\"Found a \\(number)\")","}","\/\/ Found a 2","\/\/ Found a 3","\/\/ Found a 5"]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an optional pattern","","optional-pattern --> identifier-pattern ``?``"]},{"anchor":"Type-Casting-Patterns","level":2,"type":"heading","text":"Type-Casting Patterns"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are two type-casting patterns, the "},{"type":"codeVoice","code":"is"},{"type":"text","text":" pattern and the "},{"type":"codeVoice","code":"as"},{"type":"text","text":" pattern."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"is"},{"type":"text","text":" pattern appears only in "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"type":"text","text":"case labels. The "},{"type":"codeVoice","code":"is"},{"type":"text","text":" and "},{"type":"codeVoice","code":"as"},{"type":"text","text":" patterns have the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["is <#type#>","<#pattern#> as <#type#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"is"},{"type":"text","text":" pattern matches a value if the type of that value at runtime is the same as"},{"type":"text","text":" "},{"type":"text","text":"the type specified in the right-hand side of the "},{"type":"codeVoice","code":"is"},{"type":"text","text":" pattern—or a subclass of that type."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"is"},{"type":"text","text":" pattern behaves like the "},{"type":"codeVoice","code":"is"},{"type":"text","text":" operator in that they both perform a type cast"},{"type":"text","text":" "},{"type":"text","text":"but discard the returned type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as"},{"type":"text","text":" pattern matches a value if the type of that value at runtime is the same as"},{"type":"text","text":" "},{"type":"text","text":"the type specified in the right-hand side of the "},{"type":"codeVoice","code":"as"},{"type":"text","text":" pattern—or a subclass of that type."},{"type":"text","text":" "},{"type":"text","text":"If the match succeeds,"},{"type":"text","text":" "},{"type":"text","text":"the type of the matched value is cast to the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" specified in the right-hand side"},{"type":"text","text":" "},{"type":"text","text":"of the "},{"type":"codeVoice","code":"as"},{"type":"text","text":" pattern."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For an example that uses a "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"type":"text","text":"to match values with "},{"type":"codeVoice","code":"is"},{"type":"text","text":" and "},{"type":"codeVoice","code":"as"},{"type":"text","text":" patterns,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Type-Casting-for-Any-and-AnyObject"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a type casting pattern","","type-casting-pattern --> is-pattern | as-pattern","is-pattern --> ``is`` type","as-pattern --> pattern ``as`` type"]},{"anchor":"Expression-Pattern","level":2,"type":"heading","text":"Expression Pattern"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression pattern"}]},{"type":"text","text":" represents the value of an expression."},{"type":"text","text":" "},{"type":"text","text":"Expression patterns appear only in "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"type":"text","text":"case labels."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The expression represented by the expression pattern"},{"type":"text","text":" "},{"type":"text","text":"is compared with the value of an input expression"},{"type":"text","text":" "},{"type":"text","text":"using the Swift standard library "},{"type":"codeVoice","code":"~="},{"type":"text","text":" operator."},{"type":"text","text":" "},{"type":"text","text":"The matches succeeds"},{"type":"text","text":" "},{"type":"text","text":"if the "},{"type":"codeVoice","code":"~="},{"type":"text","text":" operator returns "},{"type":"codeVoice","code":"true"},{"type":"text","text":". By default, the "},{"type":"codeVoice","code":"~="},{"type":"text","text":" operator compares"},{"type":"text","text":" "},{"type":"text","text":"two values of the same type using the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator."},{"type":"text","text":" "},{"type":"text","text":"It can also match a value with a range of values,"},{"type":"text","text":" "},{"type":"text","text":"by checking whether the value is contained within the range,"},{"type":"text","text":" "},{"type":"text","text":"as the following example shows."}]},{"type":"codeListing","syntax":"swift","code":["let point = (1, 2)","switch point {","   case (0, 0):","      print(\"(0, 0) is at the origin.\")","   case (-2...2, -2...2):","      print(\"(\\(point.0), \\(point.1)) is near the origin.\")","   default:","      print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"(1, 2) is near the origin.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can overload the "},{"type":"codeVoice","code":"~="},{"type":"text","text":" operator to provide custom expression matching behavior."},{"type":"text","text":" "},{"type":"text","text":"For example, you can rewrite the above example to compare the "},{"type":"codeVoice","code":"point"},{"type":"text","text":" expression"},{"type":"text","text":" "},{"type":"text","text":"with a string representations of points."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Overload the ~= operator to match a string with an integer.","func ~= (pattern: String, value: Int) -> Bool {","   return pattern == \"\\(value)\"","}","switch point {","   case (\"0\", \"0\"):","      print(\"(0, 0) is at the origin.\")","   default:","      print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"The point is at (1, 2).\""]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an expression pattern","","expression-pattern --> expression"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/patterns"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" represents the structure of a single value"},{"type":"text","text":" "},{"type":"text","text":"or a composite value."},{"type":"text","text":" "},{"type":"text","text":"For example, the structure of a tuple "},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" is a comma-separated list of two"},{"type":"text","text":" "},{"type":"text","text":"elements. Because patterns represent the structure of a value rather than any"},{"type":"text","text":" "},{"type":"text","text":"one particular value, you can match them with a variety of values."},{"type":"text","text":" "},{"type":"text","text":"For instance, the pattern "},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":" matches the tuple "},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" and any other"},{"type":"text","text":" "},{"type":"text","text":"two-element tuple. In addition to matching a pattern with a value,"},{"type":"text","text":" "},{"type":"text","text":"you can extract part or all of a composite value and bind each part"},{"type":"text","text":" "},{"type":"text","text":"to a constant or variable name."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Patterns","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Reference","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AboutTheLanguageReference","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Types","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Statements","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/GenericParametersAndArguments"],"generated":true}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Statements":{"role":"article","title":"Statements","abstract":[{"type":"text","text":"In Swift, there are three kinds of statements: simple statements, compiler control statements,"},{"type":"text","text":" "},{"type":"text","text":"and control flow statements."},{"type":"text","text":" "},{"type":"text","text":"Simple statements are the most common and consist of either an expression or a declaration."},{"type":"text","text":" "},{"type":"text","text":"Compiler control statements allow the program to change aspects of the compiler’s behavior"},{"type":"text","text":" "},{"type":"text","text":"and include a conditional compilation block and a line control statement."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Statements","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/statements"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Types":{"role":"article","title":"Tipos","abstract":[{"type":"text","text":"Em Swift, existem dois tipos de dados: tipos nomeados e tipos compostos."},{"type":"text","text":" "},{"type":"text","text":"Um "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipo nomeado"}]},{"type":"text","text":" é um tipo que pode receber um nome específico quando é definido."},{"type":"text","text":" "},{"type":"text","text":"Tipos nomeados incluem classes, structs, enums, e protocolos."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, instâncias de uma classe definida pelo usuário chamada "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":"  tem o tipo "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Além dos tipos nomeados definidos pelo usuário, a biblioteca padrão do Swift define muitos tipos nomeados que são usados com mais frequência, incluindo aqueles que representam arrays, dicionários, e valores opcionais."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Types","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes":{"role":"article","title":"Attributes","abstract":[{"type":"text","text":"There are two kinds of attributes in Swift —"},{"type":"text","text":" "},{"type":"text","text":"those that apply to declarations and those that apply to types."},{"type":"text","text":" "},{"type":"text","text":"An attribute provides additional information about the declaration or type."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"discardableResult"},{"type":"text","text":" attribute on a function declaration indicates that,"},{"type":"text","text":" "},{"type":"text","text":"although the function returns a value,"},{"type":"text","text":" "},{"type":"text","text":"the compiler shouldn’t generate a warning if the return value is unused."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/attributes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/GenericParametersAndArguments":{"role":"article","title":"Generic Parameters and Arguments","abstract":[{"type":"text","text":"This chapter describes parameters and arguments for generic types, functions, and"},{"type":"text","text":" "},{"type":"text","text":"initializers. When you declare a generic type, function, subscript, or initializer,"},{"type":"text","text":" "},{"type":"text","text":"you specify the type parameters that the generic type, function, or initializer"},{"type":"text","text":" "},{"type":"text","text":"can work with. These type parameters act as placeholders that"},{"type":"text","text":" "},{"type":"text","text":"are replaced by actual concrete type arguments when an instance of a generic type is"},{"type":"text","text":" "},{"type":"text","text":"created or a generic function or initializer is called."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/GenericParametersAndArguments","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/genericparametersandarguments"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions":{"role":"article","title":"Expressions","abstract":[{"type":"text","text":"In Swift, there are four kinds of expressions:"},{"type":"text","text":" "},{"type":"text","text":"prefix expressions, infix expressions, primary expressions, and postfix expressions."},{"type":"text","text":" "},{"type":"text","text":"Evaluating an expression returns a value,"},{"type":"text","text":" "},{"type":"text","text":"causes a side effect, or both."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/expressions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/LexicalStructure":{"role":"article","title":"Lexical Structure","abstract":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"lexical structure"}]},{"type":"text","text":" of Swift describes what sequence of characters"},{"type":"text","text":" "},{"type":"text","text":"form valid tokens of the language."},{"type":"text","text":" "},{"type":"text","text":"These valid tokens form the lowest-level building blocks of the language"},{"type":"text","text":" "},{"type":"text","text":"and are used to describe the rest of the language in subsequent chapters."},{"type":"text","text":" "},{"type":"text","text":"A token consists of an identifier, keyword, punctuation, literal, or operator."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/lexicalstructure"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Enumerations#Associated-Values":{"abstract":[],"title":"Associated Values","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations#Associated-Values","url":"\/documentation\/the-swift-programming-language\/enumerations#Associated-Values"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting#Type-Casting-for-Any-and-AnyObject":{"abstract":[],"title":"Type Casting for Any and AnyObject","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Type-Casting-for-Any-and-AnyObject","url":"\/documentation\/the-swift-programming-language\/typecasting#Type-Casting-for-Any-and-AnyObject"},"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations":{"role":"article","title":"Declarations","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"declaration"}]},{"type":"text","text":" introduces a new name or construct into your program."},{"type":"text","text":" "},{"type":"text","text":"For example, you use declarations to introduce functions and methods,"},{"type":"text","text":" "},{"type":"text","text":"to introduce variables and constants,"},{"type":"text","text":" "},{"type":"text","text":"and to define enumeration, structure, class, and protocol types."},{"type":"text","text":" "},{"type":"text","text":"You can also use a declaration to extend the behavior"},{"type":"text","text":" "},{"type":"text","text":"of an existing named type and to import symbols into your program that are declared elsewhere."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/declarations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AboutTheLanguageReference":{"role":"article","title":"About the Language Reference","abstract":[{"type":"text","text":"This part of the book describes the formal grammar of the Swift programming language."},{"type":"text","text":" "},{"type":"text","text":"The grammar described here is intended to help you understand the language in more"},{"type":"text","text":" "},{"type":"text","text":"detail, rather than to allow you to directly implement a parser or compiler."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AboutTheLanguageReference","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/aboutthelanguagereference"}}}