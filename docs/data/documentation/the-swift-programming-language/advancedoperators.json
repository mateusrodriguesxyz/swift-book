{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Ao contrário dos operadores aritméticos em C,"},{"type":"text","text":" "},{"type":"text","text":"os operadores aritméticos em Swift não possuem overflow por padrão."},{"type":"text","text":" "},{"type":"text","text":"O overflow é interceptado e relatado como um erro."},{"type":"text","text":" "},{"type":"text","text":"Para ativar o overflow,"},{"type":"text","text":" "},{"type":"text","text":"use o segundo conjunto de operadores aritméticos de Swift,"},{"type":"text","text":" "},{"type":"text","text":"como o operador de adição de overflow ("},{"type":"codeVoice","code":"&+"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"Todos esses operadores de overflow começam com um e comercial ("},{"type":"codeVoice","code":"&"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Quando você define suas próprias estruturas, classes, e enumerações,"},{"type":"text","text":" "},{"type":"text","text":"pode ser útil fornecer suas próprias implementações dos"},{"type":"text","text":" "},{"type":"text","text":"operadores padrão do Swift para esses tipos personalizados."},{"type":"text","text":" "},{"type":"text","text":"O Swift facilita o fornecimento de implementações personalizadas desses operadores"},{"type":"text","text":" "},{"type":"text","text":"e determina exatamente qual deve ser o comportamento deles para cada tipo criado."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Você não está limitado a operadores predefinidos."},{"type":"text","text":" "},{"type":"text","text":"A linguagem Swift dá liberdade de definir a forma como personaliza"},{"type":"text","text":" "},{"type":"text","text":"operadores de infixo, prefixo, pós-fixo, e atribuição,"},{"type":"text","text":" "},{"type":"text","text":"com precedência personalizada e valores associativos."},{"type":"text","text":" "},{"type":"text","text":"Esses operadores podem ser usados e adotados no código como qualquer um dos operadores predefinidos,"},{"type":"text","text":" "},{"type":"text","text":"e você pode até estender os tipos existentes para suporte de operadores personalizados que você definir."}]},{"anchor":"Operadores-Bit-a-bit","level":2,"type":"heading","text":"Operadores Bit a bit"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Operadores bit a bit"}]},{"type":"text","text":" permitem que você manipule"},{"type":"text","text":" "},{"type":"text","text":"os bits de dados brutos individuais, dentro de uma estrutura de dados."},{"type":"text","text":" "},{"type":"text","text":"Eles são frequentemente usados em programação de baixo-nível,"},{"type":"text","text":" "},{"type":"text","text":"como em programação gráfica e criação de driver de dispositivo."},{"type":"text","text":" "},{"type":"text","text":"Operadores bit a bit podem ser úteis quando você trabalha com dados brutos para fontes externas,"},{"type":"text","text":" "},{"type":"text","text":"como codificação e decodificação de dados para comunicação por meio de um protocolo personalizado."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O Swift suporta todos os operadores bit a bit encontrados em C, como descrito abaixo."}]},{"anchor":"Operador-Bitwise-NOT","level":3,"type":"heading","text":"Operador Bitwise NOT"},{"type":"paragraph","inlineContent":[{"type":"text","text":"O "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operador "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise NOT"}]}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"~"},{"type":"text","text":") inverte todos os bits em um número:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitwiseNOT"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O operador "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise NOT"}]},{"type":"text","text":" é um operador de pré-fixo"},{"type":"text","text":" "},{"type":"text","text":"e aparece imediatamente antes do valor a qual opera,"},{"type":"text","text":" "},{"type":"text","text":"sem nenhum espaço em branco:"}]},{"type":"codeListing","syntax":"swift","code":["let initialBits: UInt8 = 0b00001111","let invertedBits = ~initialBits  \/\/ igual a 11110000"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O inteiro "},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" tem oito bits"},{"type":"text","text":" "},{"type":"text","text":"e cada um pode armazenar qualquer valor entre "},{"type":"codeVoice","code":"0"},{"type":"text","text":" e "},{"type":"codeVoice","code":"255"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Este exemplo inicializa um inteiro "},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" com o valor binário "},{"type":"codeVoice","code":"00001111"},{"type":"text","text":" "},{"type":"text","text":"que tem "},{"type":"codeVoice","code":"0"},{"type":"text","text":" nos primeiros quatro bits,"},{"type":"text","text":" "},{"type":"text","text":"e "},{"type":"codeVoice","code":"1"},{"type":"text","text":" nos seu segundo conjunto de quatro bits."},{"type":"text","text":" "},{"type":"text","text":"Isso equivale ao decimal de valor "},{"type":"codeVoice","code":"15"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O operador "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise NOT"}]},{"type":"text","text":" é então usado para criar uma nova constante chamada "},{"type":"codeVoice","code":"invertedBits"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"que é igual ao "},{"type":"codeVoice","code":"initialBits"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"mas com todos os bits invertidos."},{"type":"text","text":" "},{"type":"text","text":"Zeros viram uns e uns viram zeros."},{"type":"text","text":" "},{"type":"text","text":"O valor de "},{"type":"codeVoice","code":"invertedBits"},{"type":"text","text":" é "},{"type":"codeVoice","code":"11110000"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"que equivale a um decimal não atribuido de valor "},{"type":"codeVoice","code":"240"},{"type":"text","text":"."}]},{"anchor":"Operador-Bit-a-bit-AND","level":3,"type":"heading","text":"Operador Bit a bit AND"},{"type":"paragraph","inlineContent":[{"type":"text","text":"O "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operador bit a bit AND"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"&"},{"type":"text","text":") combina os bits de dois números."},{"type":"text","text":" "},{"type":"text","text":"Ele retorna um novo número cujo os bits são definitos como  "},{"type":"codeVoice","code":"1"},{"type":"text","text":" "},{"type":"text","text":"somente se os bits forem igual a "},{"type":"codeVoice","code":"1"},{"type":"text","text":" em ambos os numeros de entrada:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitwiseAND"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"No exemplo abaixo,"},{"type":"text","text":" "},{"type":"text","text":"os valores de "},{"type":"codeVoice","code":"firstSixBits"},{"type":"text","text":" e "},{"type":"codeVoice","code":"lastSixBits"},{"type":"text","text":" "},{"type":"text","text":"ambos têm quatro bit no meio igual a "},{"type":"codeVoice","code":"1"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"O operador bit a bit AND combina os dois para formar o número "},{"type":"codeVoice","code":"00111100"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"que é igual ao decinal não atribuído de valor "},{"type":"codeVoice","code":"60"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let firstSixBits: UInt8 = 0b11111100","let lastSixBits: UInt8  = 0b00111111","let middleFourBits = firstSixBits & lastSixBits  \/\/ equals 00111100"]},{"anchor":"Operador-bit-a-bit-OR","level":3,"type":"heading","text":"Operador bit a bit OR"},{"type":"paragraph","inlineContent":[{"type":"text","text":"O "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operador bit a bit OR"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"|"},{"type":"text","text":") compara os bits de dois números."},{"type":"text","text":" "},{"type":"text","text":"O operador retorna um novo número cujo os bits são definidos como  "},{"type":"codeVoice","code":"1"},{"type":"text","text":" "},{"type":"text","text":"se os bits forem iguais a "},{"type":"codeVoice","code":"1"},{"type":"text","text":" em "},{"type":"emphasis","inlineContent":[{"type":"text","text":"nenhum"}]},{"type":"text","text":" dos números de entrada."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitwiseOR"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"No exemplo abaixo,"},{"type":"text","text":" "},{"type":"text","text":"os valores de "},{"type":"codeVoice","code":"someBits"},{"type":"text","text":" e "},{"type":"codeVoice","code":"moreBits"},{"type":"text","text":" têm diferentes bits definidos como "},{"type":"codeVoice","code":"1"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"O operador bit a bit OR os combina para formar o número "},{"type":"codeVoice","code":"11111110"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"que é equivalente ao decimal não atribuído de valor "},{"type":"codeVoice","code":"254"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let someBits: UInt8 = 0b10110010","let moreBits: UInt8 = 0b01011110","let combinedbits = someBits | moreBits  \/\/ é igual a 11111110"]},{"anchor":"Bitwise-XOR-Operator","level":3,"type":"heading","text":"Bitwise XOR Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise XOR operator"}]},{"type":"text","text":", or “exclusive OR operator” ("},{"type":"codeVoice","code":"^"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"compares the bits of two numbers."},{"type":"text","text":" "},{"type":"text","text":"The operator returns a new number whose bits are set to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" "},{"type":"text","text":"where the input bits are different"},{"type":"text","text":" "},{"type":"text","text":"and are set to "},{"type":"codeVoice","code":"0"},{"type":"text","text":" where the input bits are the same:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitwiseXOR"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example below,"},{"type":"text","text":" "},{"type":"text","text":"the values of "},{"type":"codeVoice","code":"firstBits"},{"type":"text","text":" and "},{"type":"codeVoice","code":"otherBits"},{"type":"text","text":" each have a bit set to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" "},{"type":"text","text":"in a location that the other does not."},{"type":"text","text":" "},{"type":"text","text":"The bitwise XOR operator sets both of these bits to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" in its output value."},{"type":"text","text":" "},{"type":"text","text":"All of the other bits in "},{"type":"codeVoice","code":"firstBits"},{"type":"text","text":" and "},{"type":"codeVoice","code":"otherBits"},{"type":"text","text":" match"},{"type":"text","text":" "},{"type":"text","text":"and are set to "},{"type":"codeVoice","code":"0"},{"type":"text","text":" in the output value:"}]},{"type":"codeListing","syntax":"swift","code":["let firstBits: UInt8 = 0b00010100","let otherBits: UInt8 = 0b00000101","let outputBits = firstBits ^ otherBits  \/\/ equals 00010001"]},{"anchor":"Deslocamento-à-esquerda-e-à-direita","level":3,"type":"heading","text":"Deslocamento à esquerda e à direita"},{"type":"paragraph","inlineContent":[{"type":"text","text":"O "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operador com deslocamento à esquerda"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"<<"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"e o "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operador com deslocamento à direita"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":">>"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"move todos os bits em um número para a esquerda ou para a direita considerando um certo número de espaços,"},{"type":"text","text":" "},{"type":"text","text":"de acordo com as regras definidas abaixo."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Deslocamentos bit a bit à esquerda e à direita têm um efeito de"},{"type":"text","text":" "},{"type":"text","text":"multiplicador ou divisor de um número inteiro pelo fator dois."},{"type":"text","text":" "},{"type":"text","text":"Deslocar bits de um inteiro à esquerda em uma posição dobra seu valor,"},{"type":"text","text":" "},{"type":"text","text":"enquanto que deslocá-lo para a direita em uma posição reduz pela metade o seu valor."}]},{"anchor":"Comportamento-de-deslocamento-de-bits-para-inteiros-não-sinalizados","level":4,"type":"heading","text":"Comportamento de deslocamento de bits para inteiros não sinalizados"},{"type":"paragraph","inlineContent":[{"type":"text","text":"O comportamento de descolamento de bits para inteiros não sinalizados é o seguinte:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Bits existentes são deslocado para a esquerda ou direita pelo número de posições solicitadas."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Quaisquer bits que são deslocamento além dos limites do armazenamento dos inteiros são descartados."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Os zeros são inseridos em espaços deixados para trás depois que os bits originais foram deslocados para a esquerda ou direita."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Essa abordagem é conhecida como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"d lógica"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A ilustração abaixo mostra os resultados de ‘11111111 << 1’"},{"type":"text","text":" "},{"type":"text","text":"(o qual ‘11111111’ é movido para a direita por ‘1’ posição),"},{"type":"text","text":" "},{"type":"text","text":"e ‘11111111 >> 1’"},{"type":"text","text":" "},{"type":"text","text":"(o qual ‘11111111’ é movido para a direita por ‘1’ posição)."},{"type":"text","text":" "},{"type":"text","text":"Os números azuis são movidos,"},{"type":"text","text":" "},{"type":"text","text":"os números cinzas são descartados,"},{"type":"text","text":" "},{"type":"text","text":"e os zeros laranjas são inseridos."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftUnsigned"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Confira como o bit movido aparece na Swift:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"‘’’swift"},{"type":"text","text":" "},{"type":"text","text":"let shiftBits: UInt8 = 4   \/\/ 00000100 in binary"},{"type":"text","text":" "},{"type":"text","text":"shiftBits << 1             \/\/ 00001000"},{"type":"text","text":" "},{"type":"text","text":"shiftBits << 2             \/\/ 00010000"},{"type":"text","text":" "},{"type":"text","text":"shiftBits << 5             \/\/ 10000000"},{"type":"text","text":" "},{"type":"text","text":"shiftBits << 6             \/\/ 00000000"},{"type":"text","text":" "},{"type":"text","text":"shiftBits >> 2             \/\/ 00000001"},{"type":"text","text":" "},{"type":"text","text":"‘’’"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Você pode usar o deslocamento de bit para codificar e descodificar valores com outros tipos de dados:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"‘’’swift"},{"type":"text","text":" "},{"type":"text","text":"let pink: UInt32 = 0xCC6699"},{"type":"text","text":" "},{"type":"text","text":"let redComponent = (pink & 0xFF0000) >> 16    \/\/ redComponent is 0xCC, or 204"},{"type":"text","text":" "},{"type":"text","text":"let greenComponent = (pink & 0x00FF00) >> 8   \/\/ greenComponent is 0x66, or 102"},{"type":"text","text":" "},{"type":"text","text":"let blueComponent = pink & 0x0000FF           \/\/ blueComponent is 0x99, or 153"},{"type":"text","text":" "},{"type":"text","text":"‘’’"}]},{"anchor":"Comportamento-de-Deslocamento-para-Inteiros-com-Sinal","level":4,"type":"heading","text":"Comportamento de Deslocamento para Inteiros com Sinal"},{"type":"paragraph","inlineContent":[{"type":"text","text":"O comportamento de deslocamento é mais complicado para inteiros com sinal do que para inteiros sem sinal,"},{"type":"text","text":" "},{"type":"text","text":"por conta da maneira que são representados em modo binário."},{"type":"text","text":" "},{"type":"text","text":"(Os exemplos a seguir são baseados em inteiros com sinal de 8-bits para simplificar,"},{"type":"text","text":" "},{"type":"text","text":"mas os mesmos princípios podem ser aplicados para inteiros com sinal de qualquer tamanho.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Inteiros com sinal usam o primeiro bit (conhecido como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bit de sinal"}]},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"para indicar que o inteiro é positivo ou negativo."},{"type":"text","text":" "},{"type":"text","text":"O sinal para o bit "},{"type":"codeVoice","code":"0"},{"type":"text","text":"siginifica positivo, e o sinal para bit "},{"type":"codeVoice","code":"1"},{"type":"text","text":" significa negativo."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Os bits restantes (conhecidos como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bits de valor"}]},{"type":"text","text":") armazenam o valor atual."},{"type":"text","text":" "},{"type":"text","text":"Os números positivos são armazenados exatamente da mesma maneira que os inteiros sem sinal,"},{"type":"text","text":" "},{"type":"text","text":"adicionando o "},{"type":"codeVoice","code":"0"},{"type":"text","text":" à posição inicial."},{"type":"text","text":" "},{"type":"text","text":"Veja como os bits dentro do "},{"type":"codeVoice","code":"Int8"},{"type":"text","text":" buscam o número "},{"type":"codeVoice","code":"4"},{"type":"text","text":":"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSignedFour"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O bit de sinal é "},{"type":"codeVoice","code":"0"},{"type":"text","text":"(significa “positivo”)"},{"type":"text","text":" "},{"type":"text","text":"e os sete bits de valor são o número "},{"type":"codeVoice","code":"4"},{"type":"text","text":" "},{"type":"text","text":"escrito em notação binária."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Números negativos, no entanto, são armazenados de forma diferente."},{"type":"text","text":" "},{"type":"text","text":"Eles são armazenados subtraindo de seu valor absoluto "},{"type":"codeVoice","code":"2"},{"type":"text","text":" à potência de "},{"type":"codeVoice","code":"n"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"onde "},{"type":"codeVoice","code":"n"},{"type":"text","text":" é o número de bits de valor."},{"type":"text","text":" "},{"type":"text","text":"Um número de oito bits tem sete bits de valor,"},{"type":"text","text":" "},{"type":"text","text":"então isso significa "},{"type":"codeVoice","code":"2"},{"type":"text","text":" elevado a potência "},{"type":"codeVoice","code":"7"},{"type":"text","text":", ou "},{"type":"codeVoice","code":"128"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Veja como os bits dentro de um "},{"type":"codeVoice","code":"Int8"},{"type":"text","text":" buscam o número "},{"type":"codeVoice","code":"-4"},{"type":"text","text":":"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSignedMinusFour"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Desta vez, o bit de sinal é "},{"type":"codeVoice","code":"1"},{"type":"text","text":" (significando “negativo”),"},{"type":"text","text":" "},{"type":"text","text":"e os sete bits de valor têm um valor binário de "},{"type":"codeVoice","code":"124"},{"type":"text","text":" (que é "},{"type":"codeVoice","code":"128 - 4"},{"type":"text","text":"):"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSignedMinusFourValue"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Essa codificação para números negativos é uma representação conhecida como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"complemento de dois"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Pode parecer uma maneira incomum de representar números negativos,"},{"type":"text","text":" "},{"type":"text","text":"mas tem várias vantagens."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Primeiro, você pode adicionar "},{"type":"codeVoice","code":"-1"},{"type":"text","text":" a "},{"type":"codeVoice","code":"-4"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"simplesmente executando uma adição binária padrão de todos os oito bits"},{"type":"text","text":" "},{"type":"text","text":"(incluindo o bit de sinal),"},{"type":"text","text":" "},{"type":"text","text":"e descartando qualquer coisa que não se encaixe nos oito bits quando terminar:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSignedAddition"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Segundo, a representação do complemento de dois também permite que você"},{"type":"text","text":" "},{"type":"text","text":"desloque os bits de números negativos para a esquerda e para a direita como números positivos,"},{"type":"text","text":" "},{"type":"text","text":"e ainda acabam dobrando-os para cada deslocamento que você faz para a esquerda,"},{"type":"text","text":" "},{"type":"text","text":"ou reduzi-los pela metade para cada mudança que você faz para a direita."},{"type":"text","text":" "},{"type":"text","text":"Para conseguir isso, uma regra extra é usada quando os inteiros com sinal são deslocados para a direita:"},{"type":"text","text":" "},{"type":"text","text":"Quando você desloca inteiros com sinal para a direita,"},{"type":"text","text":" "},{"type":"text","text":"aplique as mesmas regras que para inteiros sem sinal,"},{"type":"text","text":" "},{"type":"text","text":"mas preencha quaisquer bits vazios à esquerda com o "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bit de sinal"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"ao invés de um zero."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSigned"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Essa ação garante que os inteiros com sinal tenham o mesmo sinal depois de serem deslocados para a direita,"},{"type":"text","text":" "},{"type":"text","text":"conhecido como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"deslocamento aritmético"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Por causa da maneira especial que os números positivos e negativos são armazenados,"},{"type":"text","text":" "},{"type":"text","text":"deslocar qualquer um deles para a direita os aproxima de zero."},{"type":"text","text":" "},{"type":"text","text":"Manter o bit de sinal o mesmo durante este deslocamento significa que"},{"type":"text","text":" "},{"type":"text","text":"inteiros negativos permanecem negativos à medida que seu valor se aproxima de zero."}]},{"anchor":"Overflow-Operators","level":2,"type":"heading","text":"Overflow Operators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Se você tentar inserir um número em uma constante ou variável inteira que não pode manter esse valor,"},{"type":"text","text":" "},{"type":"text","text":"por padrão o Swift relata um erro em vez de permitir que um valor inválido seja criado."},{"type":"text","text":" "},{"type":"text","text":"Este comportamento oferece segurança extra ao trabalhar com números muito grandes ou muito pequenos."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Por examplo, o tipo inteiro "},{"type":"codeVoice","code":"Int16"},{"type":"text","text":" pode conter qualquer inteiro assinado entre "},{"type":"codeVoice","code":"-32768"},{"type":"text","text":" e "},{"type":"codeVoice","code":"32767"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Tentando definir uma constante ou variável "},{"type":"codeVoice","code":"Int16"},{"type":"text","text":" para um número fora desse intervalo causa um erro:"}]},{"type":"codeListing","syntax":"swift","code":["var potentialOverflow = Int16.max","\/\/ potentialOverflow igual a 32767, que é o valor máximo que um Int16 pode manter","potentialOverflow += 1","\/\/ isso causa um erro"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Fornecendo tratamento de erros quando os valores ficam muito grandes ou muito pequenos oferece muito mais flexibilidade quando codificar para condições de valor limite."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"No entanto, quando você quer especificamente uma condição de overflow para truncar o número de bits disponíveis, você pode optar  por este comportamente em vez de desencadear um erro."},{"type":"text","text":" "},{"type":"text","text":"Swift fornece três "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operadores de overflow"}]},{"type":"text","text":" aritméticos que optam pelo comportamento de overflow para cálculos inteiros."},{"type":"text","text":" "},{"type":"text","text":"Todos esse operadores começam com um "},{"type":"codeVoice","code":"e"},{"type":"text","text":" comercial ("},{"type":"codeVoice","code":"&"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"These operators all begin with an ampersand ("},{"type":"codeVoice","code":"&"},{"type":"text","text":"):"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Overflow de adição ("},{"type":"codeVoice","code":"&+"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Overflow de subtração ("},{"type":"codeVoice","code":"&-"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Overflow de multiplicação ("},{"type":"codeVoice","code":"&*"},{"type":"text","text":")"}]}]}]},{"anchor":"Valor-de-Overflow","level":3,"type":"heading","text":"Valor de Overflow"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Números podem transbordar tanto em direções positivas como em negativas."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Aqui está um exemplo do que acontece quando"},{"type":"text","text":" "},{"type":"text","text":"um inteiro sem sinal é permitido estourar um sentido positivo,"},{"type":"text","text":" "},{"type":"text","text":"usando um operador de adição de overflow."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"(’&+’):"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"‘’’swift"},{"type":"text","text":" "},{"type":"text","text":"var unsignedOverflow = UInt8.max"},{"type":"text","text":" "},{"type":"text","text":"\/\/ O unsignedOverflow é igual a 255, que é o valor máximo que UInt8 pode conterunsignedOverflow = unsignedOverflow &+ 1"},{"type":"text","text":" "},{"type":"text","text":"\/\/ Agora, o unsignedOverflow é igual a 0."},{"type":"text","text":" "},{"type":"text","text":"‘’’"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A variável ‘unsignedOverflow’ é inicializada com o valor máximo que um ‘UInt8’ pode conter"},{"type":"text","text":" "},{"type":"text","text":"(‘255’ ou ‘11111111’ em binário)."},{"type":"text","text":" "},{"type":"text","text":"É então incrementado por ‘1’ usando o operador de adição de overflow(’&+’)."},{"type":"text","text":" "},{"type":"text","text":"Isso empurra sua representação binária um pouco acima do tamanho que um ‘UInt8’ pode conter,"},{"type":"text","text":" "},{"type":"text","text":"fazendo com que ele transborde além de seus limites,"},{"type":"text","text":" "},{"type":"text","text":"como mostrado no diagrama abaixo."},{"type":"text","text":" "},{"type":"text","text":"O valor que permanece dentro dos limites do ‘UInt8’"},{"type":"text","text":" "},{"type":"text","text":"após a adição de overlow é ‘00000000’, ou zero."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"overflowAddition"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Algo parecido acontece quando"},{"type":"text","text":" "},{"type":"text","text":"um inteiro sem sinal é permitido estourar em um sentido negativo."},{"type":"text","text":" "},{"type":"text","text":"Aqui está um exemplo usando um operador de subtração de overflow (’&-’):"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"‘’’swift"},{"type":"text","text":" "},{"type":"text","text":"var unsignedOverflow = UInt8.min"},{"type":"text","text":" "},{"type":"text","text":"\/\/ O unsignedOverflow é igual a 0, que é o valor mínimo que uma UInt8 pode conter"},{"type":"text","text":" "},{"type":"text","text":"unsignedOverflow = unsignedOverflow &- 1"},{"type":"text","text":" "},{"type":"text","text":"\/\/ Agora, o unseignedOverflow é igual a 255"},{"type":"text","text":" "},{"type":"text","text":"‘’’"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O valor mínimo que ‘UInt8’ pode conter é zero,"},{"type":"text","text":" "},{"type":"text","text":"ou ‘00000000’ em binário."},{"type":"text","text":" "},{"type":"text","text":"Se você subtrair ‘1’ de ‘00000000’ usando um operador de subtração de overflow (’&-’),"},{"type":"text","text":" "},{"type":"text","text":"o número vai estourar e envolver com ‘11111111’"},{"type":"text","text":" "},{"type":"text","text":"ou com ‘255’ em decimal."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"overflowUnsignedSubtraction"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O overflow também ocorre para inteiros com sinal."},{"type":"text","text":" "},{"type":"text","text":"Todas as somas e subtrações para inteiros com sinal são executadas de forma bit a bit,"},{"type":"text","text":" "},{"type":"text","text":"com o bit de sinal incluído como parte dos números sendo adicionados ou subtraídos,"},{"type":"text","text":" "},{"type":"text","text":"conforme descrito em "},{"type":"text","text":"doc:AdvancedOperators#Bitwise-Left-and-Right-Shift-Operators"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"‘’’swift"},{"type":"text","text":" "},{"type":"text","text":"var signedOverflow = Int8.min"},{"type":"text","text":" "},{"type":"text","text":"\/\/ O signedOverflow é igual a -128, que é o valor mínimo que uma UInt8 pode conter"},{"type":"text","text":" "},{"type":"text","text":"signedOverflow = signedOverflow &- 1"},{"type":"text","text":" "},{"type":"text","text":"\/\/ O signedOverflow agora é igual a 127"},{"type":"text","text":" "},{"type":"text","text":"‘’’"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O valor mínimo que um ‘Int8’ pode conter é ‘-128’"},{"type":"text","text":" "},{"type":"text","text":"ou ‘10000000’ em binário,"},{"type":"text","text":" "},{"type":"text","text":"Subtraindo ‘1’ de seu número binário com o operador de overflow"},{"type":"text","text":" "},{"type":"text","text":"resulta no valor binário ‘01111111’,"},{"type":"text","text":" "},{"type":"text","text":"que alterna o bit de sinal e resulta em positivo ‘127’"},{"type":"text","text":" "},{"type":"text","text":"o valor positivo máximo que um ‘Int8’ pode conter."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"overflowSignedSubtraction"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Para inteiros com e sem sinal,"},{"type":"text","text":" "},{"type":"text","text":"o overflow na direção positiva"},{"type":"text","text":" "},{"type":"text","text":"envolve do valor inteiro válido máximo de volta ao mínimo,"},{"type":"text","text":" "},{"type":"text","text":"e o overflow na direção negativa"},{"type":"text","text":" "},{"type":"text","text":"envolve do valor mínimo ao máximo."}]},{"anchor":"Precedência-e-Associatividade","level":2,"type":"heading","text":"Precedência e Associatividade"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"precedência"}]},{"type":"text","text":" do operador dá a alguns operadores prioridade mais alta do que a outros;"},{"type":"text","text":" "},{"type":"text","text":"esses operadores são aplicados primeiro."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"associatividade"}]},{"type":"text","text":" do operador define como os operadores de mesma precedência"},{"type":"text","text":" "},{"type":"text","text":"estão agrupados —"},{"type":"text","text":" "},{"type":"text","text":"agrupados à esquerda ou à direita."},{"type":"text","text":" "},{"type":"text","text":"Pense nisso como significando “eles associam com a expressão à sua esquerda”,"},{"type":"text","text":" "},{"type":"text","text":"ou “associam-se à expressão à sua direita”."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"É importante considerar"},{"type":"text","text":" "},{"type":"text","text":"a precedência e associatividade de cada operador"},{"type":"text","text":" "},{"type":"text","text":"ao calcular a ordem na qual uma expressão composta será executada."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo,"},{"type":"text","text":" "},{"type":"text","text":"a precedência do operador explica por que a seguinte expressão é igual a "},{"type":"codeVoice","code":"17"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["2 + 3 % 4 * 5","\/\/ isso é igual a 17"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Se você ler estritamente da esquerda para a direita,"},{"type":"text","text":" "},{"type":"text","text":"você pode esperar que a expressão seja calculada da seguinte forma:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"2"},{"type":"text","text":" mais "},{"type":"codeVoice","code":"3"},{"type":"text","text":" é igual a "},{"type":"codeVoice","code":"5"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"5"},{"type":"text","text":" módulo "},{"type":"codeVoice","code":"4"},{"type":"text","text":" é igual a "},{"type":"codeVoice","code":"1"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"1"},{"type":"text","text":" vezes "},{"type":"codeVoice","code":"5"},{"type":"text","text":" é igual a "},{"type":"codeVoice","code":"5"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"No entanto, a resposta certa é "},{"type":"codeVoice","code":"17"},{"type":"text","text":", não "},{"type":"codeVoice","code":"5"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Os operadores de maior precedência são avaliados antes dos de menor precedência."},{"type":"text","text":" "},{"type":"text","text":"Em Swift, como em C,"},{"type":"text","text":" "},{"type":"text","text":"o operador de módulo ("},{"type":"codeVoice","code":"%"},{"type":"text","text":") e o operador de multiplicação ("},{"type":"codeVoice","code":"*"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"têm uma precedência maior do que o operador de adição ("},{"type":"codeVoice","code":"+"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"Como resultado, ambos são avaliados antes que a adição seja considerada."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"No entanto, módulo e multiplicação têm a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"mesma"}]},{"type":"text","text":" precedência."},{"type":"text","text":" "},{"type":"text","text":"Para descobrir a ordem exata de avaliação a ser usada,"},{"type":"text","text":" "},{"type":"text","text":"você também precisa considerar sua associatividade."},{"type":"text","text":" "},{"type":"text","text":"O módulo e a multiplicação associam-se à expressão à sua esquerda."},{"type":"text","text":" "},{"type":"text","text":"Pense nisso como adicionar parênteses implícitos em torno dessas partes da expressão,"},{"type":"text","text":" "},{"type":"text","text":"começando pela esquerda:"}]},{"type":"codeListing","syntax":"swift","code":["2 + ((3 % 4) * 5)"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"(3 % 4)"},{"type":"text","text":" é "},{"type":"codeVoice","code":"3"},{"type":"text","text":", então isso é equivalente a:"}]},{"type":"codeListing","syntax":"swift","code":["2 + (3 * 5)"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"(3 * 5)"},{"type":"text","text":" é "},{"type":"codeVoice","code":"15"},{"type":"text","text":", então isso é equivalente a:"}]},{"type":"codeListing","syntax":"swift","code":["2 + 15"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Este cálculo produz a resposta final de "},{"type":"codeVoice","code":"17"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Para obter informações sobre os operadores fornecidos pela biblioteca padrão do Swift,"},{"type":"text","text":" "},{"type":"text","text":"incluindo uma lista completa dos grupos de precedência do operador e configurações de associatividade,"},{"type":"text","text":" "},{"type":"text","text":"Veja "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"as precedências de operadores e as regras de associatividade do Swift são mais simples e previsíveis"},{"type":"text","text":" "},{"type":"text","text":"do que os encontrados em C e Objective-C."},{"type":"text","text":" "},{"type":"text","text":"No entanto, isso significa que eles não são exatamente os mesmos que em linguagens baseadas em C."},{"type":"text","text":" "},{"type":"text","text":"Tenha cuidado em garantir que as interações dos operadores ainda se comportem da maneira esperada"},{"type":"text","text":" "},{"type":"text","text":"ao portar um código para o Swift."}]}],"type":"aside","name":"Nota"},{"anchor":"Operator-Methods","level":2,"type":"heading","text":"Operator Methods"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Classes and structures can provide their own implementations of existing operators."},{"type":"text","text":" "},{"type":"text","text":"This is known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"overloading"}]},{"type":"text","text":" the existing operators."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below shows how to implement"},{"type":"text","text":" "},{"type":"text","text":"the arithmetic addition operator ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") for a custom structure."},{"type":"text","text":" "},{"type":"text","text":"The arithmetic addition operator is a binary operator"},{"type":"text","text":" "},{"type":"text","text":"because it operates on two targets"},{"type":"text","text":" "},{"type":"text","text":"and it’s an infix operator because it appears between those two targets."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example defines a "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" structure for"},{"type":"text","text":" "},{"type":"text","text":"a two-dimensional position vector "},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"followed by a definition of an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operator method"}]},{"type":"text","text":" "},{"type":"text","text":"to add together instances of the "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" structure:"}]},{"type":"codeListing","syntax":"swift","code":["struct Vector2D {","   var x = 0.0, y = 0.0","}","","extension Vector2D {","    static func + (left: Vector2D, right: Vector2D) -> Vector2D {","       return Vector2D(x: left.x + right.x, y: left.y + right.y)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The operator method is defined as a type method on "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"with a method name that matches the operator to be overloaded ("},{"type":"codeVoice","code":"+"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"Because addition isn’t part of the essential behavior for a vector,"},{"type":"text","text":" "},{"type":"text","text":"the type method is defined in an extension of "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" "},{"type":"text","text":"rather than in the main structure declaration of "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Because the arithmetic addition operator is a binary operator,"},{"type":"text","text":" "},{"type":"text","text":"this operator method takes two input parameters of type "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" "},{"type":"text","text":"and returns a single output value, also of type "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this implementation, the input parameters are named "},{"type":"codeVoice","code":"left"},{"type":"text","text":" and "},{"type":"codeVoice","code":"right"},{"type":"text","text":" "},{"type":"text","text":"to represent the "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances that will be on"},{"type":"text","text":" "},{"type":"text","text":"the left side and right side of the "},{"type":"codeVoice","code":"+"},{"type":"text","text":" operator."},{"type":"text","text":" "},{"type":"text","text":"The method returns a new "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instance,"},{"type":"text","text":" "},{"type":"text","text":"whose "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":" properties are"},{"type":"text","text":" "},{"type":"text","text":"initialized with the sum of the "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":" properties from"},{"type":"text","text":" "},{"type":"text","text":"the two "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances that are added together."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The type method"},{"type":"text","text":" "},{"type":"text","text":"can be used as an infix operator between existing "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances:"}]},{"type":"codeListing","syntax":"swift","code":["let vector = Vector2D(x: 3.0, y: 1.0)","let anotherVector = Vector2D(x: 2.0, y: 4.0)","let combinedVector = vector + anotherVector","\/\/ combinedVector is a Vector2D instance with values of (5.0, 5.0)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example adds together the vectors "},{"type":"codeVoice","code":"(3.0, 1.0)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"(2.0, 4.0)"},{"type":"text","text":" "},{"type":"text","text":"to make the vector "},{"type":"codeVoice","code":"(5.0, 5.0)"},{"type":"text","text":", as illustrated below."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"vectorAddition"}]},{"anchor":"Operadores-Prefixo-e-Pós-Fixo","level":3,"type":"heading","text":"Operadores Prefixo e Pós-Fixo"},{"type":"paragraph","inlineContent":[{"type":"text","text":"O Exemplo mostrado abaixo demonstra uma implementação customizada de um"},{"type":"text","text":" "},{"type":"text","text":"operador binário infíxo."},{"type":"text","text":" "},{"type":"text","text":"Classes e estruturas também podem prover implementações"},{"type":"text","text":" "},{"type":"text","text":"dos "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operadores unários"}]},{"type":"text","text":" padrões."},{"type":"text","text":" "},{"type":"text","text":"Operadores unários operam em um único alvo."},{"type":"text","text":" "},{"type":"text","text":"Eles são "},{"type":"emphasis","inlineContent":[{"type":"text","text":"prefixos"}]},{"type":"text","text":" se precedem seu alvo (assim como "},{"type":"codeVoice","code":"-a"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"e "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pós-fixos"}]},{"type":"text","text":" os que sucedem o seu alvo (assim como "},{"type":"codeVoice","code":"b!"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Implementa-se um operador unário prefixo ou pós-fixo por escrever o modificador "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":" ou "},{"type":"codeVoice","code":"postfix"},{"type":"text","text":" "},{"type":"text","text":"antes da palavra-chave "},{"type":"codeVoice","code":"func"},{"type":"text","text":" quando se declara um método de operador:"}]},{"type":"codeListing","syntax":"swift","code":["extension Vector2D {","    static prefix func - (vector: Vector2D) -> Vector2D {","        return Vector2D(x: -vector.x, y: -vector.y)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O exemplo acima implementa o operador unário menos ("},{"type":"codeVoice","code":"-a"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"para intâncias "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"O operador unário menos é um operador prefixo,"},{"type":"text","text":" "},{"type":"text","text":"então esse método deve ser arguido com o modificador "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Para valores numéricos simples, o operador unário menos converte números positivos em seus equivalentes negativos e vice-versa."},{"type":"text","text":" "},{"type":"text","text":"A implementação correspondente para instâncias "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Vector2D"}]},{"type":"text","text":" performam essa operação em ambas propriedades "},{"type":"codeVoice","code":"x"},{"type":"text","text":" e "},{"type":"codeVoice","code":"y"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["let positive = Vector2D(x: 3.0, y: 4.0)","let negative = -positive","\/\/ negative is a Vector2D instance with values of (-3.0, -4.0)","let alsoPositive = -negative","\/\/ alsoPositive is a Vector2D instance with values of (3.0, 4.0)"]},{"anchor":"Operadores-de-Atribuição-Composta","level":3,"type":"heading","text":"Operadores de Atribuição Composta"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Operadores de atribuição composta"}]},{"type":"text","text":" combinam atribuição (’=’) com outra operação."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, o operador de atribuição de adição (’+=’)"},{"type":"text","text":" "},{"type":"text","text":"combina adição e atribuição em uma única operação"},{"type":"text","text":" "},{"type":"text","text":"Você marca o tipo de parâmetro de entrada esquerdo de um operador de atribuição composto como ‘inout’,"},{"type":"text","text":" "},{"type":"text","text":"pois o valor do parâmetro será modificado diretamente de dentro do método o operador."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O exemplo abaixo implementa"},{"type":"text","text":" "},{"type":"text","text":"um operador de atribuição de adição para instâncias ‘Vector2D’:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"‘’’swift"},{"type":"text","text":" "},{"type":"text","text":"extension Vector2D {"},{"type":"text","text":" "},{"type":"text","text":"static func += (left: inout Vector2D, right: Vector2D) {"},{"type":"text","text":" "},{"type":"text","text":"left = left + right"},{"type":"text","text":" "},{"type":"text","text":"}"},{"type":"text","text":" "},{"type":"text","text":"}"},{"type":"text","text":" "},{"type":"text","text":"‘’’"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Como um operador de adição foi definido anteriormente,"},{"type":"text","text":" "},{"type":"text","text":"você não precisa reimplementar o processo de adição aqui."},{"type":"text","text":" "},{"type":"text","text":"Nesse caso, o método do operador de atribuição de adição"},{"type":"text","text":" "},{"type":"text","text":"aproveita do método de operador de adição existente,"},{"type":"text","text":" "},{"type":"text","text":"e o uso para definir o valor esquerdo como o valor esquerdo somado ao valor direito:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"‘’’swift"},{"type":"text","text":" "},{"type":"text","text":"var original = Vector2D(x: 1.0, y: 2.0)"},{"type":"text","text":" "},{"type":"text","text":"let vectorToAdd = Vector2D(x: 3.0, y: 4.0)"},{"type":"text","text":" "},{"type":"text","text":"original += vectorToAdd"},{"type":"text","text":" "},{"type":"text","text":"\/\/ agora, original tem os valores de (4.0, 6.0)"},{"type":"text","text":" "},{"type":"text","text":"‘’’"}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Não é possível sobrecarregar o padrão"},{"type":"text","text":" "},{"type":"text","text":"operador de atribuição (‘=‘)"},{"type":"text","text":" "},{"type":"text","text":"Somente os operadores de tribuição compostos podem ser sobrecarregados."},{"type":"text","text":" "},{"type":"text","text":"Igualmente, o operador condicional ternário"},{"type":"text","text":" "},{"type":"text","text":"(‘a ? b : c’) não podem ser sobrecarregados."}]}],"type":"aside","name":"Nota"},{"anchor":"Operadores-de-Equivalência","level":3,"type":"heading","text":"Operadores de Equivalência"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Por padrão , classes customizadas e structures não possuem uma implementação dos "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operadores de equivalência"}]},{"type":"text","text":", conhecidos como os operadores "},{"type":"emphasis","inlineContent":[{"type":"text","text":"igual a"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"=="},{"type":"text","text":") e "},{"type":"emphasis","inlineContent":[{"type":"text","text":"diferente de"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"!="},{"type":"text","text":"). Normalmente se implementa o operador "},{"type":"codeVoice","code":"=="},{"type":"text","text":" e se usa a implementação padrão do operador ("},{"type":"codeVoice","code":"!="},{"type":"text","text":") da biblioteca padrão que nega o resultado do operador "},{"type":"codeVoice","code":"=="},{"type":"text","text":". Existem duas maneiras de se implementar o operador "},{"type":"codeVoice","code":"=="},{"type":"text","text":": Você pode implementar por conta própria ou, em muitos casos, você pode pedir ao Swift para que sintetize a implementação por você. Em ambos os casos, você adiciona conformidade ao protocolo "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" da biblioteca padrão."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Você pode fornecer a implementação do operador "},{"type":"codeVoice","code":"=="},{"type":"text","text":" da mesma maneira que implementa outros operadores infixos:"}]},{"type":"codeListing","syntax":"swift","code":["extension Vector2D: Equatable {","    static func == (left: Vector2D, right: Vector2D) -> Bool {","       return (left.x == right.x) && (left.y == right.y)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"O exemplo acima implementa um operador "},{"type":"codeVoice","code":"=="},{"type":"text","text":" para verificar se duas instancias de "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" tem valores equivalentes. No contexto de "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":", faz sentido considerar que “igual” significa que “ambas as instâncias tem os mesmos valores de "},{"type":"codeVoice","code":"x"},{"type":"text","text":" e "},{"type":"codeVoice","code":"y"},{"type":"text","text":"”, sendo essa a lógica usada pela implementação  do operador."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Agora você pode usar esse operador para verificar se duas instâncias de "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" são equivalentes:"}]},{"type":"codeListing","syntax":"swift","code":["let twoThree = Vector2D(x: 2.0, y: 3.0)","let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)","if twoThree == anotherTwoThree {","   print(\"These two vectors are equivalent.\")","}","\/\/ Prints \"These two vectors are equivalent.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Em muitos casos simples, você pode pedir que o Swift sintetize a implementação dos operadores de equivalência , como descrito em "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation"},{"type":"text","text":"."}]},{"anchor":"Custom-Operators","level":2,"type":"heading","text":"Custom Operators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can declare and implement your own "},{"type":"emphasis","inlineContent":[{"type":"text","text":"custom operators"}]},{"type":"text","text":" in addition to"},{"type":"text","text":" "},{"type":"text","text":"the standard operators provided by Swift."},{"type":"text","text":" "},{"type":"text","text":"For a list of characters that can be used to define custom operators,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure#Operators"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"New operators are declared at a global level using the "},{"type":"codeVoice","code":"operator"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"and are marked with the "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":", "},{"type":"codeVoice","code":"infix"},{"type":"text","text":" or "},{"type":"codeVoice","code":"postfix"},{"type":"text","text":" modifiers:"}]},{"type":"codeListing","syntax":"swift","code":["prefix operator +++"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above defines a new prefix operator called "},{"type":"codeVoice","code":"+++"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This operator doesn’t have an existing meaning in Swift,"},{"type":"text","text":" "},{"type":"text","text":"and so it’s given its own custom meaning below in the specific context of"},{"type":"text","text":" "},{"type":"text","text":"working with "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances. For the purposes of this example,"},{"type":"text","text":" "},{"type":"codeVoice","code":"+++"},{"type":"text","text":" is treated as a new “prefix doubling” operator."},{"type":"text","text":" "},{"type":"text","text":"It doubles the "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":" values of a "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instance,"},{"type":"text","text":" "},{"type":"text","text":"by adding the vector to itself with the addition assignment operator defined earlier."},{"type":"text","text":" "},{"type":"text","text":"To implement the "},{"type":"codeVoice","code":"+++"},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"you add a type method called "},{"type":"codeVoice","code":"+++"},{"type":"text","text":" to "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" as follows:"}]},{"type":"codeListing","syntax":"swift","code":["extension Vector2D {","   static prefix func +++ (vector: inout Vector2D) -> Vector2D {","      vector += vector","      return vector","   }","}","","var toBeDoubled = Vector2D(x: 1.0, y: 4.0)","let afterDoubling = +++toBeDoubled","\/\/ toBeDoubled now has values of (2.0, 8.0)","\/\/ afterDoubling also has values of (2.0, 8.0)"]},{"anchor":"Precedence-for-Custom-Infix-Operators","level":3,"type":"heading","text":"Precedence for Custom Infix Operators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Custom infix operators each belong to a precedence group."},{"type":"text","text":" "},{"type":"text","text":"A precedence group specifies an operator’s precedence relative"},{"type":"text","text":" "},{"type":"text","text":"to other infix operators, as well as the operator’s associativity."},{"type":"text","text":" "},{"type":"text","text":"See "},{"type":"text","text":"doc:AdvancedOperators#Precedence-and-Associativity"},{"type":"text","text":" for an explanation of"},{"type":"text","text":" "},{"type":"text","text":"how these characteristics affect an infix operator’s interaction"},{"type":"text","text":" "},{"type":"text","text":"with other infix operators."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A custom infix operator that isn’t explicitly placed into a precedence group is"},{"type":"text","text":" "},{"type":"text","text":"given a default precedence group with a precedence immediately higher"},{"type":"text","text":" "},{"type":"text","text":"than the precedence of the ternary conditional operator."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example defines a new custom infix operator called "},{"type":"codeVoice","code":"+-"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which belongs to the precedence group "},{"type":"codeVoice","code":"AdditionPrecedence"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["infix operator +-: AdditionPrecedence","extension Vector2D {","   static func +- (left: Vector2D, right: Vector2D) -> Vector2D {","      return Vector2D(x: left.x + right.x, y: left.y - right.y)","   }","}","let firstVector = Vector2D(x: 1.0, y: 2.0)","let secondVector = Vector2D(x: 3.0, y: 4.0)","let plusMinusVector = firstVector +- secondVector","\/\/ plusMinusVector is a Vector2D instance with values of (4.0, -2.0)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This operator adds together the "},{"type":"codeVoice","code":"x"},{"type":"text","text":" values of two vectors,"},{"type":"text","text":" "},{"type":"text","text":"and subtracts the "},{"type":"codeVoice","code":"y"},{"type":"text","text":" value of the second vector from the first."},{"type":"text","text":" "},{"type":"text","text":"Because it’s in essence an “additive” operator,"},{"type":"text","text":" "},{"type":"text","text":"it has been given the same precedence group"},{"type":"text","text":" "},{"type":"text","text":"as additive infix operators such as "},{"type":"codeVoice","code":"+"},{"type":"text","text":" and "},{"type":"codeVoice","code":"-"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"including a complete list of the operator precedence groups and associativity settings,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"overridingTitleInlineContent":[{"type":"text","text":"Operator Declarations"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","overridingTitle":"Operator Declarations"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For more information about precedence groups and to see the syntax for"},{"type":"text","text":" "},{"type":"text","text":"defining your own operators and precedence groups,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Operator-Declaration"},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You don’t specify a precedence when defining a prefix or postfix operator."},{"type":"text","text":" "},{"type":"text","text":"However, if you apply both a prefix and a postfix operator to the same operand,"},{"type":"text","text":" "},{"type":"text","text":"the postfix operator is applied first."}]}],"type":"aside","name":"Note"},{"anchor":"Result-Builders","level":2,"type":"heading","text":"Result Builders"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"result builder"}]},{"type":"text","text":" is a type you define"},{"type":"text","text":" "},{"type":"text","text":"that adds syntax for creating nested data,"},{"type":"text","text":" "},{"type":"text","text":"like a list or tree,"},{"type":"text","text":" "},{"type":"text","text":"in a natural, declarative way."},{"type":"text","text":" "},{"type":"text","text":"The code that uses the result builder"},{"type":"text","text":" "},{"type":"text","text":"can include ordinary Swift syntax, like "},{"type":"codeVoice","code":"if"},{"type":"text","text":"  and "},{"type":"codeVoice","code":"for"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"to handle conditional or repeated pieces of data."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code below defines a few types for drawing on a single line"},{"type":"text","text":" "},{"type":"text","text":"using stars and text."}]},{"type":"codeListing","syntax":"swift","code":["protocol Drawable {","    func draw() -> String","}","struct Line: Drawable {","    var elements: [Drawable]","    func draw() -> String {","        return elements.map { $0.draw() }.joined(separator: \"\")","    }","}","struct Text: Drawable {","    var content: String","    init(_ content: String) { self.content = content }","    func draw() -> String { return content }","}","struct Space: Drawable {","    func draw() -> String { return \" \" }","}","struct Stars: Drawable {","    var length: Int","    func draw() -> String { return String(repeating: \"*\", count: length) }","}","struct AllCaps: Drawable {","    var content: Drawable","    func draw() -> String { return content.draw().uppercased() }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Drawable"},{"type":"text","text":" protocol defines the requirement"},{"type":"text","text":" "},{"type":"text","text":"for something that can be drawn, like a line or shape:"},{"type":"text","text":" "},{"type":"text","text":"The type must implement a "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Line"},{"type":"text","text":" structure represents a single-line drawing,"},{"type":"text","text":" "},{"type":"text","text":"and it serves the top-level container for most drawings."},{"type":"text","text":" "},{"type":"text","text":"To draw a "},{"type":"codeVoice","code":"Line"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the structure calls "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" on each of the line’s components,"},{"type":"text","text":" "},{"type":"text","text":"and then concatenates the resulting strings into a single string."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Text"},{"type":"text","text":" structure wraps a string to make it part of a drawing."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"AllCaps"},{"type":"text","text":" structure wraps and modifies another drawing,"},{"type":"text","text":" "},{"type":"text","text":"converting any text in the drawing to uppercase."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s possible to make a drawing with these types"},{"type":"text","text":" "},{"type":"text","text":"by calling their initializers:"}]},{"type":"codeListing","syntax":"swift","code":["let name: String? = \"Ravi Patel\"","let manualDrawing = Line(elements: [","     Stars(length: 3),","     Text(\"Hello\"),","     Space(),","     AllCaps(content: Text((name ?? \"World\") + \"!\")),","     Stars(length: 2),","])","print(manualDrawing.draw())","\/\/ Prints \"***Hello RAVI PATEL!**\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This code works, but it’s a little awkward."},{"type":"text","text":" "},{"type":"text","text":"The deeply nested parentheses after "},{"type":"codeVoice","code":"AllCaps"},{"type":"text","text":" are hard to read."},{"type":"text","text":" "},{"type":"text","text":"The fallback logic to use “World” when "},{"type":"codeVoice","code":"name"},{"type":"text","text":" is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" "},{"type":"text","text":"has to be done inline using the "},{"type":"codeVoice","code":"??"},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"which would be difficult with anything more complex."},{"type":"text","text":" "},{"type":"text","text":"If you needed to include switches or "},{"type":"codeVoice","code":"for"},{"type":"text","text":" loops"},{"type":"text","text":" "},{"type":"text","text":"to build up part of the drawing, there’s no way to do that."},{"type":"text","text":" "},{"type":"text","text":"A result builder lets you rewrite code like this"},{"type":"text","text":" "},{"type":"text","text":"so that it looks like normal Swift code."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To define a result builder,"},{"type":"text","text":" "},{"type":"text","text":"you write the "},{"type":"codeVoice","code":"@resultBuilder"},{"type":"text","text":" attribute on a type declaration."},{"type":"text","text":" "},{"type":"text","text":"For example, this code defines a result builder called "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which lets you use a declarative syntax to describe a drawing:"}]},{"type":"codeListing","syntax":"swift","code":["@resultBuilder","struct DrawingBuilder {","    static func buildBlock(_ components: Drawable...) -> Drawable {","        return Line(elements: components)","    }","    static func buildEither(first: Drawable) -> Drawable {","        return first","    }","    static func buildEither(second: Drawable) -> Drawable {","        return second","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":" structure defines three methods"},{"type":"text","text":" "},{"type":"text","text":"that implement parts of the result builder syntax."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"buildBlock(_:)"},{"type":"text","text":" method adds support for"},{"type":"text","text":" "},{"type":"text","text":"writing a series of lines in a block of code."},{"type":"text","text":" "},{"type":"text","text":"It combines the components in that block into a "},{"type":"codeVoice","code":"Line"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"buildEither(first:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"buildEither(second:)"},{"type":"text","text":" methods"},{"type":"text","text":" "},{"type":"text","text":"add support for "},{"type":"codeVoice","code":"if"},{"type":"text","text":"-"},{"type":"codeVoice","code":"else"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can apply the "},{"type":"codeVoice","code":"@DrawingBuilder"},{"type":"text","text":" attribute to a function’s parameter,"},{"type":"text","text":" "},{"type":"text","text":"which turns a closure passed to the function"},{"type":"text","text":" "},{"type":"text","text":"into the value that the result builder creates from that closure."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["func draw(@DrawingBuilder content: () -> Drawable) -> Drawable {","    return content()","}","func caps(@DrawingBuilder content: () -> Drawable) -> Drawable {","    return AllCaps(content: content())","}","","func makeGreeting(for name: String? = nil) -> Drawable {","    let greeting = draw {","        Stars(length: 3)","        Text(\"Hello\")","        Space()","        caps {","            if let name = name {","                Text(name + \"!\")","            } else {","                Text(\"World!\")","            }","        }","        Stars(length: 2)","    }","    return greeting","}","let genericGreeting = makeGreeting()","print(genericGreeting.draw())","\/\/ Prints \"***Hello WORLD!**\"","","let personalGreeting = makeGreeting(for: \"Ravi Patel\")","print(personalGreeting.draw())","\/\/ Prints \"***Hello RAVI PATEL!**\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeGreeting(for:)"},{"type":"text","text":" function takes a "},{"type":"codeVoice","code":"name"},{"type":"text","text":" parameter"},{"type":"text","text":" "},{"type":"text","text":"and uses it to draw a personalized greeting."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"draw(_:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"caps(_:)"},{"type":"text","text":" functions"},{"type":"text","text":" "},{"type":"text","text":"both take a single closure as their argument,"},{"type":"text","text":" "},{"type":"text","text":"which is marked with the "},{"type":"codeVoice","code":"@DrawingBuilder"},{"type":"text","text":" attribute."},{"type":"text","text":" "},{"type":"text","text":"When you call those functions,"},{"type":"text","text":" "},{"type":"text","text":"you use the special syntax that "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":" defines."},{"type":"text","text":" "},{"type":"text","text":"Swift transforms that declarative description of a drawing"},{"type":"text","text":" "},{"type":"text","text":"into a series of calls to the methods on "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":" "},{"type":"text","text":"to build up the value that’s passed as the function argument."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift transforms the call to "},{"type":"codeVoice","code":"caps(_:)"},{"type":"text","text":" in that example"},{"type":"text","text":" "},{"type":"text","text":"into code like the following:"}]},{"type":"codeListing","syntax":"swift","code":["let capsDrawing = caps {","    let partialDrawing: Drawable","    if let name = name {","        let text = Text(name + \"!\")","        partialDrawing = DrawingBuilder.buildEither(first: text)","    } else {","        let text = Text(\"World!\")","        partialDrawing = DrawingBuilder.buildEither(second: text)","    }","    return partialDrawing","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift transforms the "},{"type":"codeVoice","code":"if"},{"type":"text","text":"-"},{"type":"codeVoice","code":"else"},{"type":"text","text":" block into"},{"type":"text","text":" "},{"type":"text","text":"calls to the "},{"type":"codeVoice","code":"buildEither(first:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"buildEither(second:)"},{"type":"text","text":" methods."},{"type":"text","text":" "},{"type":"text","text":"Although you don’t call these methods in your own code,"},{"type":"text","text":" "},{"type":"text","text":"showing the result of the transformation"},{"type":"text","text":" "},{"type":"text","text":"makes it easier to see how Swift transforms your code"},{"type":"text","text":" "},{"type":"text","text":"when you use the "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":" syntax."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To add support for writing "},{"type":"codeVoice","code":"for"},{"type":"text","text":" loops in the special drawing syntax,"},{"type":"text","text":" "},{"type":"text","text":"add a "},{"type":"codeVoice","code":"buildArray(_:)"},{"type":"text","text":" method."}]},{"type":"codeListing","syntax":"swift","code":["extension DrawingBuilder {","    static func buildArray(_ components: [Drawable]) -> Drawable {","        return Line(elements: components)","    }","}","let manyStars = draw {","    Text(\"Stars:\")","    for length in 1...3 {","        Space()","        Stars(length: length)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above, the "},{"type":"codeVoice","code":"for"},{"type":"text","text":" loop creates an array of drawings,"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"buildArray(_:)"},{"type":"text","text":" method turns that array into a "},{"type":"codeVoice","code":"Line"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For a complete list of how Swift transforms builder syntax"},{"type":"text","text":" "},{"type":"text","text":"into calls to the builder type’s methods,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes#resultBuilder"},{"type":"text","text":"."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/advancedoperators"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Além dos operadores descritos no tópico "},{"type":"text","text":"doc:OperadoresBasicos"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"a linguagem Swift oferece o tópico Operadores Avançados que fazem manipulação de valores mais complexa."},{"type":"text","text":" "},{"type":"text","text":"Lá são incluídos operadores bit a bit e operadores com deslocamento que estamos familiarizados em C e Objective-C."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Operadores Avançados","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Guide","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl"],"generated":true}],"references":{"bitwiseOR":{"alt":null,"type":"image","identifier":"bitwiseOR","variants":[{"url":"\/images\/bitwiseOR@2x.png","traits":["2x","light"]},{"url":"\/images\/bitwiseOR~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/NestedTypes":{"role":"article","title":"Tipos Aninhados","abstract":[{"type":"text","text":"Enumerações são frequentemente criadas para dar suporte a uma funcionalidade especifica de uma classe ou estrutura."},{"type":"text","text":" "},{"type":"text","text":"Similarmente, pode ser conveniente definir classes e estruturas de utilidade"},{"type":"text","text":" "},{"type":"text","text":"puramente para o uso dentro de um contexto de um tipo mais complexo."},{"type":"text","text":" "},{"type":"text","text":"Para fazer isso, o Swift permite que você defina "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos aninhados"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"nos quais você aninha enumerações, classes e estruturas de suporte"},{"type":"text","text":" "},{"type":"text","text":"dentro da definição do tipo que elas suportam."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/nestedtypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures":{"role":"article","title":"Estruturas e Classes","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Estruturas"}]},{"type":"text","text":" e "},{"type":"emphasis","inlineContent":[{"type":"text","text":"classes"}]},{"type":"text","text":" são construções flexíveis de propósito geral que se tornam os blocos de construção do código do seu programa. Você define propriedades e métodos para adicionar funcionalidade às suas estruturas e classes usando a mesma sintaxe usada para definir constantes, variáveis e funções."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/classesandstructures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow":{"role":"article","title":"Control Flow","abstract":[{"type":"text","text":"Swift provides a variety of control flow statements."},{"type":"text","text":" "},{"type":"text","text":"These include "},{"type":"codeVoice","code":"while"},{"type":"text","text":" loops to perform a task multiple times;"},{"type":"text","text":" "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", and "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statements"},{"type":"text","text":" "},{"type":"text","text":"to execute different branches of code based on certain conditions;"},{"type":"text","text":" "},{"type":"text","text":"and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" "},{"type":"text","text":"to transfer the flow of execution to another point in your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/controlflow"},"bitshiftSignedMinusFour":{"alt":null,"type":"image","identifier":"bitshiftSignedMinusFour","variants":[{"url":"\/images\/bitshiftSignedMinusFour@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftSignedMinusFour~dark@2x.png","traits":["2x","dark"]}]},"bitshiftSignedFour":{"alt":null,"type":"image","identifier":"bitshiftSignedFour","variants":[{"url":"\/images\/bitshiftSignedFour@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftSignedFour~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/StringsAndCharacters":{"role":"article","title":"Strings e Characters","abstract":[{"type":"text","text":"Uma "},{"type":"emphasis","inlineContent":[{"type":"text","text":"string"}]},{"type":"text","text":" é uma série de caracteres,"},{"type":"text","text":" "},{"type":"text","text":"tal como "},{"type":"codeVoice","code":"\"olá, mundo\""},{"type":"text","text":" ou "},{"type":"codeVoice","code":"\"albatroz\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Strings em Swift são representadas pelo tipo "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"O conteúdo de uma "},{"type":"codeVoice","code":"String"},{"type":"text","text":" pode ser acessado de várias maneiras,"},{"type":"text","text":" "},{"type":"text","text":"incluindo como uma coleção de valores "},{"type":"codeVoice","code":"Character"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/stringsandcharacters"},"https://developer.apple.com/documentation/swift/operator_declarations":{"title":"Operator Declarations","titleInlineContent":[{"type":"text","text":"Operator Declarations"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","url":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"},"bitwiseAND":{"alt":null,"type":"image","identifier":"bitwiseAND","variants":[{"url":"\/images\/bitwiseAND@2x.png","traits":["2x","light"]},{"url":"\/images\/bitwiseAND~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes":{"role":"article","title":"Tipos de Coleção","abstract":[{"type":"text","text":"Swift oferece três "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos de coleção"}]},{"type":"text","text":" primários, conhecidos como arrays, sets e dicionários, para armazenar coleções de valores. Arrays são coleções ordenadas de valores. Sets são coleções não ordenadas de valores únicos. Os dicionários são coleções não ordenadas de associações chave-valor."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/collectiontypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Enumerations":{"role":"article","title":"Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values"},{"type":"text","text":" "},{"type":"text","text":"and enables you to work with those values in a type-safe way within your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/enumerations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OptionalChaining":{"role":"article","title":"Optional Chaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling"},{"type":"text","text":" "},{"type":"text","text":"properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the optional contains a value,"},{"type":"text","text":" "},{"type":"text","text":"the property, method, or subscript call succeeds;"},{"type":"text","text":" "},{"type":"text","text":"if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Multiple queries can be chained together,"},{"type":"text","text":" "},{"type":"text","text":"and the entire chain fails gracefully if any link in the chain is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/optionalchaining"},"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures":{"role":"article","title":"Closures","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closures"}]},{"type":"text","text":" are self-contained blocks of functionality"},{"type":"text","text":" "},{"type":"text","text":"that can be passed around and used in your code."},{"type":"text","text":" "},{"type":"text","text":"Closures in Swift are similar to blocks in C and Objective-C"},{"type":"text","text":" "},{"type":"text","text":"and to lambdas in other programming languages."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/closures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"role":"article","title":"Type Casting","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance,"},{"type":"text","text":" "},{"type":"text","text":"or to treat that instance as a different"},{"type":"text","text":" "},{"type":"text","text":"superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes":{"role":"article","title":"Opaque Types","abstract":[{"type":"text","text":"A function or method with an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"type":"text","text":"Instead of providing a concrete type as the function’s return type,"},{"type":"text","text":" "},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"type":"text","text":"Hiding type information"},{"type":"text","text":" "},{"type":"text","text":"is useful at boundaries between"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"type":"text","text":" "},{"type":"text","text":"because the underlying type of the return value can remain private."},{"type":"text","text":" "},{"type":"text","text":"Unlike returning a value whose type is a protocol type,"},{"type":"text","text":" "},{"type":"text","text":"opaque types preserve type identity —"},{"type":"text","text":" "},{"type":"text","text":"the compiler has access to the type information,"},{"type":"text","text":" "},{"type":"text","text":"but clients of the module don’t."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/opaquetypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Deinitialization":{"role":"article","title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"deinitializer"}]},{"type":"text","text":" is called immediately before a class instance is deallocated."},{"type":"text","text":" "},{"type":"text","text":"You write deinitializers with the "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"similar to how initializers are written with the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"Deinitializers are only available on class types."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/deinitialization"},"bitshiftSigned":{"alt":null,"type":"image","identifier":"bitshiftSigned","variants":[{"url":"\/images\/bitshiftSigned@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftSigned~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"role":"article","title":"Error Handling","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Error handling"}]},{"type":"text","text":" is the process of responding to"},{"type":"text","text":" "},{"type":"text","text":"and recovering from error conditions in your program."},{"type":"text","text":" "},{"type":"text","text":"Swift provides first-class support for"},{"type":"text","text":" "},{"type":"text","text":"throwing, catching, propagating, and manipulating"},{"type":"text","text":" "},{"type":"text","text":"recoverable errors at runtime."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/errorhandling"},"vectorAddition":{"alt":null,"type":"image","identifier":"vectorAddition","variants":[{"url":"\/images\/vectorAddition@2x.png","traits":["2x","light"]},{"url":"\/images\/vectorAddition~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AccessControl":{"role":"article","title":"Access Control","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"type":"text","text":" restricts access to parts of your code"},{"type":"text","text":" "},{"type":"text","text":"from code in other source files and modules."},{"type":"text","text":" "},{"type":"text","text":"This feature enables you to hide the implementation details of your code,"},{"type":"text","text":" "},{"type":"text","text":"and to specify a preferred interface through which that code can be accessed and used."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/accesscontrol"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"role":"article","title":"Operadores básicos","abstract":[{"type":"text","text":"Um operador é um símbolo ou frase que você pode usar para verificar, mudar ou combinar valores."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, o operador de adição ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") soma dois números,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"e o operador lógico E ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"AND"}]},{"type":"text","text":" - "},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combina dois valores booleanos,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/basicoperators"},"overflowAddition":{"alt":null,"type":"image","identifier":"overflowAddition","variants":[{"url":"\/images\/overflowAddition@2x.png","traits":["2x","light"]},{"url":"\/images\/overflowAddition~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"role":"article","title":"Generics","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types"},{"type":"text","text":" "},{"type":"text","text":"that can work with any type, subject to requirements that you define."},{"type":"text","text":" "},{"type":"text","text":"You can write code that avoids duplication"},{"type":"text","text":" "},{"type":"text","text":"and expresses its intent in a clear, abstracted manner."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Subscripts":{"role":"article","title":"Subscripts","abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscripts"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which are shortcuts for accessing the member elements of a collection, list, or sequence."},{"type":"text","text":" "},{"type":"text","text":"You use subscripts to set and retrieve values by index without needing"},{"type":"text","text":" "},{"type":"text","text":"separate methods for setting and retrieval."},{"type":"text","text":" "},{"type":"text","text":"For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" "},{"type":"text","text":"and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/subscripts"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation":{"abstract":[],"title":"Adopting a Protocol Using a Synthesized Implementation","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation","url":"\/documentation\/the-swift-programming-language\/protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols":{"role":"article","title":"Protocols","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol"}]},{"type":"text","text":" defines a blueprint of"},{"type":"text","text":" "},{"type":"text","text":"methods, properties, and other requirements"},{"type":"text","text":" "},{"type":"text","text":"that suit a particular task or piece of functionality."},{"type":"text","text":" "},{"type":"text","text":"The protocol can then be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"adopted"}]},{"type":"text","text":" by a class, structure, or enumeration"},{"type":"text","text":" "},{"type":"text","text":"to provide an actual implementation of those requirements."},{"type":"text","text":" "},{"type":"text","text":"Any type that satisfies the requirements of a protocol is said to"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conform"}]},{"type":"text","text":" to that protocol."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/protocols"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization":{"role":"article","title":"Initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"type":"text","text":" is the process of preparing an instance of"},{"type":"text","text":" "},{"type":"text","text":"a class, structure, or enumeration for use."},{"type":"text","text":" "},{"type":"text","text":"This process involves setting an initial value for each stored property on that instance"},{"type":"text","text":" "},{"type":"text","text":"and performing any other setup or initialization that’s required"},{"type":"text","text":" "},{"type":"text","text":"before the new instance is ready for use."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes#resultBuilder":{"abstract":[],"title":"resultBuilder","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes#resultBuilder","url":"\/documentation\/the-swift-programming-language\/attributes#resultBuilder"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Methods":{"role":"article","title":"Methods","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Methods"}]},{"type":"text","text":" are functions that are associated with a particular type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can all define instance methods,"},{"type":"text","text":" "},{"type":"text","text":"which encapsulate specific tasks and functionality for working with an instance of a given type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can also define type methods,"},{"type":"text","text":" "},{"type":"text","text":"which are associated with the type itself."},{"type":"text","text":" "},{"type":"text","text":"Type methods are similar to class methods in Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/methods"},"bitwiseXOR":{"alt":null,"type":"image","identifier":"bitwiseXOR","variants":[{"url":"\/images\/bitwiseXOR@2x.png","traits":["2x","light"]},{"url":"\/images\/bitwiseXOR~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting":{"role":"article","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"type":"text","text":" (ARC)"},{"type":"text","text":" "},{"type":"text","text":"to track and manage your app’s memory usage."},{"type":"text","text":" "},{"type":"text","text":"In most cases, this means that memory management “just works” in Swift,"},{"type":"text","text":" "},{"type":"text","text":"and you don’t need to think about memory management yourself."},{"type":"text","text":" "},{"type":"text","text":"ARC automatically frees up the memory used by class instances"},{"type":"text","text":" "},{"type":"text","text":"when those instances are no longer needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting"},"bitshiftUnsigned":{"alt":null,"type":"image","identifier":"bitshiftUnsigned","variants":[{"url":"\/images\/bitshiftUnsigned@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftUnsigned~dark@2x.png","traits":["2x","dark"]}]},"bitwiseNOT":{"alt":null,"type":"image","identifier":"bitwiseNOT","variants":[{"url":"\/images\/bitwiseNOT@2x.png","traits":["2x","light"]},{"url":"\/images\/bitwiseNOT~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Extensions":{"role":"article","title":"Extensões","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensões"}]},{"type":"text","text":" adicionam novas funcionalidades a uma classe, estrutura, enumeração ou tipo de protocolo existente. Isso inclui a capacidade de estender tipos para os quais você não tem acesso ao código-fonte original (conhecido como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"modelagem retroativa"}]},{"type":"text","text":"). As extensões são semelhantes às categorias em Objective-C. (Ao contrário das categorias de Objective-C, as extensões Swift não têm nomes.)"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/extensions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency":{"role":"article","title":"Concorrência","abstract":[{"type":"text","text":"Swift tem suporte por padrão para escrita de código assíncrono e paralelo"},{"type":"text","text":" "},{"type":"text","text":"de forma estruturada."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código assíncrono"}]},{"type":"text","text":" pode ser suspenso e retomado posteriormente,"},{"type":"text","text":" "},{"type":"text","text":"embora apenas uma parte do programa seja executada por vez."},{"type":"text","text":" "},{"type":"text","text":"Suspender e retomar código em seu programa"},{"type":"text","text":" "},{"type":"text","text":"permite que ele continue a progredir"},{"type":"text","text":" "},{"type":"text","text":"em operações de curto prazo, como atualizar a interface do usuário,"},{"type":"text","text":" "},{"type":"text","text":"enquanto continua a trabalhar em operações de longa duração"},{"type":"text","text":" "},{"type":"text","text":"como buscar dados pela rede ou analisar arquivos."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código paralelo"}]},{"type":"text","text":" significa vários pedaços de código executando simultaneamente —"},{"type":"text","text":" "},{"type":"text","text":"por exemplo, um computador com um processador de quatro núcleos"},{"type":"text","text":" "},{"type":"text","text":"pode executar quatro pedaços de código ao mesmo tempo,"},{"type":"text","text":" "},{"type":"text","text":"com cada núcleo realizando uma das tarefas."},{"type":"text","text":" "},{"type":"text","text":"Um programa que usa código paralelo e assíncrono"},{"type":"text","text":" "},{"type":"text","text":"realiza várias operações ao mesmo tempo;"},{"type":"text","text":" "},{"type":"text","text":"suspende as operações que estão à espera de um sistema externo,"},{"type":"text","text":" "},{"type":"text","text":"e torna mais fácil escrever esse código de maneira segura para a memória ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"memory-safe"}]},{"type":"text","text":")."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/concurrency"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics":{"role":"article","title":"O Básico","abstract":[{"type":"text","text":"Swift é uma linguagem de programação para desenvolvimento de aplicativos iOS, macOS, watchOS e tvOS. Se você tem experiência em desenvolvimento em C ou Objective-C, muitas partes do Swift serão familiares para você."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/thebasics"},"overflowSignedSubtraction":{"alt":null,"type":"image","identifier":"overflowSignedSubtraction","variants":[{"url":"\/images\/overflowSignedSubtraction@2x.png","traits":["2x","light"]},{"url":"\/images\/overflowSignedSubtraction~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance":{"role":"article","title":"Inheritance","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"type":"text","text":" methods, properties, and other characteristics"},{"type":"text","text":" "},{"type":"text","text":"from another class."},{"type":"text","text":" "},{"type":"text","text":"When one class inherits from another,"},{"type":"text","text":" "},{"type":"text","text":"the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Inheritance is a fundamental behavior that differentiates classes"},{"type":"text","text":" "},{"type":"text","text":"from other types in Swift."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/inheritance"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/MemorySafety":{"role":"article","title":"Memory Safety","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift ensures that variables are initialized before they’re used,"},{"type":"text","text":" "},{"type":"text","text":"memory isn’t accessed after it’s been deallocated,"},{"type":"text","text":" "},{"type":"text","text":"and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/memorysafety"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"role":"article","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task."},{"type":"text","text":" "},{"type":"text","text":"You give a function a name that identifies what it does,"},{"type":"text","text":" "},{"type":"text","text":"and this name is used to “call” the function to perform its task when needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Operator-Declaration":{"abstract":[],"title":"Operator Declaration","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Operator-Declaration","url":"\/documentation\/the-swift-programming-language\/declarations#Operator-Declaration"},"overflowUnsignedSubtraction":{"alt":null,"type":"image","identifier":"overflowUnsignedSubtraction","variants":[{"url":"\/images\/overflowUnsignedSubtraction@2x.png","traits":["2x","light"]},{"url":"\/images\/overflowUnsignedSubtraction~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Properties":{"role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Properties"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration."},{"type":"text","text":" "},{"type":"text","text":"Stored properties store constant and variable values as part of an instance,"},{"type":"text","text":" "},{"type":"text","text":"whereas computed properties calculate (rather than store) a value."},{"type":"text","text":" "},{"type":"text","text":"Computed properties are provided by classes, structures, and enumerations."},{"type":"text","text":" "},{"type":"text","text":"Stored properties are provided only by classes and structures."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/properties"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/LexicalStructure#Operators":{"abstract":[],"title":"Operators","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure#Operators","url":"\/documentation\/the-swift-programming-language\/lexicalstructure#Operators"},"bitshiftSignedAddition":{"alt":null,"type":"image","identifier":"bitshiftSignedAddition","variants":[{"url":"\/images\/bitshiftSignedAddition@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftSignedAddition~dark@2x.png","traits":["2x","dark"]}]},"bitshiftSignedMinusFourValue":{"alt":null,"type":"image","identifier":"bitshiftSignedMinusFourValue","variants":[{"url":"\/images\/bitshiftSignedMinusFourValue@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftSignedMinusFourValue~dark@2x.png","traits":["2x","dark"]}]}}}