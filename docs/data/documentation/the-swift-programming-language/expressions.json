{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Prefix and infix expressions let you"},{"type":"text","text":" "},{"type":"text","text":"apply operators to smaller expressions."},{"type":"text","text":" "},{"type":"text","text":"Primary expressions are conceptually the simplest kind of expression,"},{"type":"text","text":" "},{"type":"text","text":"and they provide a way to access values."},{"type":"text","text":" "},{"type":"text","text":"Postfix expressions,"},{"type":"text","text":" "},{"type":"text","text":"like prefix and infix expressions,"},{"type":"text","text":" "},{"type":"text","text":"let you build up more complex expressions"},{"type":"text","text":" "},{"type":"text","text":"using postfixes such as function calls and member access."},{"type":"text","text":" "},{"type":"text","text":"Each kind of expression is described in detail"},{"type":"text","text":" "},{"type":"text","text":"in the sections below."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an expression","","expression --> try-operator-OPT await-operator-OPT prefix-expression infix-expressions-OPT","expression-list --> expression | expression ``,`` expression-list"]},{"anchor":"Prefix-Expressions","level":2,"type":"heading","text":"Prefix Expressions"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Prefix expressions"}]},{"type":"text","text":" combine"},{"type":"text","text":" "},{"type":"text","text":"an optional prefix operator with an expression."},{"type":"text","text":" "},{"type":"text","text":"Prefix operators take one argument,"},{"type":"text","text":" "},{"type":"text","text":"the expression that follows them."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the behavior of these operators,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a prefix expression","","prefix-expression --> prefix-operator-OPT postfix-expression","prefix-expression --> in-out-expression"]},{"anchor":"Expressão-In-Out","level":3,"type":"heading","text":"Expressão In-Out"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Uma "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expressão "},{"type":"emphasis","inlineContent":[{"type":"text","text":"in-out"}]}]},{"type":"text","text":" marca uma variável"},{"type":"text","text":" "},{"type":"text","text":"que está sendo passada"},{"type":"text","text":" "},{"type":"text","text":"como um argumento "},{"type":"emphasis","inlineContent":[{"type":"text","text":"in-out"}]},{"type":"text","text":" para uma expressão de chamada de função."}]},{"type":"codeListing","syntax":"markdown","code":["&<#expression#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Para mais informações sobre parâmetros "},{"type":"emphasis","inlineContent":[{"type":"text","text":"in-out"}]},{"type":"text","text":" e para ver um exemplo,"},{"type":"text","text":" "},{"type":"text","text":"veja "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Expressões "},{"type":"emphasis","inlineContent":[{"type":"text","text":"in-out"}]},{"type":"text","text":" também são usadas"},{"type":"text","text":" "},{"type":"text","text":"quando se provê um argumento que não é um ponteiro"},{"type":"text","text":" "},{"type":"text","text":"em um contexto onde um ponteiro é necessário,"},{"type":"text","text":" "},{"type":"text","text":"como descrito em "},{"type":"text","text":"doc:Expressions#Implicit-Conversion-to-a-Pointer-Type"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Gramática de uma expressão _in-out_","","in-out-expression --> ``&`` identifier"]},{"anchor":"Try-Operator","level":3,"type":"heading","text":"Try Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"try expression"}]},{"type":"text","text":" consists of the "},{"type":"codeVoice","code":"try"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"followed by an expression that can throw an error."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["try <#expression#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of a "},{"type":"codeVoice","code":"try"},{"type":"text","text":" expression is the value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-try expression"}]},{"type":"text","text":" consists of the "},{"type":"codeVoice","code":"try?"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"followed by an expression that can throw an error."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["try? <#expression#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" doesn’t throw an error,"},{"type":"text","text":" "},{"type":"text","text":"the value of the optional-try expression"},{"type":"text","text":" "},{"type":"text","text":"is an optional containing the value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Otherwise, the value of the optional-try expression is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"forced-try expression"}]},{"type":"text","text":" consists of the "},{"type":"codeVoice","code":"try!"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"followed by an expression that can throw an error."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["try! <#expression#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of a forced-try expression is the value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" throws an error,"},{"type":"text","text":" "},{"type":"text","text":"a runtime error is produced."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the expression on the left-hand side of an infix operator"},{"type":"text","text":" "},{"type":"text","text":"is marked with "},{"type":"codeVoice","code":"try"},{"type":"text","text":", "},{"type":"codeVoice","code":"try?"},{"type":"text","text":", or "},{"type":"codeVoice","code":"try!"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"that operator applies to the whole infix expression."},{"type":"text","text":" "},{"type":"text","text":"That said, you can use parentheses to be explicit about the scope of the operator’s application."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ try applies to both function calls","sum = try someThrowingFunction() + anotherThrowingFunction()","","\/\/ try applies to both function calls","sum = try (someThrowingFunction() + anotherThrowingFunction())","","\/\/ Error: try applies only to the first function call","sum = (try someThrowingFunction()) + anotherThrowingFunction()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"try"},{"type":"text","text":" expression can’t appear on the right-hand side of an infix operator,"},{"type":"text","text":" "},{"type":"text","text":"unless the infix operator is the assignment operator"},{"type":"text","text":" "},{"type":"text","text":"or the "},{"type":"codeVoice","code":"try"},{"type":"text","text":" expression is enclosed in parentheses."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If an expression includes both the "},{"type":"codeVoice","code":"try"},{"type":"text","text":" and "},{"type":"codeVoice","code":"await"},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"try"},{"type":"text","text":" operator must appear first."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information and to see examples of how to use "},{"type":"codeVoice","code":"try"},{"type":"text","text":", "},{"type":"codeVoice","code":"try?"},{"type":"text","text":", and "},{"type":"codeVoice","code":"try!"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a try expression","","try-operator --> ``try`` | ``try`` ``?`` | ``try`` ``!``"]},{"anchor":"Await-Operator","level":3,"type":"heading","text":"Await Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"await expression"}]},{"type":"text","text":" consists of the "},{"type":"codeVoice","code":"await"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"followed by an expression that uses the result of an asynchronous operation."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["await <#expression#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of an "},{"type":"codeVoice","code":"await"},{"type":"text","text":" expression is the value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An expression marked with "},{"type":"codeVoice","code":"await"},{"type":"text","text":" is called a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"potential suspension point"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Execution of an asynchronous function can be suspended"},{"type":"text","text":" "},{"type":"text","text":"at each expression that’s marked with "},{"type":"codeVoice","code":"await"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"In addition,"},{"type":"text","text":" "},{"type":"text","text":"execution of concurrent code is never suspended at any other point."},{"type":"text","text":" "},{"type":"text","text":"This means code between potential suspension points"},{"type":"text","text":" "},{"type":"text","text":"can safely update state that requires temporarily breaking invariants,"},{"type":"text","text":" "},{"type":"text","text":"provided that it completes the update"},{"type":"text","text":" "},{"type":"text","text":"before the next potential suspension point."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"codeVoice","code":"await"},{"type":"text","text":" expression can appear only within an asynchronous context,"},{"type":"text","text":" "},{"type":"text","text":"such as the trailing closure passed to the "},{"type":"codeVoice","code":"async(priority:operation:)"},{"type":"text","text":" function."},{"type":"text","text":" "},{"type":"text","text":"It can’t appear in the body of a "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" statement,"},{"type":"text","text":" "},{"type":"text","text":"or in an autoclosure of synchronous function type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the expression on the left-hand side of an infix operator"},{"type":"text","text":" "},{"type":"text","text":"is marked with the "},{"type":"codeVoice","code":"await"},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"that operator applies to the whole infix expression."},{"type":"text","text":" "},{"type":"text","text":"That said, you can use parentheses"},{"type":"text","text":" "},{"type":"text","text":"to be explicit about the scope of the operator’s application."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ await applies to both function calls","sum = await someAsyncFunction() + anotherAsyncFunction()","","\/\/ await applies to both function calls","sum = await (someAsyncFunction() + anotherAsyncFunction())","","\/\/ Error: await applies only to the first function call","sum = (await someAsyncFunction()) + anotherAsyncFunction()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"codeVoice","code":"await"},{"type":"text","text":" expression can’t appear on the right-hand side of an infix operator,"},{"type":"text","text":" "},{"type":"text","text":"unless the infix operator is the assignment operator"},{"type":"text","text":" "},{"type":"text","text":"or the "},{"type":"codeVoice","code":"await"},{"type":"text","text":" expression is enclosed in parentheses."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If an expression includes both the "},{"type":"codeVoice","code":"await"},{"type":"text","text":" and "},{"type":"codeVoice","code":"try"},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"try"},{"type":"text","text":" operator must appear first."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an await expression","","await-operator --> ``await``"]},{"anchor":"Infix-Expressions","level":2,"type":"heading","text":"Infix Expressions"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Infix expressions"}]},{"type":"text","text":" combine"},{"type":"text","text":" "},{"type":"text","text":"an infix binary operator with the expression that it takes"},{"type":"text","text":" "},{"type":"text","text":"as its left- and right-hand arguments."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#left-hand argument#> <#operator#> <#right-hand argument#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the behavior of these operators,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"overridingTitleInlineContent":[{"type":"text","text":"Operator Declarations"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","overridingTitle":"Operator Declarations"},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"At parse time,"},{"type":"text","text":" "},{"type":"text","text":"an expression made up of infix operators is represented"},{"type":"text","text":" "},{"type":"text","text":"as a flat list."},{"type":"text","text":" "},{"type":"text","text":"This list is transformed into a tree"},{"type":"text","text":" "},{"type":"text","text":"by applying operator precedence."},{"type":"text","text":" "},{"type":"text","text":"For example, the expression "},{"type":"codeVoice","code":"2 + 3 * 5"},{"type":"text","text":" "},{"type":"text","text":"is initially understood as a flat list of five items,"},{"type":"text","text":" "},{"type":"codeVoice","code":"2"},{"type":"text","text":", "},{"type":"codeVoice","code":"+"},{"type":"text","text":", "},{"type":"codeVoice","code":"3"},{"type":"text","text":", "},{"type":"codeVoice","code":"*"},{"type":"text","text":", and "},{"type":"codeVoice","code":"5"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This process transforms it into the tree (2 + (3 * 5))."}]}],"type":"aside","name":"Note"},{"type":"codeListing","syntax":"markdown","code":["Grammar of an infix expression","","infix-expression --> infix-operator prefix-expression","infix-expression --> assignment-operator try-operator-OPT prefix-expression","infix-expression --> conditional-operator try-operator-OPT prefix-expression","infix-expression --> type-casting-operator","infix-expressions --> infix-expression infix-expressions-OPT"]},{"anchor":"Assignment-Operator","level":3,"type":"heading","text":"Assignment Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"assignment operator"}]},{"type":"text","text":" sets a new value"},{"type":"text","text":" "},{"type":"text","text":"for a given expression."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#expression#> = <#value#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"type":"text","text":"is set to the value obtained by evaluating the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"value"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" is a tuple,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"value"}]},{"type":"text","text":" must be a tuple"},{"type":"text","text":" "},{"type":"text","text":"with the same number of elements."},{"type":"text","text":" "},{"type":"text","text":"(Nested tuples are allowed.)"},{"type":"text","text":" "},{"type":"text","text":"Assignment is performed from each part of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"value"}]},{"type":"text","text":" "},{"type":"text","text":"to the corresponding part of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["(a, _, (b, c)) = (\"test\", 9.45, (12, 3))","\/\/ a is \"test\", b is 12, c is 3, and 9.45 is ignored"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The assignment operator doesn’t return any value."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an assignment operator","","assignment-operator --> ``=``"]},{"anchor":"Ternary-Conditional-Operator","level":3,"type":"heading","text":"Ternary Conditional Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"ternary conditional operator"}]},{"type":"text","text":" evaluates to one of two given values"},{"type":"text","text":" "},{"type":"text","text":"based on the value of a condition."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#condition#> ? <#expression used if true#> : <#expression used if false#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"condition"}]},{"type":"text","text":" evaluates to "},{"type":"codeVoice","code":"true"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the conditional operator evaluates the first expression"},{"type":"text","text":" "},{"type":"text","text":"and returns its value."},{"type":"text","text":" "},{"type":"text","text":"Otherwise, it evaluates the second expression"},{"type":"text","text":" "},{"type":"text","text":"and returns its value."},{"type":"text","text":" "},{"type":"text","text":"The unused expression isn’t evaluated."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For an example that uses the ternary conditional operator,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"text","text":"doc:BasicOperators#Ternary-Conditional-Operator"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a conditional operator","","conditional-operator --> ``?`` expression ``:``"]},{"anchor":"Type-Casting-Operators","level":3,"type":"heading","text":"Type-Casting Operators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are four type-casting operators:"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"is"},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"as"},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"as!"},{"type":"text","text":" operator."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"They have the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#expression#> is <#type#>","<#expression#> as <#type#>","<#expression#> as? <#type#>","<#expression#> as! <#type#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"is"},{"type":"text","text":" operator checks at runtime whether the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"type":"text","text":"can be cast to the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"It returns "},{"type":"codeVoice","code":"true"},{"type":"text","text":" if the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" can be cast to the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":";"},{"type":"text","text":" "},{"type":"text","text":"otherwise, it returns "},{"type":"codeVoice","code":"false"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as"},{"type":"text","text":" operator performs a cast"},{"type":"text","text":" "},{"type":"text","text":"when it’s known at compile time"},{"type":"text","text":" "},{"type":"text","text":"that the cast always succeeds,"},{"type":"text","text":" "},{"type":"text","text":"such as upcasting or bridging."},{"type":"text","text":" "},{"type":"text","text":"Upcasting lets you use an expression as an instance of its type’s supertype,"},{"type":"text","text":" "},{"type":"text","text":"without using an intermediate variable."},{"type":"text","text":" "},{"type":"text","text":"The following approaches are equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["func f(_ any: Any) { print(\"Function for Any\") }","func f(_ int: Int) { print(\"Function for Int\") }","let x = 10","f(x)","\/\/ Prints \"Function for Int\"","","let y: Any = x","f(y)","\/\/ Prints \"Function for Any\"","","f(x as Any)","\/\/ Prints \"Function for Any\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Bridging lets you use an expression of"},{"type":"text","text":" "},{"type":"text","text":"a Swift standard library type such as "},{"type":"codeVoice","code":"String"},{"type":"text","text":" "},{"type":"text","text":"as its corresponding Foundation type such as "},{"type":"codeVoice","code":"NSString"},{"type":"text","text":" "},{"type":"text","text":"without needing to create a new instance."},{"type":"text","text":" "},{"type":"text","text":"For more information on bridging,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/imported_c_and_objective_c_apis\/working_with_foundation_types"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"performs a conditional cast of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"type":"text","text":"to the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" operator returns an optional of the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"At runtime, if the cast succeeds,"},{"type":"text","text":" "},{"type":"text","text":"the value of "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" is wrapped in an optional and returned;"},{"type":"text","text":" "},{"type":"text","text":"otherwise, the value returned is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If casting to the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"text","text":"is guaranteed to fail or is guaranteed to succeed,"},{"type":"text","text":" "},{"type":"text","text":"a compile-time error is raised."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as!"},{"type":"text","text":" operator performs a forced cast of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" to the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"as!"},{"type":"text","text":" operator returns a value of the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":", not an optional type."},{"type":"text","text":" "},{"type":"text","text":"If the cast fails, a runtime error is raised."},{"type":"text","text":" "},{"type":"text","text":"The behavior of "},{"type":"codeVoice","code":"x as! T"},{"type":"text","text":" is the same as the behavior of "},{"type":"codeVoice","code":"(x as? T)!"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about type casting"},{"type":"text","text":" "},{"type":"text","text":"and to see examples that use the type-casting operators,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a type-casting operator","","type-casting-operator --> ``is`` type","type-casting-operator --> ``as`` type","type-casting-operator --> ``as`` ``?`` type","type-casting-operator --> ``as`` ``!`` type"]},{"anchor":"Primary-Expressions","level":2,"type":"heading","text":"Primary Expressions"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Primary expressions"}]},{"type":"text","text":" "},{"type":"text","text":"are the most basic kind of expression."},{"type":"text","text":" "},{"type":"text","text":"They can be used as expressions on their own,"},{"type":"text","text":" "},{"type":"text","text":"and they can be combined with other tokens"},{"type":"text","text":" "},{"type":"text","text":"to make prefix expressions, infix expressions, and postfix expressions."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a primary expression","","primary-expression --> identifier generic-argument-clause-OPT","primary-expression --> literal-expression","primary-expression --> self-expression","primary-expression --> superclass-expression","primary-expression --> closure-expression","primary-expression --> parenthesized-expression","primary-expression --> tuple-expression","primary-expression --> implicit-member-expression","primary-expression --> wildcard-expression","primary-expression --> key-path-expression","primary-expression --> selector-expression","primary-expression --> key-path-string-expression"]},{"anchor":"Literal-Expression","level":3,"type":"heading","text":"Literal Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"literal expression"}]},{"type":"text","text":" consists of"},{"type":"text","text":" "},{"type":"text","text":"either an ordinary literal (such as a string or a number),"},{"type":"text","text":" "},{"type":"text","text":"an array or dictionary literal,"},{"type":"text","text":" "},{"type":"text","text":"a playground literal,"},{"type":"text","text":" "},{"type":"text","text":"or one of the following special literals:"}]},{"type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Literal"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Type"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Value"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#file"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"String"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"The path to the file in which it appears."}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#fileID"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"String"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"The name of the file and module in which it appears."}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#filePath"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"String"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"The path to the file in which it appears."}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#line"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Int"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"The line number on which it appears."}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#column"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Int"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"The column number in which it begins."}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#function"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"String"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"The name of the declaration in which it appears."}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#dsohandle"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"UnsafeRawPointer"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"The dynamic shared object (DSO) handle in use where it appears."}]}]]],"header":"row"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The string value of "},{"type":"codeVoice","code":"#file"},{"type":"text","text":" depends on the language version,"},{"type":"text","text":" "},{"type":"text","text":"to enable migration from the old "},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":" behavior"},{"type":"text","text":" "},{"type":"text","text":"to the new "},{"type":"codeVoice","code":"#fileID"},{"type":"text","text":" behavior."},{"type":"text","text":" "},{"type":"text","text":"Currently, "},{"type":"codeVoice","code":"#file"},{"type":"text","text":" has the same value as "},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"In a future version of Swift,"},{"type":"text","text":" "},{"type":"codeVoice","code":"#file"},{"type":"text","text":" will have the same value as "},{"type":"codeVoice","code":"#fileID"},{"type":"text","text":" instead."},{"type":"text","text":" "},{"type":"text","text":"To adopt the future behavior,"},{"type":"text","text":" "},{"type":"text","text":"replace "},{"type":"codeVoice","code":"#file"},{"type":"text","text":" with "},{"type":"codeVoice","code":"#fileID"},{"type":"text","text":" or "},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":" as appropriate."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The string value of a "},{"type":"codeVoice","code":"#fileID"},{"type":"text","text":" expression has the form "},{"type":"emphasis","inlineContent":[{"type":"text","text":"module"}]},{"type":"text","text":"\/"},{"type":"emphasis","inlineContent":[{"type":"text","text":"file"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"where "},{"type":"emphasis","inlineContent":[{"type":"text","text":"file"}]},{"type":"text","text":" is the name of the file in which the expression appears"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"emphasis","inlineContent":[{"type":"text","text":"module"}]},{"type":"text","text":" is the name of the module that this file is part of."},{"type":"text","text":" "},{"type":"text","text":"The string value of a "},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":" expression"},{"type":"text","text":" "},{"type":"text","text":"is the full file-system path to the file in which the expression appears."},{"type":"text","text":" "},{"type":"text","text":"Both of these values can be changed by "},{"type":"codeVoice","code":"#sourceLocation"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Statements#Line-Control-Statement"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Because "},{"type":"codeVoice","code":"#fileID"},{"type":"text","text":" doesn’t embed the full path to the source file,"},{"type":"text","text":" "},{"type":"text","text":"unlike "},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"it gives you better privacy and reduces the size of the compiled binary."},{"type":"text","text":" "},{"type":"text","text":"Avoid using "},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":" outside of tests, build scripts,"},{"type":"text","text":" "},{"type":"text","text":"or other code that doesn’t become part of the shipping program."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To parse a "},{"type":"codeVoice","code":"#fileID"},{"type":"text","text":" expression,"},{"type":"text","text":" "},{"type":"text","text":"read the module name as the text before the first slash ("},{"type":"codeVoice","code":"\/"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"and the filename as the text after the last slash."},{"type":"text","text":" "},{"type":"text","text":"In the future, the string might contain multiple slashes,"},{"type":"text","text":" "},{"type":"text","text":"such as "},{"type":"codeVoice","code":"MyModule\/some\/disambiguation\/MyFile.swift"},{"type":"text","text":"."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Inside a function,"},{"type":"text","text":" "},{"type":"text","text":"the value of "},{"type":"codeVoice","code":"#function"},{"type":"text","text":" is the name of that function,"},{"type":"text","text":" "},{"type":"text","text":"inside a method it’s the name of that method,"},{"type":"text","text":" "},{"type":"text","text":"inside a property getter or setter it’s the name of that property,"},{"type":"text","text":" "},{"type":"text","text":"inside special members like "},{"type":"codeVoice","code":"init"},{"type":"text","text":" or "},{"type":"codeVoice","code":"subscript"},{"type":"text","text":" "},{"type":"text","text":"it’s the name of that keyword,"},{"type":"text","text":" "},{"type":"text","text":"and at the top level of a file it’s the name of the current module."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When used as the default value of a function or method parameter,"},{"type":"text","text":" "},{"type":"text","text":"the special literal’s value is determined"},{"type":"text","text":" "},{"type":"text","text":"when the default value expression is evaluated at the call site."}]},{"type":"codeListing","syntax":"swift","code":["func logFunctionName(string: String = #function) {","    print(string)","}","func myFunction() {","   logFunctionName() \/\/ Prints \"myFunction()\".","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"array literal"}]},{"type":"text","text":" is"},{"type":"text","text":" "},{"type":"text","text":"an ordered collection of values."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["[<#value 1#>, <#value 2#>, <#...#>]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The last expression in the array can be followed by an optional comma."},{"type":"text","text":" "},{"type":"text","text":"The value of an array literal has type "},{"type":"codeVoice","code":"[T]"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"where "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is the type of the expressions inside it."},{"type":"text","text":" "},{"type":"text","text":"If there are expressions of multiple types,"},{"type":"text","text":" "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is their closest common supertype."},{"type":"text","text":" "},{"type":"text","text":"Empty array literals are written using an empty"},{"type":"text","text":" "},{"type":"text","text":"pair of square brackets and can be used to create an empty array of a specified type."}]},{"type":"codeListing","syntax":"swift","code":["var emptyArray: [Double] = []"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"dictionary literal"}]},{"type":"text","text":" is"},{"type":"text","text":" "},{"type":"text","text":"an unordered collection of key-value pairs."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["[<#key 1#>: <#value 1#>, <#key 2#>: <#value 2#>, <#...#>]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The last expression in the dictionary can be followed by an optional comma."},{"type":"text","text":" "},{"type":"text","text":"The value of a dictionary literal has type "},{"type":"codeVoice","code":"[Key: Value]"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"where "},{"type":"codeVoice","code":"Key"},{"type":"text","text":" is the type of its key expressions"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" is the type of its value expressions."},{"type":"text","text":" "},{"type":"text","text":"If there are expressions of multiple types,"},{"type":"text","text":" "},{"type":"codeVoice","code":"Key"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" are the closest common supertype"},{"type":"text","text":" "},{"type":"text","text":"for their respective values."},{"type":"text","text":" "},{"type":"text","text":"An empty dictionary literal is written as"},{"type":"text","text":" "},{"type":"text","text":"a colon inside a pair of brackets ("},{"type":"codeVoice","code":"[:]"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"to distinguish it from an empty array literal."},{"type":"text","text":" "},{"type":"text","text":"You can use an empty dictionary literal to create an empty dictionary literal"},{"type":"text","text":" "},{"type":"text","text":"of specified key and value types."}]},{"type":"codeListing","syntax":"swift","code":["var emptyDictionary: [String: Double] = [:]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"playground literal"}]},{"type":"text","text":" "},{"type":"text","text":"is used by Xcode to create an interactive representation"},{"type":"text","text":" "},{"type":"text","text":"of a color, file, or image within the program editor."},{"type":"text","text":" "},{"type":"text","text":"Playground literals in plain text outside of Xcode"},{"type":"text","text":" "},{"type":"text","text":"are represented using a special literal syntax."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information on using playground literals in Xcode,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev4c60242fc"},{"type":"text","text":" "},{"type":"text","text":"in Xcode Help."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a literal expression","","literal-expression --> literal","literal-expression --> array-literal | dictionary-literal | playground-literal","literal-expression --> ``#file`` | ``#fileID`` | ``#filePath``","literal-expression --> ``#line`` | ``#column`` | ``#function`` | ``#dsohandle``","","array-literal --> ``[`` array-literal-items-OPT ``]``","array-literal-items --> array-literal-item ``,``-OPT | array-literal-item ``,`` array-literal-items","array-literal-item --> expression","","dictionary-literal --> ``[`` dictionary-literal-items ``]`` | ``[`` ``:`` ``]``","dictionary-literal-items --> dictionary-literal-item ``,``-OPT | dictionary-literal-item ``,`` dictionary-literal-items","dictionary-literal-item --> expression ``:`` expression","","playground-literal --> ``#colorLiteral`` ``(`` ``red`` ``:`` expression ``,`` ``green`` ``:`` expression ``,`` ``blue`` ``:`` expression ``,`` ``alpha`` ``:`` expression ``)``","playground-literal --> ``#fileLiteral`` ``(`` ``resourceName`` ``:`` expression ``)``","playground-literal --> ``#imageLiteral`` ``(`` ``resourceName`` ``:`` expression ``)``"]},{"anchor":"Self-Expression","level":3,"type":"heading","text":"Self Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"self"},{"type":"text","text":" expression is an explicit reference to the current type"},{"type":"text","text":" "},{"type":"text","text":"or instance of the type in which it occurs."},{"type":"text","text":" "},{"type":"text","text":"It has the following forms:"}]},{"type":"codeListing","syntax":"markdown","code":["self","self.<#member name#>","self[<#subscript index#>]","self(<#initializer arguments#>)","self.init(<#initializer arguments#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In an initializer, subscript, or instance method, "},{"type":"codeVoice","code":"self"},{"type":"text","text":" refers to the current"},{"type":"text","text":" "},{"type":"text","text":"instance of the type in which it occurs. In a type method,"},{"type":"text","text":" "},{"type":"codeVoice","code":"self"},{"type":"text","text":" refers to the current type in which it occurs."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"self"},{"type":"text","text":" expression is used to specify scope when accessing members,"},{"type":"text","text":" "},{"type":"text","text":"providing disambiguation when there’s"},{"type":"text","text":" "},{"type":"text","text":"another variable of the same name in scope,"},{"type":"text","text":" "},{"type":"text","text":"such as a function parameter."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass {","    var greeting: String","    init(greeting: String) {","        self.greeting = greeting","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In a mutating method of a value type,"},{"type":"text","text":" "},{"type":"text","text":"you can assign a new instance of that value type to "},{"type":"codeVoice","code":"self"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["struct Point {","   var x = 0.0, y = 0.0","   mutating func moveBy(x deltaX: Double, y deltaY: Double) {","      self = Point(x: x + deltaX, y: y + deltaY)","   }","}"]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a self expression","","self-expression -->  ``self`` | self-method-expression | self-subscript-expression | self-initializer-expression","","self-method-expression --> ``self`` ``.`` identifier","self-subscript-expression --> ``self`` ``[`` function-call-argument-list ``]``","self-initializer-expression --> ``self`` ``.`` ``init``"]},{"anchor":"Superclass-Expression","level":3,"type":"heading","text":"Superclass Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass expression"}]},{"type":"text","text":" lets a class"},{"type":"text","text":" "},{"type":"text","text":"interact with its superclass."},{"type":"text","text":" "},{"type":"text","text":"It has one of the following forms:"}]},{"type":"codeListing","syntax":"markdown","code":["super.<#member name#>","super[<#subscript index#>]","super.init(<#initializer arguments#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The first form is used to access a member of the superclass."},{"type":"text","text":" "},{"type":"text","text":"The second form is used to access the superclass’s subscript implementation."},{"type":"text","text":" "},{"type":"text","text":"The third form is used to access an initializer of the superclass."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Subclasses can use a superclass expression"},{"type":"text","text":" "},{"type":"text","text":"in their implementation of members, subscripting, and initializers"},{"type":"text","text":" "},{"type":"text","text":"to make use of the implementation in their superclass."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a superclass expression","","superclass-expression --> superclass-method-expression | superclass-subscript-expression | superclass-initializer-expression","","superclass-method-expression --> ``super`` ``.`` identifier","superclass-subscript-expression --> ``super`` ``[`` function-call-argument-list ``]``","superclass-initializer-expression --> ``super`` ``.`` ``init``"]},{"anchor":"Closure-Expression","level":3,"type":"heading","text":"Closure Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure expression"}]},{"type":"text","text":" creates a closure,"},{"type":"text","text":" "},{"type":"text","text":"also known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"lambda"}]},{"type":"text","text":" or an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"anonymous function"}]},{"type":"text","text":" "},{"type":"text","text":"in other programming languages."},{"type":"text","text":" "},{"type":"text","text":"Like a function declaration,"},{"type":"text","text":" "},{"type":"text","text":"a closure contains statements,"},{"type":"text","text":" "},{"type":"text","text":"and it captures constants and variables from its enclosing scope."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["{ (<#parameters#>) -> <#return type#> in","   <#statements#>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"parameters"}]},{"type":"text","text":" have the same form"},{"type":"text","text":" "},{"type":"text","text":"as the parameters in a function declaration,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Function-Declaration"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Writing "},{"type":"codeVoice","code":"throws"},{"type":"text","text":" or "},{"type":"codeVoice","code":"async"},{"type":"text","text":" in a closure expression"},{"type":"text","text":" "},{"type":"text","text":"explicitly marks a closure as throwing or asynchronous."}]},{"type":"codeListing","syntax":"markdown","code":["{ (<#parameters#>) async throws -> <#return type#> in","   <#statements#>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the body of a closure includes a try expression,"},{"type":"text","text":" "},{"type":"text","text":"the closure is understood to be throwing."},{"type":"text","text":" "},{"type":"text","text":"Likewise, if it includes an await expression,"},{"type":"text","text":" "},{"type":"text","text":"it’s understood to be asynchronous."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are several special forms"},{"type":"text","text":" "},{"type":"text","text":"that allow closures to be written more concisely:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure can omit the types"},{"type":"text","text":" "},{"type":"text","text":"of its parameters, its return type, or both."},{"type":"text","text":" "},{"type":"text","text":"If you omit the parameter names and both types,"},{"type":"text","text":" "},{"type":"text","text":"omit the "},{"type":"codeVoice","code":"in"},{"type":"text","text":" keyword before the statements."},{"type":"text","text":" "},{"type":"text","text":"If the omitted types can’t be inferred,"},{"type":"text","text":" "},{"type":"text","text":"a compile-time error is raised."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure may omit names for its parameters."},{"type":"text","text":" "},{"type":"text","text":"Its parameters are then implicitly named"},{"type":"text","text":" "},{"type":"codeVoice","code":"$"},{"type":"text","text":" followed by their position:"},{"type":"text","text":" "},{"type":"codeVoice","code":"$0"},{"type":"text","text":", "},{"type":"codeVoice","code":"$1"},{"type":"text","text":", "},{"type":"codeVoice","code":"$2"},{"type":"text","text":", and so on."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure that consists of only a single expression"},{"type":"text","text":" "},{"type":"text","text":"is understood to return the value of that expression."},{"type":"text","text":" "},{"type":"text","text":"The contents of this expression are also considered"},{"type":"text","text":" "},{"type":"text","text":"when performing type inference on the surrounding expression."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following closure expressions are equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["myFunction { (x: Int, y: Int) -> Int in","    return x + y","}","","myFunction { x, y in","    return x + y","}","","myFunction { return $0 + $1 }","","myFunction { $0 + $1 }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about passing a closure as an argument to a function,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Function-Call-Expression"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Closure expressions can be used"},{"type":"text","text":" "},{"type":"text","text":"without being stored in a variable or constant,"},{"type":"text","text":" "},{"type":"text","text":"such as when you immediately use a closure as part of a function call."},{"type":"text","text":" "},{"type":"text","text":"The closure expressions passed to "},{"type":"codeVoice","code":"myFunction"},{"type":"text","text":" in code above are"},{"type":"text","text":" "},{"type":"text","text":"examples of this kind of immediate use."},{"type":"text","text":" "},{"type":"text","text":"As a result,"},{"type":"text","text":" "},{"type":"text","text":"whether a closure expression is escaping or nonescaping depends"},{"type":"text","text":" "},{"type":"text","text":"on the surrounding context of the expression."},{"type":"text","text":" "},{"type":"text","text":"A closure expression is nonescaping"},{"type":"text","text":" "},{"type":"text","text":"if it’s called immediately"},{"type":"text","text":" "},{"type":"text","text":"or passed as a nonescaping function argument."},{"type":"text","text":" "},{"type":"text","text":"Otherwise, the closure expression is escaping."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about escaping closures, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Escaping-Closures"},{"type":"text","text":"."}]},{"anchor":"Capture-Lists","level":4,"type":"heading","text":"Capture Lists"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, a closure expression captures"},{"type":"text","text":" "},{"type":"text","text":"constants and variables from its surrounding scope"},{"type":"text","text":" "},{"type":"text","text":"with strong references to those values."},{"type":"text","text":" "},{"type":"text","text":"You can use a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture list"}]},{"type":"text","text":" to explicitly control"},{"type":"text","text":" "},{"type":"text","text":"how values are captured in a closure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A capture list is written as a comma-separated list of expressions"},{"type":"text","text":" "},{"type":"text","text":"surrounded by square brackets,"},{"type":"text","text":" "},{"type":"text","text":"before the list of parameters."},{"type":"text","text":" "},{"type":"text","text":"If you use a capture list, you must also use the "},{"type":"codeVoice","code":"in"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"even if you omit the parameter names, parameter types, and return type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The entries in the capture list are initialized"},{"type":"text","text":" "},{"type":"text","text":"when the closure is created."},{"type":"text","text":" "},{"type":"text","text":"For each entry in the capture list,"},{"type":"text","text":" "},{"type":"text","text":"a constant is initialized"},{"type":"text","text":" "},{"type":"text","text":"to the value of the constant or variable that has the same name"},{"type":"text","text":" "},{"type":"text","text":"in the surrounding scope."},{"type":"text","text":" "},{"type":"text","text":"For example in the code below,"},{"type":"text","text":" "},{"type":"codeVoice","code":"a"},{"type":"text","text":" is included in the capture list but "},{"type":"codeVoice","code":"b"},{"type":"text","text":" is not,"},{"type":"text","text":" "},{"type":"text","text":"which gives them different behavior."}]},{"type":"codeListing","syntax":"swift","code":["var a = 0","var b = 0","let closure = { [a] in"," print(a, b)","}","","a = 10","b = 10","closure()","\/\/ Prints \"0 10\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are two different things named "},{"type":"codeVoice","code":"a"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the variable in the surrounding scope"},{"type":"text","text":" "},{"type":"text","text":"and the constant in the closure’s scope,"},{"type":"text","text":" "},{"type":"text","text":"but only one variable named "},{"type":"codeVoice","code":"b"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"a"},{"type":"text","text":" in the inner scope is initialized"},{"type":"text","text":" "},{"type":"text","text":"with the value of the "},{"type":"codeVoice","code":"a"},{"type":"text","text":" in the outer scope"},{"type":"text","text":" "},{"type":"text","text":"when the closure is created,"},{"type":"text","text":" "},{"type":"text","text":"but their values aren’t connected in any special way."},{"type":"text","text":" "},{"type":"text","text":"This means that a change to the value of "},{"type":"codeVoice","code":"a"},{"type":"text","text":" in the outer scope"},{"type":"text","text":" "},{"type":"text","text":"doesn’t affect the value of "},{"type":"codeVoice","code":"a"},{"type":"text","text":" in the inner scope,"},{"type":"text","text":" "},{"type":"text","text":"nor does a change to "},{"type":"codeVoice","code":"a"},{"type":"text","text":" inside the closure"},{"type":"text","text":" "},{"type":"text","text":"affect the value of "},{"type":"codeVoice","code":"a"},{"type":"text","text":" outside the closure."},{"type":"text","text":" "},{"type":"text","text":"In contrast, there’s only one variable named "},{"type":"codeVoice","code":"b"},{"type":"text","text":" —"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"b"},{"type":"text","text":" in the outer scope —"},{"type":"text","text":" "},{"type":"text","text":"so changes from inside or outside the closure are visible in both places."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This distinction isn’t visible"},{"type":"text","text":" "},{"type":"text","text":"when the captured variable’s type has reference semantics."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"there are two things named "},{"type":"codeVoice","code":"x"},{"type":"text","text":" in the code below,"},{"type":"text","text":" "},{"type":"text","text":"a variable in the outer scope and a constant in the inner scope,"},{"type":"text","text":" "},{"type":"text","text":"but they both refer to the same object"},{"type":"text","text":" "},{"type":"text","text":"because of reference semantics."}]},{"type":"codeListing","syntax":"swift","code":["class SimpleClass {","    var value: Int = 0","}","var x = SimpleClass()","var y = SimpleClass()","let closure = { [x] in","    print(x.value, y.value)","}","","x.value = 10","y.value = 10","closure()","\/\/ Prints \"10 10\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the type of the expression’s value is a class,"},{"type":"text","text":" "},{"type":"text","text":"you can mark the expression in a capture list"},{"type":"text","text":" "},{"type":"text","text":"with "},{"type":"codeVoice","code":"weak"},{"type":"text","text":" or "},{"type":"codeVoice","code":"unowned"},{"type":"text","text":" to capture a weak or unowned reference"},{"type":"text","text":" "},{"type":"text","text":"to the expression’s value."}]},{"type":"codeListing","syntax":"swift","code":["myFunction { print(self.title) }                    \/\/ implicit strong capture","myFunction { [self] in print(self.title) }          \/\/ explicit strong capture","myFunction { [weak self] in print(self!.title) }    \/\/ weak capture","myFunction { [unowned self] in print(self.title) }  \/\/ unowned capture"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also bind an arbitrary expression"},{"type":"text","text":" "},{"type":"text","text":"to a named value in a capture list."},{"type":"text","text":" "},{"type":"text","text":"The expression is evaluated when the closure is created,"},{"type":"text","text":" "},{"type":"text","text":"and the value is captured with the specified strength."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Weak capture of \"self.parent\" as \"parent\"","myFunction { [weak parent = self.parent] in print(parent!.title) }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information and examples of closure expressions,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Closure-Expressions"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For more information and examples of capture lists,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-for-Closures"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a closure expression","","closure-expression --> ``{`` attributes-OPT closure-signature-OPT statements-OPT ``}``","","closure-signature --> capture-list-OPT closure-parameter-clause ``async``-OPT ``throws``-OPT function-result-OPT ``in``","closure-signature --> capture-list ``in``","","closure-parameter-clause --> ``(`` ``)`` | ``(`` closure-parameter-list ``)`` | identifier-list","closure-parameter-list --> closure-parameter | closure-parameter ``,`` closure-parameter-list","closure-parameter --> closure-parameter-name type-annotation-OPT","closure-parameter --> closure-parameter-name type-annotation ``...``","closure-parameter-name --> identifier","","capture-list --> ``[`` capture-list-items ``]``","capture-list-items --> capture-list-item | capture-list-item ``,`` capture-list-items","capture-list-item --> capture-specifier-OPT identifier","capture-list-item --> capture-specifier-OPT identifier ``=`` expression","capture-list-item --> capture-specifier-OPT self-expression","capture-specifier --> ``weak`` | ``unowned`` | ``unowned(safe)`` | ``unowned(unsafe)``"]},{"anchor":"Implicit-Member-Expression","level":3,"type":"heading","text":"Implicit Member Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"implicit member expression"}]},{"type":"text","text":" "},{"type":"text","text":"is an abbreviated way to access a member of a type,"},{"type":"text","text":" "},{"type":"text","text":"such as an enumeration case or a type method,"},{"type":"text","text":" "},{"type":"text","text":"in a context where type inference"},{"type":"text","text":" "},{"type":"text","text":"can determine the implied type."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":[".<#member name#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["var x = MyEnumeration.someValue","x = .anotherValue"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the inferred type is an optional,"},{"type":"text","text":" "},{"type":"text","text":"you can also use a member of the non-optional type"},{"type":"text","text":" "},{"type":"text","text":"in an implicit member expression."}]},{"type":"codeListing","syntax":"swift","code":["var someOptional: MyEnumeration? = .someValue"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Implicit member expressions can be followed by"},{"type":"text","text":" "},{"type":"text","text":"a postfix operator or other postfix syntax listed in"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Postfix-Expressions"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This is called a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"chained implicit member expression"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Although it’s common for all of the chained postfix expressions"},{"type":"text","text":" "},{"type":"text","text":"to have the same type,"},{"type":"text","text":" "},{"type":"text","text":"the only requirement is that the whole chained implicit member expression"},{"type":"text","text":" "},{"type":"text","text":"needs to be convertible to the type implied by its context."},{"type":"text","text":" "},{"type":"text","text":"Specifically,"},{"type":"text","text":" "},{"type":"text","text":"if the implied type is an optional"},{"type":"text","text":" "},{"type":"text","text":"you can use a value of the non-optional type,"},{"type":"text","text":" "},{"type":"text","text":"and if the implied type is a class type"},{"type":"text","text":" "},{"type":"text","text":"you can use a value of one of its subclasses."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass {","    static var shared = SomeClass()","    static var sharedSubclass = SomeSubclass()","    var a = AnotherClass()","}","class SomeSubclass: SomeClass { }","class AnotherClass {","    static var s = SomeClass()","    func f() -> SomeClass { return AnotherClass.s }","}","let x: SomeClass = .shared.a.f()","let y: SomeClass? = .shared","let z: SomeClass = .sharedSubclass"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above,"},{"type":"text","text":" "},{"type":"text","text":"the type of "},{"type":"codeVoice","code":"x"},{"type":"text","text":" matches the type implied by its context exactly,"},{"type":"text","text":" "},{"type":"text","text":"the type of "},{"type":"codeVoice","code":"y"},{"type":"text","text":" is convertible from "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" to "},{"type":"codeVoice","code":"SomeClass?"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the type of "},{"type":"codeVoice","code":"z"},{"type":"text","text":" is convertible from "},{"type":"codeVoice","code":"SomeSubclass"},{"type":"text","text":" to "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a implicit member expression","","implicit-member-expression --> ``.`` identifier","implicit-member-expression --> ``.`` identifier ``.`` postfix-expression"]},{"anchor":"Parenthesized-Expression","level":3,"type":"heading","text":"Parenthesized Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"parenthesized expression"}]},{"type":"text","text":" consists of"},{"type":"text","text":" "},{"type":"text","text":"an expression surrounded by parentheses."},{"type":"text","text":" "},{"type":"text","text":"You can use parentheses to specify the precedence of operations"},{"type":"text","text":" "},{"type":"text","text":"by explicitly grouping expressions."},{"type":"text","text":" "},{"type":"text","text":"Grouping parentheses don’t change an expression’s type —"},{"type":"text","text":" "},{"type":"text","text":"for example, the type of "},{"type":"codeVoice","code":"(1)"},{"type":"text","text":" is simply "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a parenthesized expression","","parenthesized-expression --> ``(`` expression ``)``"]},{"anchor":"Tuple-Expression","level":3,"type":"heading","text":"Tuple Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple expression"}]},{"type":"text","text":" consists of"},{"type":"text","text":" "},{"type":"text","text":"a comma-separated list of expressions surrounded by parentheses."},{"type":"text","text":" "},{"type":"text","text":"Each expression can have an optional identifier before it,"},{"type":"text","text":" "},{"type":"text","text":"separated by a colon ("},{"type":"codeVoice","code":":"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["(<#identifier 1#>: <#expression 1#>, <#identifier 2#>: <#expression 2#>, <#...#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each identifier in a tuple expression must be unique"},{"type":"text","text":" "},{"type":"text","text":"within the scope of the tuple expression."},{"type":"text","text":" "},{"type":"text","text":"In a nested tuple expression,"},{"type":"text","text":" "},{"type":"text","text":"identifiers at the same level of nesting must be unique."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"codeVoice","code":"(a: 10, a: 20)"},{"type":"text","text":" is invalid"},{"type":"text","text":" "},{"type":"text","text":"because the label "},{"type":"codeVoice","code":"a"},{"type":"text","text":" appears twice at the same level."},{"type":"text","text":" "},{"type":"text","text":"However, "},{"type":"codeVoice","code":"(a: 10, b: (a: 1, x: 2))"},{"type":"text","text":" is valid —"},{"type":"text","text":" "},{"type":"text","text":"although "},{"type":"codeVoice","code":"a"},{"type":"text","text":" appears twice,"},{"type":"text","text":" "},{"type":"text","text":"it appears once in the outer tuple and once in the inner tuple."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A tuple expression can contain zero expressions,"},{"type":"text","text":" "},{"type":"text","text":"or it can contain two or more expressions."},{"type":"text","text":" "},{"type":"text","text":"A single expression inside parentheses is a parenthesized expression."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Both an empty tuple expression and an empty tuple type"},{"type":"text","text":" "},{"type":"text","text":"are written "},{"type":"codeVoice","code":"()"},{"type":"text","text":" in Swift."},{"type":"text","text":" "},{"type":"text","text":"Because "},{"type":"codeVoice","code":"Void"},{"type":"text","text":" is a type alias for "},{"type":"codeVoice","code":"()"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"you can use it to write an empty tuple type."},{"type":"text","text":" "},{"type":"text","text":"However, like all type aliases, "},{"type":"codeVoice","code":"Void"},{"type":"text","text":" is always a type —"},{"type":"text","text":" "},{"type":"text","text":"you can’t use it to write an empty tuple expression."}]}],"type":"aside","name":"Note"},{"type":"codeListing","syntax":"markdown","code":["Grammar of a tuple expression","","tuple-expression --> ``(`` ``)`` | ``(`` tuple-element ``,`` tuple-element-list ``)``","tuple-element-list --> tuple-element | tuple-element ``,`` tuple-element-list","tuple-element --> expression | identifier ``:`` expression"]},{"anchor":"Wildcard-Expression","level":3,"type":"heading","text":"Wildcard Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Uma "},{"type":"emphasis","inlineContent":[{"type":"text","text":"wildcard expression"}]},{"type":"text","text":" "},{"type":"text","text":"é usada para ignorar explicitamente o valor durante uma atribuição."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, na seguinte atribuição,"},{"type":"text","text":" "},{"type":"text","text":"10 é atribuído a "},{"type":"codeVoice","code":"x"},{"type":"text","text":" e 20 é ignorado:"}]},{"type":"codeListing","syntax":"swift","code":["(x, _) = (10, 20)","\/\/ x é 10, e 20 é ignorado"]},{"type":"codeListing","syntax":"markdown","code":["Gramática de uma wildcard expression","","wildcard-expression --> ``_``"]},{"anchor":"Key-Path-Expression","level":3,"type":"heading","text":"Key-Path Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path expression"}]},{"type":"text","text":" "},{"type":"text","text":"refers to a property or subscript of a type."},{"type":"text","text":" "},{"type":"text","text":"You use key-path expressions"},{"type":"text","text":" "},{"type":"text","text":"in dynamic programming tasks,"},{"type":"text","text":" "},{"type":"text","text":"such as key-value observing."},{"type":"text","text":" "},{"type":"text","text":"They have the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["\\<#type name#>.<#path#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type name"}]},{"type":"text","text":" is the name of a concrete type,"},{"type":"text","text":" "},{"type":"text","text":"including any generic parameters,"},{"type":"text","text":" "},{"type":"text","text":"such as "},{"type":"codeVoice","code":"String"},{"type":"text","text":", "},{"type":"codeVoice","code":"[Int]"},{"type":"text","text":", or "},{"type":"codeVoice","code":"Set<Int>"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"path"}]},{"type":"text","text":" consists of"},{"type":"text","text":" "},{"type":"text","text":"property names, subscripts, optional-chaining expressions,"},{"type":"text","text":" "},{"type":"text","text":"and forced unwrapping expressions."},{"type":"text","text":" "},{"type":"text","text":"Each of these key-path components"},{"type":"text","text":" "},{"type":"text","text":"can be repeated as many times as needed,"},{"type":"text","text":" "},{"type":"text","text":"in any order."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"At compile time, a key-path expression"},{"type":"text","text":" "},{"type":"text","text":"is replaced by an instance"},{"type":"text","text":" "},{"type":"text","text":"of the "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/keypath"},{"type":"text","text":" class."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To access a value using a key path,"},{"type":"text","text":" "},{"type":"text","text":"pass the key path to the "},{"type":"codeVoice","code":"subscript(keyPath:)"},{"type":"text","text":" subscript,"},{"type":"text","text":" "},{"type":"text","text":"which is available on all types."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["struct SomeStructure {","    var someValue: Int","}","","let s = SomeStructure(someValue: 12)","let pathToProperty = \\SomeStructure.someValue","","let value = s[keyPath: pathToProperty]","\/\/ value is 12"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type name"}]},{"type":"text","text":" can be omitted"},{"type":"text","text":" "},{"type":"text","text":"in contexts where type inference"},{"type":"text","text":" "},{"type":"text","text":"can determine the implied type."},{"type":"text","text":" "},{"type":"text","text":"The following code uses "},{"type":"codeVoice","code":"\\.someProperty"},{"type":"text","text":" "},{"type":"text","text":"instead of "},{"type":"codeVoice","code":"\\SomeClass.someProperty"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass: NSObject {","    @objc dynamic var someProperty: Int","    init(someProperty: Int) {","        self.someProperty = someProperty","    }","}","","let c = SomeClass(someProperty: 10)","c.observe(\\.someProperty) { object, change in","    \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"path"}]},{"type":"text","text":" can refer to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" to create the identity key path ("},{"type":"codeVoice","code":"\\.self"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"The identity key path refers to a whole instance,"},{"type":"text","text":" "},{"type":"text","text":"so you can use it to access and change all of the data stored in a variable"},{"type":"text","text":" "},{"type":"text","text":"in a single step."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["var compoundValue = (a: 1, b: 2)","\/\/ Equivalent to compoundValue = (a: 10, b: 20)","compoundValue[keyPath: \\.self] = (a: 10, b: 20)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"path"}]},{"type":"text","text":" can contain multiple property names,"},{"type":"text","text":" "},{"type":"text","text":"separated by periods,"},{"type":"text","text":" "},{"type":"text","text":"to refer to a property of a property’s value."},{"type":"text","text":" "},{"type":"text","text":"This code uses the key path expression"},{"type":"text","text":" "},{"type":"codeVoice","code":"\\OuterStructure.outer.someValue"},{"type":"text","text":" "},{"type":"text","text":"to access the "},{"type":"codeVoice","code":"someValue"},{"type":"text","text":" property"},{"type":"text","text":" "},{"type":"text","text":"of the "},{"type":"codeVoice","code":"OuterStructure"},{"type":"text","text":" type’s "},{"type":"codeVoice","code":"outer"},{"type":"text","text":" property:"}]},{"type":"codeListing","syntax":"swift","code":["struct OuterStructure {","    var outer: SomeStructure","    init(someValue: Int) {","        self.outer = SomeStructure(someValue: someValue)","    }","}","","let nested = OuterStructure(someValue: 24)","let nestedKeyPath = \\OuterStructure.outer.someValue","","let nestedValue = nested[keyPath: nestedKeyPath]","\/\/ nestedValue is 24"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"path"}]},{"type":"text","text":" can include subscripts using brackets,"},{"type":"text","text":" "},{"type":"text","text":"as long as the subscript’s parameter type conforms to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"This example uses a subscript in a key path"},{"type":"text","text":" "},{"type":"text","text":"to access the second element of an array:"}]},{"type":"codeListing","syntax":"swift","code":["let greetings = [\"hello\", \"hola\", \"bonjour\", \"안녕\"]","let myGreeting = greetings[keyPath: \\[String].[1]]","\/\/ myGreeting is 'hola'"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value used in a subscript can be a named value or a literal."},{"type":"text","text":" "},{"type":"text","text":"Values are captured in key paths using value semantics."},{"type":"text","text":" "},{"type":"text","text":"The following code uses the variable "},{"type":"codeVoice","code":"index"},{"type":"text","text":" "},{"type":"text","text":"in both a key-path expression and in a closure to access"},{"type":"text","text":" "},{"type":"text","text":"the third element of the "},{"type":"codeVoice","code":"greetings"},{"type":"text","text":" array."},{"type":"text","text":" "},{"type":"text","text":"When "},{"type":"codeVoice","code":"index"},{"type":"text","text":" is modified,"},{"type":"text","text":" "},{"type":"text","text":"the key-path expression still references the third element,"},{"type":"text","text":" "},{"type":"text","text":"while the closure uses the new index."}]},{"type":"codeListing","syntax":"swift","code":["var index = 2","let path = \\[String].[index]","let fn: ([String]) -> String = { strings in strings[index] }","","print(greetings[keyPath: path])","\/\/ Prints \"bonjour\"","print(fn(greetings))","\/\/ Prints \"bonjour\"","","\/\/ Setting 'index' to a new value doesn't affect 'path'","index += 1","print(greetings[keyPath: path])","\/\/ Prints \"bonjour\"","","\/\/ Because 'fn' closes over 'index', it uses the new value","print(fn(greetings))","\/\/ Prints \"안녕\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"path"}]},{"type":"text","text":" can use optional chaining and forced unwrapping."},{"type":"text","text":" "},{"type":"text","text":"This code uses optional chaining in a key path"},{"type":"text","text":" "},{"type":"text","text":"to access a property of an optional string:"}]},{"type":"codeListing","syntax":"swift","code":["let firstGreeting: String? = greetings.first","print(firstGreeting?.count as Any)","\/\/ Prints \"Optional(5)\"","","\/\/ Do the same thing using a key path.","let count = greetings[keyPath: \\[String].first?.count]","print(count as Any)","\/\/ Prints \"Optional(5)\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can mix and match components of key paths to access values"},{"type":"text","text":" "},{"type":"text","text":"that are deeply nested within a type."},{"type":"text","text":" "},{"type":"text","text":"The following code accesses different values and properties"},{"type":"text","text":" "},{"type":"text","text":"of a dictionary of arrays"},{"type":"text","text":" "},{"type":"text","text":"by using key-path expressions"},{"type":"text","text":" "},{"type":"text","text":"that combine these components."}]},{"type":"codeListing","syntax":"swift","code":["let interestingNumbers = [\"prime\": [2, 3, 5, 7, 11, 13, 17],","                          \"triangular\": [1, 3, 6, 10, 15, 21, 28],","                          \"hexagonal\": [1, 6, 15, 28, 45, 66, 91]]","print(interestingNumbers[keyPath: \\[String: [Int]].[\"prime\"]] as Any)","\/\/ Prints \"Optional([2, 3, 5, 7, 11, 13, 17])\"","print(interestingNumbers[keyPath: \\[String: [Int]].[\"prime\"]![0]])","\/\/ Prints \"2\"","print(interestingNumbers[keyPath: \\[String: [Int]].[\"hexagonal\"]!.count])","\/\/ Prints \"7\"","print(interestingNumbers[keyPath: \\[String: [Int]].[\"hexagonal\"]!.count.bitWidth])","\/\/ Prints \"64\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use a key path expression"},{"type":"text","text":" "},{"type":"text","text":"in contexts where you would normally provide a function or closure."},{"type":"text","text":" "},{"type":"text","text":"Specifically,"},{"type":"text","text":" "},{"type":"text","text":"you can use a key path expression"},{"type":"text","text":" "},{"type":"text","text":"whose root type is "},{"type":"codeVoice","code":"SomeType"},{"type":"text","text":" "},{"type":"text","text":"and whose path produces a value of type "},{"type":"codeVoice","code":"Value"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"instead of a function or closure of type "},{"type":"codeVoice","code":"(SomeType) -> Value"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["struct Task {","    var description: String","    var completed: Bool","}","var toDoList = [","    Task(description: \"Practice ping-pong.\", completed: false),","    Task(description: \"Buy a pirate costume.\", completed: true),","    Task(description: \"Visit Boston in the Fall.\", completed: false),","]","","\/\/ Both approaches below are equivalent.","let descriptions = toDoList.filter(\\.completed).map(\\.description)","let descriptions2 = toDoList.filter { $0.completed }.map { $0.description }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any side effects of a key path expression"},{"type":"text","text":" "},{"type":"text","text":"are evaluated only at the point where the expression is evaluated."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"if you make a function call inside a subscript in a key path expression,"},{"type":"text","text":" "},{"type":"text","text":"the function is called only once as part of evaluating the expression,"},{"type":"text","text":" "},{"type":"text","text":"not every time the key path is used."}]},{"type":"codeListing","syntax":"swift","code":["func makeIndex() -> Int {","    print(\"Made an index\")","    return 0","}","\/\/ The line below calls makeIndex().","let taskKeyPath = \\[Task][makeIndex()]","\/\/ Prints \"Made an index\"","","\/\/ Using taskKeyPath doesn't call makeIndex() again.","let someTask = toDoList[keyPath: taskKeyPath]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about using key paths"},{"type":"text","text":" "},{"type":"text","text":"in code that interacts with Objective-C APIs,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For information about key-value coding and key-value observing,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a key-path expression","","key-path-expression --> ``\\`` type-OPT ``.`` key-path-components","key-path-components --> key-path-component | key-path-component ``.`` key-path-components","key-path-component --> identifier key-path-postfixes-OPT | key-path-postfixes","","key-path-postfixes --> key-path-postfix key-path-postfixes-OPT","key-path-postfix --> ``?`` | ``!`` | ``self`` | ``[`` function-call-argument-list ``]``"]},{"anchor":"Selector-Expression","level":3,"type":"heading","text":"Selector Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A selector expression lets you access the selector"},{"type":"text","text":" "},{"type":"text","text":"used to refer to a method or to a property’s"},{"type":"text","text":" "},{"type":"text","text":"getter or setter in Objective-C."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["#selector(<#method name#>)","#selector(getter: <#property name#>)","#selector(setter: <#property name#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"method name"}]},{"type":"text","text":" and "},{"type":"emphasis","inlineContent":[{"type":"text","text":"property name"}]},{"type":"text","text":" must be a reference to a method or a property"},{"type":"text","text":" "},{"type":"text","text":"that’s available in the Objective-C runtime."},{"type":"text","text":" "},{"type":"text","text":"The value of a selector expression is an instance of the "},{"type":"codeVoice","code":"Selector"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass: NSObject {","    @objc let property: String","","    @objc(doSomethingWithInt:)","    func doSomething(_ x: Int) { }","","    init(property: String) {","        self.property = property","    }","}","let selectorForMethod = #selector(SomeClass.doSomething(_:))","let selectorForPropertyGetter = #selector(getter: SomeClass.property)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When creating a selector for a property’s getter,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"property name"}]},{"type":"text","text":" can be a reference to a variable or constant property."},{"type":"text","text":" "},{"type":"text","text":"In contrast, when creating a selector for a property’s setter,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"property name"}]},{"type":"text","text":" must be a reference to a variable property only."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"method name"}]},{"type":"text","text":" can contain parentheses for grouping,"},{"type":"text","text":" "},{"type":"text","text":"as well the "},{"type":"codeVoice","code":"as"},{"type":"text","text":" operator to disambiguate between methods that share a name"},{"type":"text","text":" "},{"type":"text","text":"but have different type signatures."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["extension SomeClass {","    @objc(doSomethingWithString:)","    func doSomething(_ x: String) { }","}","let anotherSelector = #selector(SomeClass.doSomething(_:) as (SomeClass) -> (String) -> Void)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because a selector is created at compile time, not at runtime,"},{"type":"text","text":" "},{"type":"text","text":"the compiler can check that a method or property exists"},{"type":"text","text":" "},{"type":"text","text":"and that they’re exposed to the Objective-C runtime."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Although the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"method name"}]},{"type":"text","text":" and the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"property name"}]},{"type":"text","text":" are expressions,"},{"type":"text","text":" "},{"type":"text","text":"they’re never evaluated."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about using selectors"},{"type":"text","text":" "},{"type":"text","text":"in Swift code that interacts with Objective-C APIs,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"overridingTitleInlineContent":[{"type":"text","text":"Using Objective-C Runtime Features in Swift"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift","overridingTitle":"Using Objective-C Runtime Features in Swift"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a selector expression","","selector-expression --> ``#selector`` ``(`` expression  ``)``","selector-expression --> ``#selector`` ``(`` ``getter:`` expression  ``)``","selector-expression --> ``#selector`` ``(`` ``setter:`` expression  ``)``"]},{"anchor":"Key-Path-String-Expression","level":3,"type":"heading","text":"Key-Path String Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A key-path string expression lets you access the string"},{"type":"text","text":" "},{"type":"text","text":"used to refer to a property in Objective-C,"},{"type":"text","text":" "},{"type":"text","text":"for use in key-value coding and key-value observing APIs."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["#keyPath(<#property name#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"property name"}]},{"type":"text","text":" must be a reference to a property"},{"type":"text","text":" "},{"type":"text","text":"that’s available in the Objective-C runtime."},{"type":"text","text":" "},{"type":"text","text":"At compile time, the key-path string expression is replaced by a string literal."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass: NSObject {","   @objc var someProperty: Int","   init(someProperty: Int) {","       self.someProperty = someProperty","   }","}","","let c = SomeClass(someProperty: 12)","let keyPath = #keyPath(SomeClass.someProperty)","","if let value = c.value(forKey: keyPath) {","    print(value)","}","\/\/ Prints \"12\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you use a key-path string expression within a class,"},{"type":"text","text":" "},{"type":"text","text":"you can refer to a property of that class"},{"type":"text","text":" "},{"type":"text","text":"by writing just the property name, without the class name."}]},{"type":"codeListing","syntax":"swift","code":["extension SomeClass {","   func getSomeKeyPath() -> String {","      return #keyPath(someProperty)","   }","}","print(keyPath == c.getSomeKeyPath())","\/\/ Prints \"true\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the key path string is created at compile time, not at runtime,"},{"type":"text","text":" "},{"type":"text","text":"the compiler can check that the property exists"},{"type":"text","text":" "},{"type":"text","text":"and that the property is exposed to the Objective-C runtime."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about using key paths"},{"type":"text","text":" "},{"type":"text","text":"in Swift code that interacts with Objective-C APIs,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"overridingTitleInlineContent":[{"type":"text","text":"Using Objective-C Runtime Features in Swift"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift","overridingTitle":"Using Objective-C Runtime Features in Swift"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For information about key-value coding and key-value observing,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"overridingTitleInlineContent":[{"type":"text","text":"Key-Value Coding Programming Guide"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i","overridingTitle":"Key-Value Coding Programming Guide"},{"type":"text","text":" "},{"type":"text","text":"and "},{"overridingTitleInlineContent":[{"type":"text","text":"Key-Value Observing Programming Guide"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i","overridingTitle":"Key-Value Observing Programming Guide"},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Although the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"property name"}]},{"type":"text","text":" is an expression, it’s never evaluated."}]}],"type":"aside","name":"Note"},{"type":"codeListing","syntax":"markdown","code":["Grammar of a key-path string expression","","key-path-string-expression --> ``#keyPath`` ``(`` expression  ``)``"]},{"anchor":"Postfix-Expressions","level":2,"type":"heading","text":"Postfix Expressions"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Postfix expressions"}]},{"type":"text","text":" are formed"},{"type":"text","text":" "},{"type":"text","text":"by applying a postfix operator or other postfix syntax"},{"type":"text","text":" "},{"type":"text","text":"to an expression."},{"type":"text","text":" "},{"type":"text","text":"Syntactically, every primary expression is also a postfix expression."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the behavior of these operators,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"overridingTitleInlineContent":[{"type":"text","text":"Operator Declarations"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","overridingTitle":"Operator Declarations"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a postfix expression","","postfix-expression --> primary-expression","postfix-expression --> postfix-expression postfix-operator","postfix-expression --> function-call-expression","postfix-expression --> initializer-expression","postfix-expression --> explicit-member-expression","postfix-expression --> postfix-self-expression","postfix-expression --> subscript-expression","postfix-expression --> forced-value-expression","postfix-expression --> optional-chaining-expression"]},{"anchor":"Function-Call-Expression","level":3,"type":"heading","text":"Function Call Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function call expression"}]},{"type":"text","text":" consists of a function name"},{"type":"text","text":" "},{"type":"text","text":"followed by a comma-separated list of the function’s arguments in parentheses."},{"type":"text","text":" "},{"type":"text","text":"Function call expressions have the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#function name#>(<#argument value 1#>, <#argument value 2#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function name"}]},{"type":"text","text":" can be any expression whose value is of a function type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the function definition includes names for its parameters,"},{"type":"text","text":" "},{"type":"text","text":"the function call must include names before its argument values,"},{"type":"text","text":" "},{"type":"text","text":"separated by a colon ("},{"type":"codeVoice","code":":"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"This kind of function call expression has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#function name#>(<#argument name 1#>: <#argument value 1#>, <#argument name 2#>: <#argument value 2#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A function call expression can include trailing closures"},{"type":"text","text":" "},{"type":"text","text":"in the form of closure expressions immediately after the closing parenthesis."},{"type":"text","text":" "},{"type":"text","text":"The trailing closures are understood as arguments to the function,"},{"type":"text","text":" "},{"type":"text","text":"added after the last parenthesized argument."},{"type":"text","text":" "},{"type":"text","text":"The first closure expression is unlabeled;"},{"type":"text","text":" "},{"type":"text","text":"any additional closure expressions are preceded by their argument labels."},{"type":"text","text":" "},{"type":"text","text":"The example below shows the equivalent version of function calls"},{"type":"text","text":" "},{"type":"text","text":"that do and don’t use trailing closure syntax:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ someFunction takes an integer and a closure as its arguments","someFunction(x: x, f: { $0 == 13 })","someFunction(x: x) { $0 == 13 }","","\/\/ anotherFunction takes an integer and two closures as its arguments","anotherFunction(x: x, f: { $0 == 13 }, g: { print(99) })","anotherFunction(x: x) { $0 == 13 } g: { print(99) }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the trailing closure is the function’s only argument,"},{"type":"text","text":" "},{"type":"text","text":"you can omit the parentheses."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ someMethod takes a closure as its only argument","myData.someMethod() { $0 == 13 }","myData.someMethod { $0 == 13 }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To include the trailing closures in the arguments,"},{"type":"text","text":" "},{"type":"text","text":"the compiler examines the function’s parameters from left to right as follows:"}]},{"type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Trailing Closure"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Parameter"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Action"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Labeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Labeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the labels are the same, the closure matches the parameter; otherwise, the parameter is skipped."}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Labeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unlabeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"The parameter is skipped."}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unlabeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Labeled or unlabeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the parameter structurally resembles a function type, as defined below, the closure matches the parameter; otherwise, the parameter is skipped."}]}]]],"header":"row"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The trailing closure is passed as the argument for the parameter that it matches."},{"type":"text","text":" "},{"type":"text","text":"Parameters that were skipped during the scanning process"},{"type":"text","text":" "},{"type":"text","text":"don’t have an argument passed to them —"},{"type":"text","text":" "},{"type":"text","text":"for example, they can use a default parameter."},{"type":"text","text":" "},{"type":"text","text":"After finding a match, scanning continues"},{"type":"text","text":" "},{"type":"text","text":"with the next trailing closure and the next parameter."},{"type":"text","text":" "},{"type":"text","text":"At the end of the matching process,"},{"type":"text","text":" "},{"type":"text","text":"all trailing closures must have a match."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter "},{"type":"emphasis","inlineContent":[{"type":"text","text":"structurally resembles"}]},{"type":"text","text":" a function type"},{"type":"text","text":" "},{"type":"text","text":"if the parameter isn’t an in-out parameter,"},{"type":"text","text":" "},{"type":"text","text":"and the parameter is one of the following:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter whose type is a function type,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"type":"codeVoice","code":"(Bool) -> Int"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An autoclosure parameter"},{"type":"text","text":" "},{"type":"text","text":"whose wrapped expression’s type is a function type,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"type":"codeVoice","code":"@autoclosure () -> ((Bool) -> Int)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A variadic parameter"},{"type":"text","text":" "},{"type":"text","text":"whose array element type is a function type,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"type":"codeVoice","code":"((Bool) -> Int)..."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter whose type is wrapped in one or more layers of optional,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"type":"codeVoice","code":"Optional<(Bool) -> Int>"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter whose type combines these allowed types,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"type":"codeVoice","code":"(Optional<(Bool) -> Int>)..."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When a trailing closure is matched to a parameter"},{"type":"text","text":" "},{"type":"text","text":"whose type structurally resembles a function type, but isn’t a function,"},{"type":"text","text":" "},{"type":"text","text":"the closure is wrapped as needed."},{"type":"text","text":" "},{"type":"text","text":"For example, if the parameter’s type is an optional type,"},{"type":"text","text":" "},{"type":"text","text":"the closure is wrapped in "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" automatically."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To ease migration of code from versions of Swift prior to 5.3 —"},{"type":"text","text":" "},{"type":"text","text":"which performed this matching from right to left —"},{"type":"text","text":" "},{"type":"text","text":"the compiler checks both the left-to-right and right-to-left orderings."},{"type":"text","text":" "},{"type":"text","text":"If the scan directions produce different results,"},{"type":"text","text":" "},{"type":"text","text":"the old right-to-left ordering is used"},{"type":"text","text":" "},{"type":"text","text":"and the compiler generates a warning."},{"type":"text","text":" "},{"type":"text","text":"A future version of Swift will always use the left-to-right ordering."}]},{"type":"codeListing","syntax":"swift","code":["typealias Callback = (Int) -> Int","func someFunction(firstClosure: Callback? = nil,","                secondClosure: Callback? = nil) {","    let first = firstClosure?(10)","    let second = secondClosure?(20)","    print(first ?? \"-\", second ?? \"-\")","}","","someFunction()  \/\/ Prints \"- -\"","someFunction { return $0 + 100 }  \/\/ Ambiguous","someFunction { return $0 } secondClosure: { return $0 }  \/\/ Prints \"10 20\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above,"},{"type":"text","text":" "},{"type":"text","text":"the function call marked “Ambiguous”"},{"type":"text","text":" "},{"type":"text","text":"prints “- 120” and produces a compiler warning on Swift 5.3."},{"type":"text","text":" "},{"type":"text","text":"A future version of Swift will print “110 -”."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A class, structure, or enumeration type"},{"type":"text","text":" "},{"type":"text","text":"can enable syntactic sugar for function call syntax"},{"type":"text","text":" "},{"type":"text","text":"by declaring one of several methods,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Methods-with-Special-Names"},{"type":"text","text":"."}]},{"anchor":"Implicit-Conversion-to-a-Pointer-Type","level":4,"type":"heading","text":"Implicit Conversion to a Pointer Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In a function call expression,"},{"type":"text","text":" "},{"type":"text","text":"if the argument and parameter have a different type,"},{"type":"text","text":" "},{"type":"text","text":"the compiler tries to make their types match"},{"type":"text","text":" "},{"type":"text","text":"by applying one of the implicit conversions in the following list:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"inout SomeType"},{"type":"text","text":" can become"},{"type":"text","text":" "},{"type":"codeVoice","code":"UnsafePointer<SomeType>"},{"type":"text","text":" or "},{"type":"codeVoice","code":"UnsafeMutablePointer<SomeType>"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"inout Array<SomeType>"},{"type":"text","text":" can become"},{"type":"text","text":" "},{"type":"codeVoice","code":"UnsafePointer<SomeType>"},{"type":"text","text":" or "},{"type":"codeVoice","code":"UnsafeMutablePointer<SomeType>"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Array<SomeType>"},{"type":"text","text":" can become "},{"type":"codeVoice","code":"UnsafePointer<SomeType>"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"String"},{"type":"text","text":" can become "},{"type":"codeVoice","code":"UnsafePointer<CChar>"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following two function calls are equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["func unsafeFunction(pointer: UnsafePointer<Int>) {","    \/\/ ...","}","var myNumber = 1234","","unsafeFunction(pointer: &myNumber)","withUnsafePointer(to: myNumber) { unsafeFunction(pointer: $0) }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A pointer that’s created by these implicit conversions"},{"type":"text","text":" "},{"type":"text","text":"is valid only for the duration of the function call."},{"type":"text","text":" "},{"type":"text","text":"To avoid undefined behavior,"},{"type":"text","text":" "},{"type":"text","text":"ensure that your code"},{"type":"text","text":" "},{"type":"text","text":"never persists the pointer after the function call ends."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When implicitly converting an array to an unsafe pointer,"},{"type":"text","text":" "},{"type":"text","text":"Swift ensures that the array’s storage is contiguous"},{"type":"text","text":" "},{"type":"text","text":"by converting or copying the array as needed."},{"type":"text","text":" "},{"type":"text","text":"For example, you can use this syntax"},{"type":"text","text":" "},{"type":"text","text":"with an array that was bridged to "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" "},{"type":"text","text":"from an "},{"type":"codeVoice","code":"NSArray"},{"type":"text","text":" subclass that makes no API contract about its storage."},{"type":"text","text":" "},{"type":"text","text":"If you need to guarantee that the array’s storage is already contiguous,"},{"type":"text","text":" "},{"type":"text","text":"so the implicit conversion never needs to do this work,"},{"type":"text","text":" "},{"type":"text","text":"use "},{"type":"codeVoice","code":"ContiguousArray"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"Array"},{"type":"text","text":"."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using "},{"type":"codeVoice","code":"&"},{"type":"text","text":" instead of an explicit function like "},{"type":"codeVoice","code":"withUnsafePointer(to:)"},{"type":"text","text":" "},{"type":"text","text":"can help make calls to low-level C functions more readable,"},{"type":"text","text":" "},{"type":"text","text":"especially when the function takes several pointer arguments."},{"type":"text","text":" "},{"type":"text","text":"However, when calling functions from other Swift code,"},{"type":"text","text":" "},{"type":"text","text":"avoid using "},{"type":"codeVoice","code":"&"},{"type":"text","text":" instead of using the unsafe APIs explicitly."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a function call expression","","function-call-expression --> postfix-expression function-call-argument-clause","function-call-expression --> postfix-expression function-call-argument-clause-OPT trailing-closures","","function-call-argument-clause --> ``(`` ``)`` | ``(`` function-call-argument-list ``)``","function-call-argument-list --> function-call-argument | function-call-argument ``,`` function-call-argument-list","function-call-argument --> expression | identifier ``:`` expression","function-call-argument --> operator | identifier ``:`` operator","","trailing-closures --> closure-expression labeled-trailing-closures-OPT","labeled-trailing-closures --> labeled-trailing-closure labeled-trailing-closures-OPT","labeled-trailing-closure --> identifier ``:`` closure-expression"]},{"anchor":"Initializer-Expression","level":3,"type":"heading","text":"Initializer Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"initializer expression"}]},{"type":"text","text":" provides access"},{"type":"text","text":" "},{"type":"text","text":"to a type’s initializer."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#expression#>.init(<#initializer arguments#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You use the initializer expression in a function call expression"},{"type":"text","text":" "},{"type":"text","text":"to initialize a new instance of a type."},{"type":"text","text":" "},{"type":"text","text":"You also use an initializer expression"},{"type":"text","text":" "},{"type":"text","text":"to delegate to the initializer of a superclass."}]},{"type":"codeListing","syntax":"swift","code":["class SomeSubClass: SomeSuperClass {","    override init() {","        \/\/ subclass initialization goes here","        super.init()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Like a function, an initializer can be used as a value."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Type annotation is required because String has multiple initializers.","let initializer: (Int) -> String = String.init","let oneTwoThree = [1, 2, 3].map(initializer).reduce(\"\", +)","print(oneTwoThree)","\/\/ Prints \"123\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you specify a type by name,"},{"type":"text","text":" "},{"type":"text","text":"you can access the type’s initializer without using an initializer expression."},{"type":"text","text":" "},{"type":"text","text":"In all other cases, you must use an initializer expression."}]},{"type":"codeListing","syntax":"swift","code":["let s1 = SomeType.init(data: 3)  \/\/ Valid","let s2 = SomeType(data: 1)       \/\/ Also valid","","let s3 = type(of: someValue).init(data: 7)  \/\/ Valid","let s4 = type(of: someValue)(data: 5)       \/\/ Error"]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an initializer expression","","initializer-expression --> postfix-expression ``.`` ``init``","initializer-expression --> postfix-expression ``.`` ``init`` ``(`` argument-names ``)``"]},{"anchor":"Explicit-Member-Expression","level":3,"type":"heading","text":"Explicit Member Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"explicit member expression"}]},{"type":"text","text":" allows access"},{"type":"text","text":" "},{"type":"text","text":"to the members of a named type, a tuple, or a module."},{"type":"text","text":" "},{"type":"text","text":"It consists of a period ("},{"type":"codeVoice","code":"."},{"type":"text","text":") between the item"},{"type":"text","text":" "},{"type":"text","text":"and the identifier of its member."}]},{"type":"codeListing","syntax":"markdown","code":["<#expression#>.<#member name#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The members of a named type are named"},{"type":"text","text":" "},{"type":"text","text":"as part of the type’s declaration or extension."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass {","    var someProperty = 42","}","let c = SomeClass()","let y = c.someProperty  \/\/ Member access"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The members of a tuple"},{"type":"text","text":" "},{"type":"text","text":"are implicitly named using integers in the order they appear,"},{"type":"text","text":" "},{"type":"text","text":"starting from zero."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["var t = (10, 20, 30)","t.0 = t.1","\/\/ Now t is (20, 20, 30)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The members of a module access"},{"type":"text","text":" "},{"type":"text","text":"the top-level declarations of that module."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Types declared with the "},{"type":"codeVoice","code":"dynamicMemberLookup"},{"type":"text","text":" attribute"},{"type":"text","text":" "},{"type":"text","text":"include members that are looked up at runtime,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To distinguish between methods or initializers"},{"type":"text","text":" "},{"type":"text","text":"whose names differ only by the names of their arguments,"},{"type":"text","text":" "},{"type":"text","text":"include the argument names in parentheses,"},{"type":"text","text":" "},{"type":"text","text":"with each argument name followed by a colon ("},{"type":"codeVoice","code":":"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"Write an underscore ("},{"type":"codeVoice","code":"_"},{"type":"text","text":") for an argument with no name."},{"type":"text","text":" "},{"type":"text","text":"To distinguish between overloaded methods,"},{"type":"text","text":" "},{"type":"text","text":"use a type annotation."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass {","    func someMethod(x: Int, y: Int) {}","    func someMethod(x: Int, z: Int) {}","    func overloadedMethod(x: Int, y: Int) {}","    func overloadedMethod(x: Int, y: Bool) {}","}","let instance = SomeClass()","","let a = instance.someMethod              \/\/ Ambiguous","let b = instance.someMethod(x:y:)        \/\/ Unambiguous","","let d = instance.overloadedMethod        \/\/ Ambiguous","let d = instance.overloadedMethod(x:y:)  \/\/ Still ambiguous","let d: (Int, Bool) -> Void  = instance.overloadedMethod(x:y:)  \/\/ Unambiguous"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a period appears at the beginning of a line,"},{"type":"text","text":" "},{"type":"text","text":"it’s understood as part of an explicit member expression,"},{"type":"text","text":" "},{"type":"text","text":"not as an implicit member expression."},{"type":"text","text":" "},{"type":"text","text":"For example, the following listing shows chained method calls"},{"type":"text","text":" "},{"type":"text","text":"split over several lines:"}]},{"type":"codeListing","syntax":"swift","code":["let x = [10, 3, 20, 15, 4]","    .sorted()","    .filter { $0 > 5 }","    .map { $0 * 100 }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can combine this multiline chained syntax"},{"type":"text","text":" "},{"type":"text","text":"with compiler control statements"},{"type":"text","text":" "},{"type":"text","text":"to control when each method is called."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the following code uses a different filtering rule on iOS:"}]},{"type":"codeListing","syntax":"swift","code":["let numbers = [10, 20, 33, 43, 50]","#if os(iOS)","    .filter { $0 < 40 }","#else","    .filter { $0 > 25 }","#endif"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Between "},{"type":"codeVoice","code":"#if"},{"type":"text","text":", "},{"type":"codeVoice","code":"#endif"},{"type":"text","text":", and other compilation directives,"},{"type":"text","text":" "},{"type":"text","text":"the conditional compilation block can contain"},{"type":"text","text":" "},{"type":"text","text":"an implicit member expression"},{"type":"text","text":" "},{"type":"text","text":"followed by zero or more postfixes,"},{"type":"text","text":" "},{"type":"text","text":"to form a postfix expression."},{"type":"text","text":" "},{"type":"text","text":"It can also contain"},{"type":"text","text":" "},{"type":"text","text":"another conditional compilation block,"},{"type":"text","text":" "},{"type":"text","text":"or a combination of these expressions and blocks."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use this syntax anywhere that you can write"},{"type":"text","text":" "},{"type":"text","text":"an explicit member expression,"},{"type":"text","text":" "},{"type":"text","text":"not just in top-level code."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the conditional compilation block,"},{"type":"text","text":" "},{"type":"text","text":"the branch for the "},{"type":"codeVoice","code":"#if"},{"type":"text","text":" compilation directive"},{"type":"text","text":" "},{"type":"text","text":"must contain at least one expression."},{"type":"text","text":" "},{"type":"text","text":"The other branches can be empty."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an explicit member expression","","explicit-member-expression --> postfix-expression ``.`` decimal-digits","explicit-member-expression --> postfix-expression ``.`` identifier generic-argument-clause-OPT","explicit-member-expression --> postfix-expression ``.`` identifier ``(`` argument-names ``)``","explicit-member-expression --> postfix-expression conditional-compilation-block","","argument-names --> argument-name argument-names-OPT","argument-name --> identifier ``:``"]},{"anchor":"Postfix-Self-Expression","level":3,"type":"heading","text":"Postfix Self Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A postfix "},{"type":"codeVoice","code":"self"},{"type":"text","text":" expression consists of an expression or the name of a type,"},{"type":"text","text":" "},{"type":"text","text":"immediately followed by "},{"type":"codeVoice","code":".self"},{"type":"text","text":". It has the following forms:"}]},{"type":"codeListing","syntax":"markdown","code":["<#expression#>.self","<#type#>.self"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The first form evaluates to the value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For example, "},{"type":"codeVoice","code":"x.self"},{"type":"text","text":" evaluates to "},{"type":"codeVoice","code":"x"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The second form evaluates to the value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":". Use this form"},{"type":"text","text":" "},{"type":"text","text":"to access a type as a value. For example,"},{"type":"text","text":" "},{"type":"text","text":"because "},{"type":"codeVoice","code":"SomeClass.self"},{"type":"text","text":" evaluates to the "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" type itself,"},{"type":"text","text":" "},{"type":"text","text":"you can pass it to a function or method that accepts a type-level argument."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a postfix self expression","","postfix-self-expression --> postfix-expression ``.`` ``self``"]},{"anchor":"Subscript-Expression","level":3,"type":"heading","text":"Subscript Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscript expression"}]},{"type":"text","text":" provides subscript access"},{"type":"text","text":" "},{"type":"text","text":"using the getter and setter"},{"type":"text","text":" "},{"type":"text","text":"of the corresponding subscript declaration."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#expression#>[<#index expressions#>]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To evaluate the value of a subscript expression,"},{"type":"text","text":" "},{"type":"text","text":"the subscript getter for the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":"’s type is called"},{"type":"text","text":" "},{"type":"text","text":"with the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"index expressions"}]},{"type":"text","text":" passed as the subscript parameters."},{"type":"text","text":" "},{"type":"text","text":"To set its value,"},{"type":"text","text":" "},{"type":"text","text":"the subscript setter is called in the same way."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about subscript declarations,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Protocol-Subscript-Declaration"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a subscript expression","","subscript-expression --> postfix-expression ``[`` function-call-argument-list ``]``"]},{"anchor":"Forced-Value-Expression","level":3,"type":"heading","text":"Forced-Value Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"forced-value expression"}]},{"type":"text","text":" unwraps an optional value"},{"type":"text","text":" "},{"type":"text","text":"that you are certain isn’t "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#expression#>!"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" isn’t "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the optional value is unwrapped"},{"type":"text","text":" "},{"type":"text","text":"and returned with the corresponding non-optional type."},{"type":"text","text":" "},{"type":"text","text":"Otherwise, a runtime error is raised."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The unwrapped value of a forced-value expression can be modified,"},{"type":"text","text":" "},{"type":"text","text":"either by mutating the value itself,"},{"type":"text","text":" "},{"type":"text","text":"or by assigning to one of the value’s members."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["var x: Int? = 0","x! += 1","\/\/ x is now 1","","var someDictionary = [\"a\": [1, 2, 3], \"b\": [10, 20]]","someDictionary[\"a\"]![0] = 100","\/\/ someDictionary is now [\"a\": [100, 2, 3], \"b\": [10, 20]]"]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a forced-value expression","","forced-value-expression --> postfix-expression ``!``"]},{"anchor":"Optional-Chaining-Expression","level":3,"type":"heading","text":"Optional-Chaining Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-chaining expression"}]},{"type":"text","text":" provides a simplified syntax"},{"type":"text","text":" "},{"type":"text","text":"for using optional values in postfix expressions."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#expression#>?"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The postfix "},{"type":"codeVoice","code":"?"},{"type":"text","text":" operator makes an optional-chaining expression"},{"type":"text","text":" "},{"type":"text","text":"from an expression without changing the expression’s value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Optional-chaining expressions must appear within a postfix expression,"},{"type":"text","text":" "},{"type":"text","text":"and they cause the postfix expression to be evaluated in a special way."},{"type":"text","text":" "},{"type":"text","text":"If the value of the optional-chaining expression is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"all of the other operations in the postfix expression are ignored"},{"type":"text","text":" "},{"type":"text","text":"and the entire postfix expression evaluates to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the value of the optional-chaining expression isn’t "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the value of the optional-chaining expression is unwrapped"},{"type":"text","text":" "},{"type":"text","text":"and used to evaluate the rest of the postfix expression."},{"type":"text","text":" "},{"type":"text","text":"In either case,"},{"type":"text","text":" "},{"type":"text","text":"the value of the postfix expression is still of an optional type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a postfix expression that contains an optional-chaining expression"},{"type":"text","text":" "},{"type":"text","text":"is nested inside other postfix expressions,"},{"type":"text","text":" "},{"type":"text","text":"only the outermost expression returns an optional type."},{"type":"text","text":" "},{"type":"text","text":"In the example below,"},{"type":"text","text":" "},{"type":"text","text":"when "},{"type":"codeVoice","code":"c"},{"type":"text","text":" isn’t "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"its value is unwrapped and used to evaluate "},{"type":"codeVoice","code":".property"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the value of which is used to evaluate "},{"type":"codeVoice","code":".performAction()"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The entire expression "},{"type":"codeVoice","code":"c?.property.performAction()"},{"type":"text","text":" "},{"type":"text","text":"has a value of an optional type."}]},{"type":"codeListing","syntax":"swift","code":["var c: SomeClass?","var result: Bool? = c?.property.performAction()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example shows the behavior"},{"type":"text","text":" "},{"type":"text","text":"of the example above"},{"type":"text","text":" "},{"type":"text","text":"without using optional chaining."}]},{"type":"codeListing","syntax":"swift","code":["var result: Bool?","if let unwrappedC = c {","   result = unwrappedC.property.performAction()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The unwrapped value of an optional-chaining expression can be modified,"},{"type":"text","text":" "},{"type":"text","text":"either by mutating the value itself,"},{"type":"text","text":" "},{"type":"text","text":"or by assigning to one of the value’s members."},{"type":"text","text":" "},{"type":"text","text":"If the value of the optional-chaining expression is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the expression on the right-hand side of the assignment operator"},{"type":"text","text":" "},{"type":"text","text":"isn’t evaluated."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["func someFunctionWithSideEffects() -> Int {","   return 42  \/\/ No actual side effects.","}","var someDictionary = [\"a\": [1, 2, 3], \"b\": [10, 20]]","","someDictionary[\"not here\"]?[0] = someFunctionWithSideEffects()","\/\/ someFunctionWithSideEffects isn't evaluated","\/\/ someDictionary is still [\"a\": [1, 2, 3], \"b\": [10, 20]]","","someDictionary[\"a\"]?[0] = someFunctionWithSideEffects()","\/\/ someFunctionWithSideEffects is evaluated and returns 42","\/\/ someDictionary is now [\"a\": [42, 2, 3], \"b\": [10, 20]]"]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an optional-chaining expression","","optional-chaining-expression --> postfix-expression ``?``"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/expressions"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"In Swift, there are four kinds of expressions:"},{"type":"text","text":" "},{"type":"text","text":"prefix expressions, infix expressions, primary expressions, and postfix expressions."},{"type":"text","text":" "},{"type":"text","text":"Evaluating an expression returns a value,"},{"type":"text","text":" "},{"type":"text","text":"causes a side effect, or both."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Expressions","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Reference","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AboutTheLanguageReference","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Types","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Statements","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/GenericParametersAndArguments"],"generated":true}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions#Postfix-Expressions":{"abstract":[],"title":"Postfix Expressions","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Postfix-Expressions","url":"\/documentation\/the-swift-programming-language\/expressions#Postfix-Expressions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Types":{"role":"article","title":"Tipos","abstract":[{"type":"text","text":"Em Swift, existem dois tipos de dados: tipos nomeados e tipos compostos."},{"type":"text","text":" "},{"type":"text","text":"Um "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipo nomeado"}]},{"type":"text","text":" é um tipo que pode receber um nome específico quando é definido."},{"type":"text","text":" "},{"type":"text","text":"Tipos nomeados incluem classes, structs, enums, e protocolos."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, instâncias de uma classe definida pelo usuário chamada "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":"  tem o tipo "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Além dos tipos nomeados definidos pelo usuário, a biblioteca padrão do Swift define muitos tipos nomeados que são usados com mais frequência, incluindo aqueles que representam arrays, dicionários, e valores opcionais."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Types","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Protocol-Subscript-Declaration":{"abstract":[],"title":"Protocol Subscript Declaration","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Protocol-Subscript-Declaration","url":"\/documentation\/the-swift-programming-language\/declarations#Protocol-Subscript-Declaration"},"https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types":{"title":"Working with Foundation Types","titleInlineContent":[{"type":"text","text":"Working with Foundation Types"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/imported_c_and_objective_c_apis\/working_with_foundation_types","url":"https:\/\/developer.apple.com\/documentation\/swift\/imported_c_and_objective_c_apis\/working_with_foundation_types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-for-Closures":{"abstract":[],"title":"Resolving Strong Reference Cycles for Closures","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-for-Closures","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting#Resolving-Strong-Reference-Cycles-for-Closures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/LexicalStructure":{"role":"article","title":"Lexical Structure","abstract":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"lexical structure"}]},{"type":"text","text":" of Swift describes what sequence of characters"},{"type":"text","text":" "},{"type":"text","text":"form valid tokens of the language."},{"type":"text","text":" "},{"type":"text","text":"These valid tokens form the lowest-level building blocks of the language"},{"type":"text","text":" "},{"type":"text","text":"and are used to describe the rest of the language in subsequent chapters."},{"type":"text","text":" "},{"type":"text","text":"A token consists of an identifier, keyword, punctuation, literal, or operator."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/lexicalstructure"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#In-Out-Parameters":{"abstract":[],"title":"In-Out Parameters","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters","url":"\/documentation\/the-swift-programming-language\/functions#In-Out-Parameters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"role":"article","title":"Error Handling","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Error handling"}]},{"type":"text","text":" is the process of responding to"},{"type":"text","text":" "},{"type":"text","text":"and recovering from error conditions in your program."},{"type":"text","text":" "},{"type":"text","text":"Swift provides first-class support for"},{"type":"text","text":" "},{"type":"text","text":"throwing, catching, propagating, and manipulating"},{"type":"text","text":" "},{"type":"text","text":"recoverable errors at runtime."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/errorhandling"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Function-Declaration":{"abstract":[],"title":"Function Declaration","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Function-Declaration","url":"\/documentation\/the-swift-programming-language\/declarations#Function-Declaration"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes":{"role":"article","title":"Attributes","abstract":[{"type":"text","text":"There are two kinds of attributes in Swift —"},{"type":"text","text":" "},{"type":"text","text":"those that apply to declarations and those that apply to types."},{"type":"text","text":" "},{"type":"text","text":"An attribute provides additional information about the declaration or type."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"discardableResult"},{"type":"text","text":" attribute on a function declaration indicates that,"},{"type":"text","text":" "},{"type":"text","text":"although the function returns a value,"},{"type":"text","text":" "},{"type":"text","text":"the compiler shouldn’t generate a warning if the return value is unused."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/attributes"},"https://developer.apple.com/documentation/swift/operator_declarations":{"title":"Operator Declarations","titleInlineContent":[{"type":"text","text":"Operator Declarations"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","url":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/GenericParametersAndArguments":{"role":"article","title":"Generic Parameters and Arguments","abstract":[{"type":"text","text":"This chapter describes parameters and arguments for generic types, functions, and"},{"type":"text","text":" "},{"type":"text","text":"initializers. When you declare a generic type, function, subscript, or initializer,"},{"type":"text","text":" "},{"type":"text","text":"you specify the type parameters that the generic type, function, or initializer"},{"type":"text","text":" "},{"type":"text","text":"can work with. These type parameters act as placeholders that"},{"type":"text","text":" "},{"type":"text","text":"are replaced by actual concrete type arguments when an instance of a generic type is"},{"type":"text","text":" "},{"type":"text","text":"created or a generic function or initializer is called."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/GenericParametersAndArguments","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/genericparametersandarguments"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Statements#Line-Control-Statement":{"abstract":[],"title":"Line Control Statement","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Statements#Line-Control-Statement","url":"\/documentation\/the-swift-programming-language\/statements#Line-Control-Statement"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions#Function-Call-Expression":{"abstract":[],"title":"Function Call Expression","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Function-Call-Expression","url":"\/documentation\/the-swift-programming-language\/expressions#Function-Call-Expression"},"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i":{"title":"Key-Value Observing Programming Guide","titleInlineContent":[{"type":"text","text":"Key-Value Observing Programming Guide"}],"type":"link","identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i","url":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"role":"article","title":"Type Casting","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance,"},{"type":"text","text":" "},{"type":"text","text":"or to treat that instance as a different"},{"type":"text","text":" "},{"type":"text","text":"superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Methods-with-Special-Names":{"abstract":[],"title":"Methods with Special Names","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Methods-with-Special-Names","url":"\/documentation\/the-swift-programming-language\/declarations#Methods-with-Special-Names"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"role":"article","title":"Operadores básicos","abstract":[{"type":"text","text":"Um operador é um símbolo ou frase que você pode usar para verificar, mudar ou combinar valores."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, o operador de adição ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") soma dois números,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"e o operador lógico E ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"AND"}]},{"type":"text","text":" - "},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combina dois valores booleanos,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/basicoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Closure-Expressions":{"abstract":[],"title":"Closure Expressions","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Closure-Expressions","url":"\/documentation\/the-swift-programming-language\/closures#Closure-Expressions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators":{"role":"article","title":"Operadores Avançados","abstract":[{"type":"text","text":"Além dos operadores descritos no tópico "},{"type":"text","text":"doc:OperadoresBasicos"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"a linguagem Swift oferece o tópico Operadores Avançados que fazem manipulação de valores mais complexa."},{"type":"text","text":" "},{"type":"text","text":"Lá são incluídos operadores bit a bit e operadores com deslocamento que estamos familiarizados em C e Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/advancedoperators"},"https://developer.apple.com/documentation/swift/keypath":{"title":"KeyPath","titleInlineContent":[{"type":"text","text":"KeyPath"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/keypath","url":"https:\/\/developer.apple.com\/documentation\/swift\/keypath"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Patterns":{"role":"article","title":"Patterns","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" represents the structure of a single value"},{"type":"text","text":" "},{"type":"text","text":"or a composite value."},{"type":"text","text":" "},{"type":"text","text":"For example, the structure of a tuple "},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" is a comma-separated list of two"},{"type":"text","text":" "},{"type":"text","text":"elements. Because patterns represent the structure of a value rather than any"},{"type":"text","text":" "},{"type":"text","text":"one particular value, you can match them with a variety of values."},{"type":"text","text":" "},{"type":"text","text":"For instance, the pattern "},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":" matches the tuple "},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" and any other"},{"type":"text","text":" "},{"type":"text","text":"two-element tuple. In addition to matching a pattern with a value,"},{"type":"text","text":" "},{"type":"text","text":"you can extract part or all of a composite value and bind each part"},{"type":"text","text":" "},{"type":"text","text":"to a constant or variable name."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/patterns"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Escaping-Closures":{"abstract":[],"title":"Escaping Closures","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Escaping-Closures","url":"\/documentation\/the-swift-programming-language\/closures#Escaping-Closures"},"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i":{"title":"Key-Value Coding Programming Guide","titleInlineContent":[{"type":"text","text":"Key-Value Coding Programming Guide"}],"type":"link","identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i","url":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Statements":{"role":"article","title":"Statements","abstract":[{"type":"text","text":"In Swift, there are three kinds of statements: simple statements, compiler control statements,"},{"type":"text","text":" "},{"type":"text","text":"and control flow statements."},{"type":"text","text":" "},{"type":"text","text":"Simple statements are the most common and consist of either an expression or a declaration."},{"type":"text","text":" "},{"type":"text","text":"Compiler control statements allow the program to change aspects of the compiler’s behavior"},{"type":"text","text":" "},{"type":"text","text":"and include a conditional compilation block and a line control statement."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Statements","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/statements"},"https://help.apple.com/xcode/mac/current/#/dev4c60242fc":{"title":"Add a color, file, or image literal","titleInlineContent":[{"type":"text","text":"Add a color, file, or image literal"}],"type":"link","identifier":"https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev4c60242fc","url":"https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev4c60242fc"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AboutTheLanguageReference":{"role":"article","title":"About the Language Reference","abstract":[{"type":"text","text":"This part of the book describes the formal grammar of the Swift programming language."},{"type":"text","text":" "},{"type":"text","text":"The grammar described here is intended to help you understand the language in more"},{"type":"text","text":" "},{"type":"text","text":"detail, rather than to allow you to directly implement a parser or compiler."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AboutTheLanguageReference","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/aboutthelanguagereference"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations":{"role":"article","title":"Declarations","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"declaration"}]},{"type":"text","text":" introduces a new name or construct into your program."},{"type":"text","text":" "},{"type":"text","text":"For example, you use declarations to introduce functions and methods,"},{"type":"text","text":" "},{"type":"text","text":"to introduce variables and constants,"},{"type":"text","text":" "},{"type":"text","text":"and to define enumeration, structure, class, and protocol types."},{"type":"text","text":" "},{"type":"text","text":"You can also use a declaration to extend the behavior"},{"type":"text","text":" "},{"type":"text","text":"of an existing named type and to import symbols into your program that are declared elsewhere."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/declarations"},"https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift":{"title":"Using Objective-C Runtime Features in Swift","titleInlineContent":[{"type":"text","text":"Using Objective-C Runtime Features in Swift"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift","url":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift"}}}