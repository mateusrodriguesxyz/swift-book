{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Closures can capture and store references to any constants and variables"},{"type":"text","text":" "},{"type":"text","text":"from the context in which they’re defined."},{"type":"text","text":" "},{"type":"text","text":"This is known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"closing over"}]},{"type":"text","text":" those constants and variables."},{"type":"text","text":" "},{"type":"text","text":"Swift handles all of the memory management of capturing for you."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Don’t worry if you aren’t familiar with the concept of capturing."},{"type":"text","text":" "},{"type":"text","text":"It’s explained in detail below in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Capturing-Values"},{"type":"text","text":"."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Global and nested functions, as introduced in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"are actually special cases of closures."},{"type":"text","text":" "},{"type":"text","text":"Closures take one of three forms:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Global functions are closures that have a name"},{"type":"text","text":" "},{"type":"text","text":"and don’t capture any values."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Nested functions are closures that have a name"},{"type":"text","text":" "},{"type":"text","text":"and can capture values from their enclosing function."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Closure expressions are unnamed closures written in a lightweight syntax"},{"type":"text","text":" "},{"type":"text","text":"that can capture values from their surrounding context."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift’s closure expressions have a clean, clear style,"},{"type":"text","text":" "},{"type":"text","text":"with optimizations that encourage brief, clutter-free syntax in common scenarios."},{"type":"text","text":" "},{"type":"text","text":"These optimizations include:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Inferring parameter and return value types from context"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implicit returns from single-expression closures"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Shorthand argument names"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Trailing closure syntax"}]}]}]},{"anchor":"Closure-Expressions","level":2,"type":"heading","text":"Closure Expressions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nested functions, as introduced in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Nested-Functions"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"are a convenient means of naming and defining self-contained blocks of code"},{"type":"text","text":" "},{"type":"text","text":"as part of a larger function."},{"type":"text","text":" "},{"type":"text","text":"However, it’s sometimes useful to write shorter versions of function-like constructs"},{"type":"text","text":" "},{"type":"text","text":"without a full declaration and name."},{"type":"text","text":" "},{"type":"text","text":"This is particularly true when you work with functions or methods that take functions"},{"type":"text","text":" "},{"type":"text","text":"as one or more of their arguments."}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closure expressions"}]},{"type":"text","text":" are a way to write inline closures in a brief, focused syntax."},{"type":"text","text":" "},{"type":"text","text":"Closure expressions provide several syntax optimizations"},{"type":"text","text":" "},{"type":"text","text":"for writing closures in a shortened form without loss of clarity or intent."},{"type":"text","text":" "},{"type":"text","text":"The closure expression examples below illustrate these optimizations"},{"type":"text","text":" "},{"type":"text","text":"by refining a single example of the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method over several iterations,"},{"type":"text","text":" "},{"type":"text","text":"each of which expresses the same functionality in a more succinct way."}]},{"anchor":"The-Sorted-Method","level":3,"type":"heading","text":"The Sorted Method"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift’s standard library provides a method called "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which sorts an array of values of a known type,"},{"type":"text","text":" "},{"type":"text","text":"based on the output of a sorting closure that you provide."},{"type":"text","text":" "},{"type":"text","text":"Once it completes the sorting process,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method returns a new array of the same type and size as the old one,"},{"type":"text","text":" "},{"type":"text","text":"with its elements in the correct sorted order."},{"type":"text","text":" "},{"type":"text","text":"The original array isn’t modified by the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The closure expression examples below use the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"to sort an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values in reverse alphabetical order."},{"type":"text","text":" "},{"type":"text","text":"Here’s the initial array to be sorted:"}]},{"type":"codeListing","syntax":"swift","code":["let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method accepts a closure that takes two arguments"},{"type":"text","text":" "},{"type":"text","text":"of the same type as the array’s contents,"},{"type":"text","text":" "},{"type":"text","text":"and returns a "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" value to say whether the first value should appear"},{"type":"text","text":" "},{"type":"text","text":"before or after the second value once the values are sorted."},{"type":"text","text":" "},{"type":"text","text":"The sorting closure needs to return "},{"type":"codeVoice","code":"true"},{"type":"text","text":" "},{"type":"text","text":"if the first value should appear "},{"type":"emphasis","inlineContent":[{"type":"text","text":"before"}]},{"type":"text","text":" the second value,"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":"false"},{"type":"text","text":" otherwise."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example is sorting an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"and so the sorting closure needs to be a function of type "},{"type":"codeVoice","code":"(String, String) -> Bool"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One way to provide the sorting closure is to write a normal function of the correct type,"},{"type":"text","text":" "},{"type":"text","text":"and to pass it in as an argument to the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method:"}]},{"type":"codeListing","syntax":"swift","code":["func backward(_ s1: String, _ s2: String) -> Bool {","   return s1 > s2","}","var reversedNames = names.sorted(by: backward)","\/\/ reversedNames is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the first string ("},{"type":"codeVoice","code":"s1"},{"type":"text","text":") is greater than the second string ("},{"type":"codeVoice","code":"s2"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"backward(_:_:)"},{"type":"text","text":" function will return "},{"type":"codeVoice","code":"true"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"indicating that "},{"type":"codeVoice","code":"s1"},{"type":"text","text":" should appear before "},{"type":"codeVoice","code":"s2"},{"type":"text","text":" in the sorted array."},{"type":"text","text":" "},{"type":"text","text":"For characters in strings,"},{"type":"text","text":" "},{"type":"text","text":"“greater than” means “appears later in the alphabet than”."},{"type":"text","text":" "},{"type":"text","text":"This means that the letter "},{"type":"codeVoice","code":"\"B\""},{"type":"text","text":" is “greater than” the letter "},{"type":"codeVoice","code":"\"A\""},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the string "},{"type":"codeVoice","code":"\"Tom\""},{"type":"text","text":" is greater than the string "},{"type":"codeVoice","code":"\"Tim\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This gives a reverse alphabetical sort,"},{"type":"text","text":" "},{"type":"text","text":"with "},{"type":"codeVoice","code":"\"Barry\""},{"type":"text","text":" being placed before "},{"type":"codeVoice","code":"\"Alex\""},{"type":"text","text":", and so on."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, this is a rather long-winded way to write"},{"type":"text","text":" "},{"type":"text","text":"what is essentially a single-expression function ("},{"type":"codeVoice","code":"a > b"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"In this example, it would be preferable to write the sorting closure inline,"},{"type":"text","text":" "},{"type":"text","text":"using closure expression syntax."}]},{"anchor":"Closure-Expression-Syntax","level":3,"type":"heading","text":"Closure Expression Syntax"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Closure expression syntax has the following general form:"}]},{"type":"codeListing","syntax":"markdown","code":["{ (<#parameters#>) -> <#return type#> in","   <#statements#>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"parameters"}]},{"type":"text","text":" in closure expression syntax"},{"type":"text","text":" "},{"type":"text","text":"can be in-out parameters,"},{"type":"text","text":" "},{"type":"text","text":"but they can’t have a default value."},{"type":"text","text":" "},{"type":"text","text":"Variadic parameters can be used if you name the variadic parameter."},{"type":"text","text":" "},{"type":"text","text":"Tuples can also be used as parameter types and return types."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below shows a closure expression version of the "},{"type":"codeVoice","code":"backward(_:_:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"from above:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in","   return s1 > s2","})"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the declaration of parameters and return type for this inline closure"},{"type":"text","text":" "},{"type":"text","text":"is identical to the declaration from the "},{"type":"codeVoice","code":"backward(_:_:)"},{"type":"text","text":" function."},{"type":"text","text":" "},{"type":"text","text":"In both cases, it’s written as "},{"type":"codeVoice","code":"(s1: String, s2: String) -> Bool"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"However, for the inline closure expression,"},{"type":"text","text":" "},{"type":"text","text":"the parameters and return type are written "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inside"}]},{"type":"text","text":" the curly braces,"},{"type":"text","text":" "},{"type":"text","text":"not outside of them."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The start of the closure’s body is introduced by the "},{"type":"codeVoice","code":"in"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"This keyword indicates that"},{"type":"text","text":" "},{"type":"text","text":"the definition of the closure’s parameters and return type has finished,"},{"type":"text","text":" "},{"type":"text","text":"and the body of the closure is about to begin."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the body of the closure is so short,"},{"type":"text","text":" "},{"type":"text","text":"it can even be written on a single line:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This illustrates that the overall call to the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method has remained the same."},{"type":"text","text":" "},{"type":"text","text":"A pair of parentheses still wrap the entire argument for the method."},{"type":"text","text":" "},{"type":"text","text":"However, that argument is now an inline closure."}]},{"anchor":"Inferring-Type-From-Context","level":3,"type":"heading","text":"Inferring Type From Context"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the sorting closure is passed as an argument to a method,"},{"type":"text","text":" "},{"type":"text","text":"Swift can infer the types of its parameters"},{"type":"text","text":" "},{"type":"text","text":"and the type of the value it returns."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method is being called on an array of strings,"},{"type":"text","text":" "},{"type":"text","text":"so its argument must be a function of type "},{"type":"codeVoice","code":"(String, String) -> Bool"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This means that the "},{"type":"codeVoice","code":"(String, String)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" types don’t need to be written"},{"type":"text","text":" "},{"type":"text","text":"as part of the closure expression’s definition."},{"type":"text","text":" "},{"type":"text","text":"Because all of the types can be inferred,"},{"type":"text","text":" "},{"type":"text","text":"the return arrow ("},{"type":"codeVoice","code":"->"},{"type":"text","text":") and the parentheses around the names of the parameters"},{"type":"text","text":" "},{"type":"text","text":"can also be omitted:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s always possible to infer the parameter types and return type"},{"type":"text","text":" "},{"type":"text","text":"when passing a closure to a function or method as an inline closure expression."},{"type":"text","text":" "},{"type":"text","text":"As a result, you never need to write an inline closure in its fullest form"},{"type":"text","text":" "},{"type":"text","text":"when the closure is used as a function or method argument."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nonetheless, you can still make the types explicit if you wish,"},{"type":"text","text":" "},{"type":"text","text":"and doing so is encouraged if it avoids ambiguity for readers of your code."},{"type":"text","text":" "},{"type":"text","text":"In the case of the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method,"},{"type":"text","text":" "},{"type":"text","text":"the purpose of the closure is clear from the fact that sorting is taking place,"},{"type":"text","text":" "},{"type":"text","text":"and it’s safe for a reader to assume that"},{"type":"text","text":" "},{"type":"text","text":"the closure is likely to be working with "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"because it’s assisting with the sorting of an array of strings."}]},{"anchor":"Implicit-Returns-from-Single-Expression-Closures","level":3,"type":"heading","text":"Implicit Returns from Single-Expression Closures"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Single-expression closures can implicitly return the result of their single expression"},{"type":"text","text":" "},{"type":"text","text":"by omitting the "},{"type":"codeVoice","code":"return"},{"type":"text","text":" keyword from their declaration,"},{"type":"text","text":" "},{"type":"text","text":"as in this version of the previous example:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here, the function type of the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method’s argument"},{"type":"text","text":" "},{"type":"text","text":"makes it clear that a "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" value must be returned by the closure."},{"type":"text","text":" "},{"type":"text","text":"Because the closure’s body contains a single expression ("},{"type":"codeVoice","code":"s1 > s2"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"that returns a "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" value,"},{"type":"text","text":" "},{"type":"text","text":"there’s no ambiguity, and the "},{"type":"codeVoice","code":"return"},{"type":"text","text":" keyword can be omitted."}]},{"anchor":"Shorthand-Argument-Names","level":3,"type":"heading","text":"Shorthand Argument Names"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift automatically provides shorthand argument names to inline closures,"},{"type":"text","text":" "},{"type":"text","text":"which can be used to refer to the values of the closure’s arguments"},{"type":"text","text":" "},{"type":"text","text":"by the names "},{"type":"codeVoice","code":"$0"},{"type":"text","text":", "},{"type":"codeVoice","code":"$1"},{"type":"text","text":", "},{"type":"codeVoice","code":"$2"},{"type":"text","text":", and so on."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you use these shorthand argument names within your closure expression,"},{"type":"text","text":" "},{"type":"text","text":"you can omit the closure’s argument list from its definition."},{"type":"text","text":" "},{"type":"text","text":"The type of the shorthand argument names"},{"type":"text","text":" "},{"type":"text","text":"is inferred from the expected function type,"},{"type":"text","text":" "},{"type":"text","text":"and the highest numbered shorthand argument you use"},{"type":"text","text":" "},{"type":"text","text":"determines the number of arguments that the closure takes."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"in"},{"type":"text","text":" keyword can also be omitted,"},{"type":"text","text":" "},{"type":"text","text":"because the closure expression is made up entirely of its body:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { $0 > $1 } )"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here, "},{"type":"codeVoice","code":"$0"},{"type":"text","text":" and "},{"type":"codeVoice","code":"$1"},{"type":"text","text":" refer to the closure’s first and second "},{"type":"codeVoice","code":"String"},{"type":"text","text":" arguments."},{"type":"text","text":" "},{"type":"text","text":"Because "},{"type":"codeVoice","code":"$1"},{"type":"text","text":" is the shorthand argument with highest number,"},{"type":"text","text":" "},{"type":"text","text":"the closure is understood to take two arguments."},{"type":"text","text":" "},{"type":"text","text":"Because the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" function here expects a closure"},{"type":"text","text":" "},{"type":"text","text":"whose arguments are both strings,"},{"type":"text","text":" "},{"type":"text","text":"the shorthand arguments "},{"type":"codeVoice","code":"$0"},{"type":"text","text":" and "},{"type":"codeVoice","code":"$1"},{"type":"text","text":" are both of type "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."}]},{"anchor":"Operator-Methods","level":3,"type":"heading","text":"Operator Methods"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There’s actually an even "},{"type":"emphasis","inlineContent":[{"type":"text","text":"shorter"}]},{"type":"text","text":" way to write the closure expression above."},{"type":"text","text":" "},{"type":"text","text":"Swift’s "},{"type":"codeVoice","code":"String"},{"type":"text","text":" type defines its string-specific implementation of"},{"type":"text","text":" "},{"type":"text","text":"the greater-than operator ("},{"type":"codeVoice","code":">"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"as a method that has two parameters of type "},{"type":"codeVoice","code":"String"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and returns a value of type "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This exactly matches the method type needed by the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method."},{"type":"text","text":" "},{"type":"text","text":"Therefore, you can simply pass in the greater-than operator,"},{"type":"text","text":" "},{"type":"text","text":"and Swift will infer that you want to use its string-specific implementation:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: >)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more about operator methods, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Operator-Methods"},{"type":"text","text":"."}]},{"anchor":"Trailing-Closures","level":2,"type":"heading","text":"Trailing Closures"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you need to pass a closure expression to a function as the function’s final argument"},{"type":"text","text":" "},{"type":"text","text":"and the closure expression is long,"},{"type":"text","text":" "},{"type":"text","text":"it can be useful to write it as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"trailing closure"}]},{"type":"text","text":" instead."},{"type":"text","text":" "},{"type":"text","text":"You write a trailing closure after the function call’s parentheses,"},{"type":"text","text":" "},{"type":"text","text":"even though the trailing closure is still an argument to the function."},{"type":"text","text":" "},{"type":"text","text":"When you use the trailing closure syntax,"},{"type":"text","text":" "},{"type":"text","text":"you don’t write the argument label for the first closure"},{"type":"text","text":" "},{"type":"text","text":"as part of the function call."},{"type":"text","text":" "},{"type":"text","text":"A function call can include multiple trailing closures;"},{"type":"text","text":" "},{"type":"text","text":"however, the first few examples below use a single trailing closure."}]},{"type":"codeListing","syntax":"swift","code":["func someFunctionThatTakesAClosure(closure: () -> Void) {","   \/\/ function body goes here","}","","\/\/ Here's how you call this function without using a trailing closure:","","someFunctionThatTakesAClosure(closure: {","   \/\/ closure's body goes here","})","","\/\/ Here's how you call this function with a trailing closure instead:","","someFunctionThatTakesAClosure() {","   \/\/ trailing closure's body goes here","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The string-sorting closure from the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Closure-Expression-Syntax"},{"type":"text","text":" section above"},{"type":"text","text":" "},{"type":"text","text":"can be written outside of the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method’s parentheses as a trailing closure:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted() { $0 > $1 }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a closure expression is provided as the function’s or method’s only argument"},{"type":"text","text":" "},{"type":"text","text":"and you provide that expression as a trailing closure,"},{"type":"text","text":" "},{"type":"text","text":"you don’t need to write a pair of parentheses "},{"type":"codeVoice","code":"()"},{"type":"text","text":" "},{"type":"text","text":"after the function or method’s name when you call the function:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted { $0 > $1 }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Trailing closures are most useful when the closure is sufficiently long that"},{"type":"text","text":" "},{"type":"text","text":"it isn’t possible to write it inline on a single line."},{"type":"text","text":" "},{"type":"text","text":"As an example, Swift’s "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" type has a "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method,"},{"type":"text","text":" "},{"type":"text","text":"which takes a closure expression as its single argument."},{"type":"text","text":" "},{"type":"text","text":"The closure is called once for each item in the array,"},{"type":"text","text":" "},{"type":"text","text":"and returns an alternative mapped value (possibly of some other type) for that item."},{"type":"text","text":" "},{"type":"text","text":"You specify"},{"type":"text","text":" "},{"type":"text","text":"the nature of the mapping and the type of the returned value"},{"type":"text","text":" "},{"type":"text","text":"by writing code in the closure that you pass to "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"After applying the provided closure to each array element,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method returns a new array containing all of the new mapped values,"},{"type":"text","text":" "},{"type":"text","text":"in the same order as their corresponding values in the original array."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how you can use the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method with a trailing closure"},{"type":"text","text":" "},{"type":"text","text":"to convert an array of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values into an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values."},{"type":"text","text":" "},{"type":"text","text":"The array "},{"type":"codeVoice","code":"[16, 58, 510]"},{"type":"text","text":" is used to create the new array"},{"type":"text","text":" "},{"type":"codeVoice","code":"[\"OneSix\", \"FiveEight\", \"FiveOneZero\"]"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let digitNames = [","   0: \"Zero\", 1: \"One\", 2: \"Two\",   3: \"Three\", 4: \"Four\",","   5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"","]","let numbers = [16, 58, 510]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code above creates a dictionary of mappings between"},{"type":"text","text":" "},{"type":"text","text":"the integer digits and English-language versions of their names."},{"type":"text","text":" "},{"type":"text","text":"It also defines an array of integers, ready to be converted into strings."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can now use the "},{"type":"codeVoice","code":"numbers"},{"type":"text","text":" array to create an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"by passing a closure expression to the array’s "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method as a trailing closure:"}]},{"type":"codeListing","syntax":"swift","code":["let strings = numbers.map { (number) -> String in","   var number = number","   var output = \"\"","   repeat {","      output = digitNames[number % 10]! + output","      number \/= 10","   } while number > 0","   return output","}","\/\/ strings is inferred to be of type [String]","\/\/ its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method calls the closure expression once for each item in the array."},{"type":"text","text":" "},{"type":"text","text":"You don’t need to specify the type of the closure’s input parameter, "},{"type":"codeVoice","code":"number"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"because the type can be inferred from the values in the array to be mapped."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example,"},{"type":"text","text":" "},{"type":"text","text":"the variable "},{"type":"codeVoice","code":"number"},{"type":"text","text":" is initialized with the value of the closure’s "},{"type":"codeVoice","code":"number"},{"type":"text","text":" parameter,"},{"type":"text","text":" "},{"type":"text","text":"so that the value can be modified within the closure body."},{"type":"text","text":" "},{"type":"text","text":"(The parameters to functions and closures are always constants.)"},{"type":"text","text":" "},{"type":"text","text":"The closure expression also specifies a return type of "},{"type":"codeVoice","code":"String"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"to indicate the type that will be stored in the mapped output array."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The closure expression builds a string called "},{"type":"codeVoice","code":"output"},{"type":"text","text":" each time it’s called."},{"type":"text","text":" "},{"type":"text","text":"It calculates the last digit of "},{"type":"codeVoice","code":"number"},{"type":"text","text":" by using the remainder operator ("},{"type":"codeVoice","code":"number % 10"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"and uses this digit to look up an appropriate string in the "},{"type":"codeVoice","code":"digitNames"},{"type":"text","text":" dictionary."},{"type":"text","text":" "},{"type":"text","text":"The closure can be used to create a string representation of any integer greater than zero."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The call to the "},{"type":"codeVoice","code":"digitNames"},{"type":"text","text":" dictionary’s subscript"},{"type":"text","text":" "},{"type":"text","text":"is followed by an exclamation point ("},{"type":"codeVoice","code":"!"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"because dictionary subscripts return an optional value"},{"type":"text","text":" "},{"type":"text","text":"to indicate that the dictionary lookup can fail if the key doesn’t exist."},{"type":"text","text":" "},{"type":"text","text":"In the example above, it’s guaranteed that "},{"type":"codeVoice","code":"number % 10"},{"type":"text","text":" "},{"type":"text","text":"will always be a valid subscript key for the "},{"type":"codeVoice","code":"digitNames"},{"type":"text","text":" dictionary,"},{"type":"text","text":" "},{"type":"text","text":"and so an exclamation point is used to force-unwrap the "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value"},{"type":"text","text":" "},{"type":"text","text":"stored in the subscript’s optional return value."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The string retrieved from the "},{"type":"codeVoice","code":"digitNames"},{"type":"text","text":" dictionary"},{"type":"text","text":" "},{"type":"text","text":"is added to the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"front"}]},{"type":"text","text":" of "},{"type":"codeVoice","code":"output"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"effectively building a string version of the number in reverse."},{"type":"text","text":" "},{"type":"text","text":"(The expression "},{"type":"codeVoice","code":"number % 10"},{"type":"text","text":" gives a value of"},{"type":"text","text":" "},{"type":"codeVoice","code":"6"},{"type":"text","text":" for "},{"type":"codeVoice","code":"16"},{"type":"text","text":", "},{"type":"codeVoice","code":"8"},{"type":"text","text":" for "},{"type":"codeVoice","code":"58"},{"type":"text","text":", and "},{"type":"codeVoice","code":"0"},{"type":"text","text":" for "},{"type":"codeVoice","code":"510"},{"type":"text","text":".)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"number"},{"type":"text","text":" variable is then divided by "},{"type":"codeVoice","code":"10"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Because it’s an integer, it’s rounded down during the division,"},{"type":"text","text":" "},{"type":"text","text":"so "},{"type":"codeVoice","code":"16"},{"type":"text","text":" becomes "},{"type":"codeVoice","code":"1"},{"type":"text","text":", "},{"type":"codeVoice","code":"58"},{"type":"text","text":" becomes "},{"type":"codeVoice","code":"5"},{"type":"text","text":", and "},{"type":"codeVoice","code":"510"},{"type":"text","text":" becomes "},{"type":"codeVoice","code":"51"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The process is repeated until "},{"type":"codeVoice","code":"number"},{"type":"text","text":" is equal to "},{"type":"codeVoice","code":"0"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"at which point the "},{"type":"codeVoice","code":"output"},{"type":"text","text":" string is returned by the closure,"},{"type":"text","text":" "},{"type":"text","text":"and is added to the output array by the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The use of trailing closure syntax in the example above"},{"type":"text","text":" "},{"type":"text","text":"neatly encapsulates the closure’s functionality"},{"type":"text","text":" "},{"type":"text","text":"immediately after the function that closure supports,"},{"type":"text","text":" "},{"type":"text","text":"without needing to wrap the entire closure within"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method’s outer parentheses."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a function takes multiple closures,"},{"type":"text","text":" "},{"type":"text","text":"you omit the argument label for the first trailing closure"},{"type":"text","text":" "},{"type":"text","text":"and you label the remaining trailing closures."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the function below loads a picture for a photo gallery:"}]},{"type":"codeListing","syntax":"swift","code":["func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {","    if let picture = download(\"photo.jpg\", from: server) {","        completion(picture)","    } else {","        onFailure()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you call this function to load a picture,"},{"type":"text","text":" "},{"type":"text","text":"you provide two closures."},{"type":"text","text":" "},{"type":"text","text":"The first closure is a completion handler"},{"type":"text","text":" "},{"type":"text","text":"that displays a picture after a successful download."},{"type":"text","text":" "},{"type":"text","text":"The second closure is an error handler"},{"type":"text","text":" "},{"type":"text","text":"that displays an error to the user."}]},{"type":"codeListing","syntax":"swift","code":["loadPicture(from: someServer) { picture in","    someView.currentPicture = picture","} onFailure: {","    print(\"Couldn't download the next picture.\")","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"loadPicture(from:completion:onFailure:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"dispatches its network task into the background,"},{"type":"text","text":" "},{"type":"text","text":"and calls one of the two completion handlers when the network task finishes."},{"type":"text","text":" "},{"type":"text","text":"Writing the function this way lets you cleanly separate the code"},{"type":"text","text":" "},{"type":"text","text":"that’s responsible for handling a network failure"},{"type":"text","text":" "},{"type":"text","text":"from the code that updates the user interface after a successful download,"},{"type":"text","text":" "},{"type":"text","text":"instead of using just one closure that handles both circumstances."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Completion handlers can become hard to read,"},{"type":"text","text":" "},{"type":"text","text":"especially when you have to nest multiple handlers."},{"type":"text","text":" "},{"type":"text","text":"An alternate approach is to use asynchronous code,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency"},{"type":"text","text":"."}]}],"type":"aside","name":"Note"},{"anchor":"Capturing-Values","level":2,"type":"heading","text":"Capturing Values"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture"}]},{"type":"text","text":" constants and variables"},{"type":"text","text":" "},{"type":"text","text":"from the surrounding context in which it’s defined."},{"type":"text","text":" "},{"type":"text","text":"The closure can then refer to and modify"},{"type":"text","text":" "},{"type":"text","text":"the values of those constants and variables from within its body,"},{"type":"text","text":" "},{"type":"text","text":"even if the original scope that defined the constants and variables no longer exists."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, the simplest form of a closure that can capture values is a nested function,"},{"type":"text","text":" "},{"type":"text","text":"written within the body of another function."},{"type":"text","text":" "},{"type":"text","text":"A nested function can capture any of its outer function’s arguments"},{"type":"text","text":" "},{"type":"text","text":"and can also capture any constants and variables defined within the outer function."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a function called "},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which contains a nested function called "},{"type":"codeVoice","code":"incrementer"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The nested "},{"type":"codeVoice","code":"incrementer()"},{"type":"text","text":" function captures two values,"},{"type":"text","text":" "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"from its surrounding context."},{"type":"text","text":" "},{"type":"text","text":"After capturing these values,"},{"type":"text","text":" "},{"type":"codeVoice","code":"incrementer"},{"type":"text","text":" is returned by "},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" as a closure"},{"type":"text","text":" "},{"type":"text","text":"that increments "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" by "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" each time it’s called."}]},{"type":"codeListing","syntax":"swift","code":["func makeIncrementer(forIncrement amount: Int) -> () -> Int {","   var runningTotal = 0","   func incrementer() -> Int {","      runningTotal += amount","      return runningTotal","   }","   return incrementer","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The return type of "},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" is "},{"type":"codeVoice","code":"() -> Int"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This means that it returns a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function"}]},{"type":"text","text":", rather than a simple value."},{"type":"text","text":" "},{"type":"text","text":"The function it returns has no parameters,"},{"type":"text","text":" "},{"type":"text","text":"and returns an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value each time it’s called."},{"type":"text","text":" "},{"type":"text","text":"To learn how functions can return other functions,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Function-Types-as-Return-Types"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeIncrementer(forIncrement:)"},{"type":"text","text":" function defines an integer variable called "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"to store the current running total of the incrementer that will be returned."},{"type":"text","text":" "},{"type":"text","text":"This variable is initialized with a value of "},{"type":"codeVoice","code":"0"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeIncrementer(forIncrement:)"},{"type":"text","text":" function has a single "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" parameter"},{"type":"text","text":" "},{"type":"text","text":"with an argument label of "},{"type":"codeVoice","code":"forIncrement"},{"type":"text","text":", and a parameter name of "},{"type":"codeVoice","code":"amount"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The argument value passed to this parameter specifies"},{"type":"text","text":" "},{"type":"text","text":"how much "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" should be incremented by"},{"type":"text","text":" "},{"type":"text","text":"each time the returned incrementer function is called."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" function defines a nested function called "},{"type":"codeVoice","code":"incrementer"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which performs the actual incrementing."},{"type":"text","text":" "},{"type":"text","text":"This function simply adds "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" to "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":", and returns the result."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When considered in isolation,"},{"type":"text","text":" "},{"type":"text","text":"the nested "},{"type":"codeVoice","code":"incrementer()"},{"type":"text","text":" function might seem unusual:"}]},{"type":"codeListing","syntax":"swift","code":["func incrementer() -> Int {","   runningTotal += amount","   return runningTotal","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"incrementer()"},{"type":"text","text":" function doesn’t have any parameters,"},{"type":"text","text":" "},{"type":"text","text":"and yet it refers to "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" from within its function body."},{"type":"text","text":" "},{"type":"text","text":"It does this by capturing a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"reference"}]},{"type":"text","text":" to "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" "},{"type":"text","text":"from the surrounding function and using them within its own function body."},{"type":"text","text":" "},{"type":"text","text":"Capturing by reference ensures that "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" don’t disappear"},{"type":"text","text":" "},{"type":"text","text":"when the call to "},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" ends,"},{"type":"text","text":" "},{"type":"text","text":"and also ensures that "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" is available"},{"type":"text","text":" "},{"type":"text","text":"the next time the "},{"type":"codeVoice","code":"incrementer"},{"type":"text","text":" function is called."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As an optimization,"},{"type":"text","text":" "},{"type":"text","text":"Swift may instead capture and store a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"copy"}]},{"type":"text","text":" of a value"},{"type":"text","text":" "},{"type":"text","text":"if that value isn’t mutated by a closure,"},{"type":"text","text":" "},{"type":"text","text":"and if the value isn’t mutated after the closure is created.Swift also handles all memory management involved in disposing of"},{"type":"text","text":" "},{"type":"text","text":"variables when they’re no longer needed."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of "},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" in action:"}]},{"type":"codeListing","syntax":"swift","code":["let incrementByTen = makeIncrementer(forIncrement: 10)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example sets a constant called "},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":" "},{"type":"text","text":"to refer to an incrementer function that adds "},{"type":"codeVoice","code":"10"},{"type":"text","text":" to"},{"type":"text","text":" "},{"type":"text","text":"its "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" variable each time it’s called."},{"type":"text","text":" "},{"type":"text","text":"Calling the function multiple times shows this behavior in action:"}]},{"type":"codeListing","syntax":"swift","code":["incrementByTen()","\/\/ returns a value of 10","incrementByTen()","\/\/ returns a value of 20","incrementByTen()","\/\/ returns a value of 30"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you create a second incrementer,"},{"type":"text","text":" "},{"type":"text","text":"it will have its own stored reference to a new, separate "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" variable:"}]},{"type":"codeListing","syntax":"swift","code":["let incrementBySeven = makeIncrementer(forIncrement: 7)","incrementBySeven()","\/\/ returns a value of 7"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Calling the original incrementer ("},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":") again"},{"type":"text","text":" "},{"type":"text","text":"continues to increment its own "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" variable,"},{"type":"text","text":" "},{"type":"text","text":"and doesn’t affect the variable captured by "},{"type":"codeVoice","code":"incrementBySeven"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["incrementByTen()","\/\/ returns a value of 40"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you assign a closure to a property of a class instance,"},{"type":"text","text":" "},{"type":"text","text":"and the closure captures that instance by referring to the instance or its members,"},{"type":"text","text":" "},{"type":"text","text":"you will create a strong reference cycle between the closure and the instance."},{"type":"text","text":" "},{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture lists"}]},{"type":"text","text":" to break these strong reference cycles."},{"type":"text","text":" "},{"type":"text","text":"For more information, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures"},{"type":"text","text":"."}]}],"type":"aside","name":"Note"},{"anchor":"Closures-Are-Reference-Types","level":2,"type":"heading","text":"Closures Are Reference Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above,"},{"type":"text","text":" "},{"type":"codeVoice","code":"incrementBySeven"},{"type":"text","text":" and "},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":" are constants,"},{"type":"text","text":" "},{"type":"text","text":"but the closures these constants refer to are still able to increment"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" variables that they have captured."},{"type":"text","text":" "},{"type":"text","text":"This is because functions and closures are "},{"type":"emphasis","inlineContent":[{"type":"text","text":"reference types"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Whenever you assign a function or a closure to a constant or a variable,"},{"type":"text","text":" "},{"type":"text","text":"you are actually setting that constant or variable to be"},{"type":"text","text":" "},{"type":"text","text":"a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"reference"}]},{"type":"text","text":" to the function or closure."},{"type":"text","text":" "},{"type":"text","text":"In the example above,"},{"type":"text","text":" "},{"type":"text","text":"it’s the choice of closure that "},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"refers to"}]},{"type":"text","text":" that’s constant,"},{"type":"text","text":" "},{"type":"text","text":"and not the contents of the closure itself."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This also means that if you assign a closure to two different constants or variables,"},{"type":"text","text":" "},{"type":"text","text":"both of those constants or variables refer to the same closure."}]},{"type":"codeListing","syntax":"swift","code":["let alsoIncrementByTen = incrementByTen","alsoIncrementByTen()","\/\/ returns a value of 50","","incrementByTen()","\/\/ returns a value of 60"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above shows that calling "},{"type":"codeVoice","code":"alsoIncrementByTen"},{"type":"text","text":" "},{"type":"text","text":"is the same as calling "},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Because both of them refer to the same closure,"},{"type":"text","text":" "},{"type":"text","text":"they both increment and return the same running total."}]},{"anchor":"Escaping-Closures","level":2,"type":"heading","text":"Escaping Closures"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure is said to "},{"type":"emphasis","inlineContent":[{"type":"text","text":"escape"}]},{"type":"text","text":" a function"},{"type":"text","text":" "},{"type":"text","text":"when the closure is passed as an argument to the function,"},{"type":"text","text":" "},{"type":"text","text":"but is called after the function returns."},{"type":"text","text":" "},{"type":"text","text":"When you declare a function that takes a closure as one of its parameters,"},{"type":"text","text":" "},{"type":"text","text":"you can write "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":" before the parameter’s type"},{"type":"text","text":" "},{"type":"text","text":"to indicate that the closure is allowed to escape."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One way that a closure can escape"},{"type":"text","text":" "},{"type":"text","text":"is by being stored in a variable that’s defined outside the function."},{"type":"text","text":" "},{"type":"text","text":"As an example,"},{"type":"text","text":" "},{"type":"text","text":"many functions that start an asynchronous operation"},{"type":"text","text":" "},{"type":"text","text":"take a closure argument as a completion handler."},{"type":"text","text":" "},{"type":"text","text":"The function returns after it starts the operation,"},{"type":"text","text":" "},{"type":"text","text":"but the closure isn’t called until the operation is completed —"},{"type":"text","text":" "},{"type":"text","text":"the closure needs to escape, to be called later."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["var completionHandlers: [() -> Void] = []","func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {","    completionHandlers.append(completionHandler)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"someFunctionWithEscapingClosure(_:)"},{"type":"text","text":" function takes a closure as its argument"},{"type":"text","text":" "},{"type":"text","text":"and adds it to an array that’s declared outside the function."},{"type":"text","text":" "},{"type":"text","text":"If you didn’t mark the parameter of this function with "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"you would get a compile-time error."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An escaping closure that refers to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" "},{"type":"text","text":"needs special consideration if "},{"type":"codeVoice","code":"self"},{"type":"text","text":" refers to an instance of a class."},{"type":"text","text":" "},{"type":"text","text":"Capturing "},{"type":"codeVoice","code":"self"},{"type":"text","text":" in an escaping closure"},{"type":"text","text":" "},{"type":"text","text":"makes it easy to accidentally create a strong reference cycle."},{"type":"text","text":" "},{"type":"text","text":"For information about reference cycles,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Normally, a closure captures variables implicitly"},{"type":"text","text":" "},{"type":"text","text":"by using them in the body of the closure,"},{"type":"text","text":" "},{"type":"text","text":"but in this case you need to be explicit."},{"type":"text","text":" "},{"type":"text","text":"If you want to capture "},{"type":"codeVoice","code":"self"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"write "},{"type":"codeVoice","code":"self"},{"type":"text","text":" explicitly when you use it,"},{"type":"text","text":" "},{"type":"text","text":"or include "},{"type":"codeVoice","code":"self"},{"type":"text","text":" in the closure’s capture list."},{"type":"text","text":" "},{"type":"text","text":"Writing "},{"type":"codeVoice","code":"self"},{"type":"text","text":" explicitly lets you express your intent,"},{"type":"text","text":" "},{"type":"text","text":"and reminds you to confirm that there isn’t a reference cycle."},{"type":"text","text":" "},{"type":"text","text":"For example, in the code below,"},{"type":"text","text":" "},{"type":"text","text":"the closure passed to "},{"type":"codeVoice","code":"someFunctionWithEscapingClosure(_:)"},{"type":"text","text":" "},{"type":"text","text":"refers to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" explicitly."},{"type":"text","text":" "},{"type":"text","text":"In contrast, the closure passed to "},{"type":"codeVoice","code":"someFunctionWithNonescapingClosure(_:)"},{"type":"text","text":" "},{"type":"text","text":"is a nonescaping closure, which means it can refer to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" implicitly."}]},{"type":"codeListing","syntax":"swift","code":["func someFunctionWithNonescapingClosure(closure: () -> Void) {","    closure()","}","","class SomeClass {","    var x = 10","    func doSomething() {","        someFunctionWithEscapingClosure { self.x = 100 }","        someFunctionWithNonescapingClosure { x = 200 }","    }","}","","let instance = SomeClass()","instance.doSomething()","print(instance.x)","\/\/ Prints \"200\"","","completionHandlers.first?()","print(instance.x)","\/\/ Prints \"100\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a version of "},{"type":"codeVoice","code":"doSomething()"},{"type":"text","text":" that captures "},{"type":"codeVoice","code":"self"},{"type":"text","text":" "},{"type":"text","text":"by including it in the closure’s capture list,"},{"type":"text","text":" "},{"type":"text","text":"and then refers to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" implicitly:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeOtherClass {","    var x = 10","    func doSomething() {","        someFunctionWithEscapingClosure { [self] in x = 100 }","        someFunctionWithNonescapingClosure { x = 200 }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If "},{"type":"codeVoice","code":"self"},{"type":"text","text":" is an instance of a structure or an enumeration,"},{"type":"text","text":" "},{"type":"text","text":"you can always refer to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" implicitly."},{"type":"text","text":" "},{"type":"text","text":"However,"},{"type":"text","text":" "},{"type":"text","text":"an escaping closure can’t capture a mutable reference to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" "},{"type":"text","text":"when "},{"type":"codeVoice","code":"self"},{"type":"text","text":" is an instance of a structure or an enumeration."},{"type":"text","text":" "},{"type":"text","text":"Structures and enumerations don’t allow shared mutability,"},{"type":"text","text":" "},{"type":"text","text":"as discussed in "},{"type":"text","text":"doc:ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["struct SomeStruct {","    var x = 10","    mutating func doSomething() {","        someFunctionWithNonescapingClosure { x = 200 }  \/\/ Ok","        someFunctionWithEscapingClosure { x = 100 }     \/\/ Error","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The call to the "},{"type":"codeVoice","code":"someFunctionWithEscapingClosure"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"in the example above is an error"},{"type":"text","text":" "},{"type":"text","text":"because it’s inside a mutating method,"},{"type":"text","text":" "},{"type":"text","text":"so "},{"type":"codeVoice","code":"self"},{"type":"text","text":" is mutable."},{"type":"text","text":" "},{"type":"text","text":"That violates the rule that escaping closures can’t capture"},{"type":"text","text":" "},{"type":"text","text":"a mutable reference to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" for structures."}]},{"anchor":"Autoclosures","level":2,"type":"heading","text":"Autoclosures"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"autoclosure"}]},{"type":"text","text":" is a closure that’s automatically created"},{"type":"text","text":" "},{"type":"text","text":"to wrap an expression that’s being passed as an argument to a function."},{"type":"text","text":" "},{"type":"text","text":"It doesn’t take any arguments,"},{"type":"text","text":" "},{"type":"text","text":"and when it’s called, it returns the value"},{"type":"text","text":" "},{"type":"text","text":"of the expression that’s wrapped inside of it."},{"type":"text","text":" "},{"type":"text","text":"This syntactic convenience lets you omit braces around a function’s parameter"},{"type":"text","text":" "},{"type":"text","text":"by writing a normal expression instead of an explicit closure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s common to "},{"type":"emphasis","inlineContent":[{"type":"text","text":"call"}]},{"type":"text","text":" functions that take autoclosures,"},{"type":"text","text":" "},{"type":"text","text":"but it’s not common to "},{"type":"emphasis","inlineContent":[{"type":"text","text":"implement"}]},{"type":"text","text":" that kind of function."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"assert(condition:message:file:line:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"takes an autoclosure for its "},{"type":"codeVoice","code":"condition"},{"type":"text","text":" and "},{"type":"codeVoice","code":"message"},{"type":"text","text":" parameters;"},{"type":"text","text":" "},{"type":"text","text":"its "},{"type":"codeVoice","code":"condition"},{"type":"text","text":" parameter is evaluated only in debug builds"},{"type":"text","text":" "},{"type":"text","text":"and its "},{"type":"codeVoice","code":"message"},{"type":"text","text":" parameter is evaluated only if "},{"type":"codeVoice","code":"condition"},{"type":"text","text":" is "},{"type":"codeVoice","code":"false"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An autoclosure lets you delay evaluation,"},{"type":"text","text":" "},{"type":"text","text":"because the code inside isn’t run until you call the closure."},{"type":"text","text":" "},{"type":"text","text":"Delaying evaluation is useful for code"},{"type":"text","text":" "},{"type":"text","text":"that has side effects or is computationally expensive,"},{"type":"text","text":" "},{"type":"text","text":"because it lets you control when that code is evaluated."},{"type":"text","text":" "},{"type":"text","text":"The code below shows how a closure delays evaluation."}]},{"type":"codeListing","syntax":"swift","code":["var customersInLine = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]","print(customersInLine.count)","\/\/ Prints \"5\"","","let customerProvider = { customersInLine.remove(at: 0) }","print(customersInLine.count)","\/\/ Prints \"5\"","","print(\"Now serving \\(customerProvider())!\")","\/\/ Prints \"Now serving Chris!\"","print(customersInLine.count)","\/\/ Prints \"4\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Even though the first element of the "},{"type":"codeVoice","code":"customersInLine"},{"type":"text","text":" array is removed"},{"type":"text","text":" "},{"type":"text","text":"by the code inside the closure,"},{"type":"text","text":" "},{"type":"text","text":"the array element isn’t removed until the closure is actually called."},{"type":"text","text":" "},{"type":"text","text":"If the closure is never called,"},{"type":"text","text":" "},{"type":"text","text":"the expression inside the closure is never evaluated,"},{"type":"text","text":" "},{"type":"text","text":"which means the array element is never removed."},{"type":"text","text":" "},{"type":"text","text":"Note that the type of "},{"type":"codeVoice","code":"customerProvider"},{"type":"text","text":" isn’t "},{"type":"codeVoice","code":"String"},{"type":"text","text":" "},{"type":"text","text":"but "},{"type":"codeVoice","code":"() -> String"},{"type":"text","text":" —"},{"type":"text","text":" "},{"type":"text","text":"a function with no parameters that returns a string."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You get the same behavior of delayed evaluation"},{"type":"text","text":" "},{"type":"text","text":"when you pass a closure as an argument to a function."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]","func serve(customer customerProvider: () -> String) {","    print(\"Now serving \\(customerProvider())!\")","}","serve(customer: { customersInLine.remove(at: 0) } )","\/\/ Prints \"Now serving Alex!\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"serve(customer:)"},{"type":"text","text":" function in the listing above"},{"type":"text","text":" "},{"type":"text","text":"takes an explicit closure that returns a customer’s name."},{"type":"text","text":" "},{"type":"text","text":"The version of "},{"type":"codeVoice","code":"serve(customer:)"},{"type":"text","text":" below"},{"type":"text","text":" "},{"type":"text","text":"performs the same operation but, instead of taking an explicit closure,"},{"type":"text","text":" "},{"type":"text","text":"it takes an autoclosure"},{"type":"text","text":" "},{"type":"text","text":"by marking its parameter’s type with the "},{"type":"codeVoice","code":"@autoclosure"},{"type":"text","text":" attribute."},{"type":"text","text":" "},{"type":"text","text":"Now you can call the function"},{"type":"text","text":" "},{"type":"text","text":"as if it took a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" argument instead of a closure."},{"type":"text","text":" "},{"type":"text","text":"The argument is automatically converted to a closure,"},{"type":"text","text":" "},{"type":"text","text":"because the "},{"type":"codeVoice","code":"customerProvider"},{"type":"text","text":" parameter’s type is marked"},{"type":"text","text":" "},{"type":"text","text":"with the "},{"type":"codeVoice","code":"@autoclosure"},{"type":"text","text":" attribute."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]","func serve(customer customerProvider: @autoclosure () -> String) {","    print(\"Now serving \\(customerProvider())!\")","}","serve(customer: customersInLine.remove(at: 0))","\/\/ Prints \"Now serving Ewa!\""]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Overusing autoclosures can make your code hard to understand."},{"type":"text","text":" "},{"type":"text","text":"The context and function name should make it clear"},{"type":"text","text":" "},{"type":"text","text":"that evaluation is being deferred."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you want an autoclosure that’s allowed to escape,"},{"type":"text","text":" "},{"type":"text","text":"use both the "},{"type":"codeVoice","code":"@autoclosure"},{"type":"text","text":" and "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":" attributes."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":" attribute is described above in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Escaping-Closures"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ customersInLine is [\"Barry\", \"Daniella\"]","var customerProviders: [() -> String] = []","func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {","    customerProviders.append(customerProvider)","}","collectCustomerProviders(customersInLine.remove(at: 0))","collectCustomerProviders(customersInLine.remove(at: 0))","","print(\"Collected \\(customerProviders.count) closures.\")","\/\/ Prints \"Collected 2 closures.\"","for customerProvider in customerProviders {","    print(\"Now serving \\(customerProvider())!\")","}","\/\/ Prints \"Now serving Barry!\"","\/\/ Prints \"Now serving Daniella!\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above,"},{"type":"text","text":" "},{"type":"text","text":"instead of calling the closure passed to it"},{"type":"text","text":" "},{"type":"text","text":"as its "},{"type":"codeVoice","code":"customerProvider"},{"type":"text","text":" argument,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"collectCustomerProviders(_:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"appends the closure to the "},{"type":"codeVoice","code":"customerProviders"},{"type":"text","text":" array."},{"type":"text","text":" "},{"type":"text","text":"The array is declared outside the scope of the function,"},{"type":"text","text":" "},{"type":"text","text":"which means the closures in the array can be executed after the function returns."},{"type":"text","text":" "},{"type":"text","text":"As a result,"},{"type":"text","text":" "},{"type":"text","text":"the value of the "},{"type":"codeVoice","code":"customerProvider"},{"type":"text","text":" argument"},{"type":"text","text":" "},{"type":"text","text":"must be allowed to escape the function’s scope."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/closures"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","interfaceLanguage":"swift"},"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closures"}]},{"type":"text","text":" are self-contained blocks of functionality"},{"type":"text","text":" "},{"type":"text","text":"that can be passed around and used in your code."},{"type":"text","text":" "},{"type":"text","text":"Closures in Swift are similar to blocks in C and Objective-C"},{"type":"text","text":" "},{"type":"text","text":"and to lambdas in other programming languages."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Closures","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Guide","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"],"generated":true}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"role":"article","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task."},{"type":"text","text":" "},{"type":"text","text":"You give a function a name that identifies what it does,"},{"type":"text","text":" "},{"type":"text","text":"and this name is used to “call” the function to perform its task when needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Extensions":{"role":"article","title":"Extensões","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensões"}]},{"type":"text","text":" adicionam novas funcionalidades a uma classe, estrutura, enumeração ou tipo de protocolo existente. Isso inclui a capacidade de estender tipos para os quais você não tem acesso ao código-fonte original (conhecido como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"modelagem retroativa"}]},{"type":"text","text":"). As extensões são semelhantes às categorias em Objective-C. (Ao contrário das categorias de Objective-C, as extensões Swift não têm nomes.)"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/extensions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Closure-Expression-Syntax":{"abstract":[],"title":"Closure Expression Syntax","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Closure-Expression-Syntax","url":"\/documentation\/the-swift-programming-language\/closures#Closure-Expression-Syntax"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics":{"role":"article","title":"O Básico","abstract":[{"type":"text","text":"Swift é uma linguagem de programação para desenvolvimento de aplicativos iOS, macOS, watchOS e tvOS. Se você tem experiência em desenvolvimento em C ou Objective-C, muitas partes do Swift serão familiares para você."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/thebasics"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols":{"role":"article","title":"Protocols","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol"}]},{"type":"text","text":" defines a blueprint of"},{"type":"text","text":" "},{"type":"text","text":"methods, properties, and other requirements"},{"type":"text","text":" "},{"type":"text","text":"that suit a particular task or piece of functionality."},{"type":"text","text":" "},{"type":"text","text":"The protocol can then be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"adopted"}]},{"type":"text","text":" by a class, structure, or enumeration"},{"type":"text","text":" "},{"type":"text","text":"to provide an actual implementation of those requirements."},{"type":"text","text":" "},{"type":"text","text":"Any type that satisfies the requirements of a protocol is said to"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conform"}]},{"type":"text","text":" to that protocol."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/protocols"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency":{"role":"article","title":"Concorrência","abstract":[{"type":"text","text":"Swift tem suporte por padrão para escrita de código assíncrono e paralelo"},{"type":"text","text":" "},{"type":"text","text":"de forma estruturada."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código assíncrono"}]},{"type":"text","text":" pode ser suspenso e retomado posteriormente,"},{"type":"text","text":" "},{"type":"text","text":"embora apenas uma parte do programa seja executada por vez."},{"type":"text","text":" "},{"type":"text","text":"Suspender e retomar código em seu programa"},{"type":"text","text":" "},{"type":"text","text":"permite que ele continue a progredir"},{"type":"text","text":" "},{"type":"text","text":"em operações de curto prazo, como atualizar a interface do usuário,"},{"type":"text","text":" "},{"type":"text","text":"enquanto continua a trabalhar em operações de longa duração"},{"type":"text","text":" "},{"type":"text","text":"como buscar dados pela rede ou analisar arquivos."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código paralelo"}]},{"type":"text","text":" significa vários pedaços de código executando simultaneamente —"},{"type":"text","text":" "},{"type":"text","text":"por exemplo, um computador com um processador de quatro núcleos"},{"type":"text","text":" "},{"type":"text","text":"pode executar quatro pedaços de código ao mesmo tempo,"},{"type":"text","text":" "},{"type":"text","text":"com cada núcleo realizando uma das tarefas."},{"type":"text","text":" "},{"type":"text","text":"Um programa que usa código paralelo e assíncrono"},{"type":"text","text":" "},{"type":"text","text":"realiza várias operações ao mesmo tempo;"},{"type":"text","text":" "},{"type":"text","text":"suspende as operações que estão à espera de um sistema externo,"},{"type":"text","text":" "},{"type":"text","text":"e torna mais fácil escrever esse código de maneira segura para a memória ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"memory-safe"}]},{"type":"text","text":")."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/concurrency"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Subscripts":{"role":"article","title":"Subscripts","abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscripts"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which are shortcuts for accessing the member elements of a collection, list, or sequence."},{"type":"text","text":" "},{"type":"text","text":"You use subscripts to set and retrieve values by index without needing"},{"type":"text","text":" "},{"type":"text","text":"separate methods for setting and retrieval."},{"type":"text","text":" "},{"type":"text","text":"For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" "},{"type":"text","text":"and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/subscripts"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"role":"article","title":"Error Handling","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Error handling"}]},{"type":"text","text":" is the process of responding to"},{"type":"text","text":" "},{"type":"text","text":"and recovering from error conditions in your program."},{"type":"text","text":" "},{"type":"text","text":"Swift provides first-class support for"},{"type":"text","text":" "},{"type":"text","text":"throwing, catching, propagating, and manipulating"},{"type":"text","text":" "},{"type":"text","text":"recoverable errors at runtime."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/errorhandling"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Properties":{"role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Properties"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration."},{"type":"text","text":" "},{"type":"text","text":"Stored properties store constant and variable values as part of an instance,"},{"type":"text","text":" "},{"type":"text","text":"whereas computed properties calculate (rather than store) a value."},{"type":"text","text":" "},{"type":"text","text":"Computed properties are provided by classes, structures, and enumerations."},{"type":"text","text":" "},{"type":"text","text":"Stored properties are provided only by classes and structures."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/properties"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"role":"article","title":"Type Casting","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance,"},{"type":"text","text":" "},{"type":"text","text":"or to treat that instance as a different"},{"type":"text","text":" "},{"type":"text","text":"superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures":{"role":"article","title":"Estruturas e Classes","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Estruturas"}]},{"type":"text","text":" e "},{"type":"emphasis","inlineContent":[{"type":"text","text":"classes"}]},{"type":"text","text":" são construções flexíveis de propósito geral que se tornam os blocos de construção do código do seu programa. Você define propriedades e métodos para adicionar funcionalidade às suas estruturas e classes usando a mesma sintaxe usada para definir constantes, variáveis e funções."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/classesandstructures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures":{"abstract":[],"title":"Strong Reference Cycles for Closures","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting#Strong-Reference-Cycles-for-Closures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Capturing-Values":{"abstract":[],"title":"Capturing Values","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Capturing-Values","url":"\/documentation\/the-swift-programming-language\/closures#Capturing-Values"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#Nested-Functions":{"abstract":[],"title":"Nested Functions","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Nested-Functions","url":"\/documentation\/the-swift-programming-language\/functions#Nested-Functions"},"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/NestedTypes":{"role":"article","title":"Tipos Aninhados","abstract":[{"type":"text","text":"Enumerações são frequentemente criadas para dar suporte a uma funcionalidade especifica de uma classe ou estrutura."},{"type":"text","text":" "},{"type":"text","text":"Similarmente, pode ser conveniente definir classes e estruturas de utilidade"},{"type":"text","text":" "},{"type":"text","text":"puramente para o uso dentro de um contexto de um tipo mais complexo."},{"type":"text","text":" "},{"type":"text","text":"Para fazer isso, o Swift permite que você defina "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos aninhados"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"nos quais você aninha enumerações, classes e estruturas de suporte"},{"type":"text","text":" "},{"type":"text","text":"dentro da definição do tipo que elas suportam."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/nestedtypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AccessControl":{"role":"article","title":"Access Control","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"type":"text","text":" restricts access to parts of your code"},{"type":"text","text":" "},{"type":"text","text":"from code in other source files and modules."},{"type":"text","text":" "},{"type":"text","text":"This feature enables you to hide the implementation details of your code,"},{"type":"text","text":" "},{"type":"text","text":"and to specify a preferred interface through which that code can be accessed and used."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/accesscontrol"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Enumerations":{"role":"article","title":"Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values"},{"type":"text","text":" "},{"type":"text","text":"and enables you to work with those values in a type-safe way within your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/enumerations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#Function-Types-as-Return-Types":{"abstract":[],"title":"Function Types as Return Types","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Function-Types-as-Return-Types","url":"\/documentation\/the-swift-programming-language\/functions#Function-Types-as-Return-Types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/MemorySafety":{"role":"article","title":"Memory Safety","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift ensures that variables are initialized before they’re used,"},{"type":"text","text":" "},{"type":"text","text":"memory isn’t accessed after it’s been deallocated,"},{"type":"text","text":" "},{"type":"text","text":"and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/memorysafety"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Methods":{"role":"article","title":"Methods","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Methods"}]},{"type":"text","text":" are functions that are associated with a particular type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can all define instance methods,"},{"type":"text","text":" "},{"type":"text","text":"which encapsulate specific tasks and functionality for working with an instance of a given type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can also define type methods,"},{"type":"text","text":" "},{"type":"text","text":"which are associated with the type itself."},{"type":"text","text":" "},{"type":"text","text":"Type methods are similar to class methods in Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Deinitialization":{"role":"article","title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"deinitializer"}]},{"type":"text","text":" is called immediately before a class instance is deallocated."},{"type":"text","text":" "},{"type":"text","text":"You write deinitializers with the "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"similar to how initializers are written with the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"Deinitializers are only available on class types."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/deinitialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#Operator-Methods":{"abstract":[],"title":"Operator Methods","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Operator-Methods","url":"\/documentation\/the-swift-programming-language\/advancedoperators#Operator-Methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow":{"role":"article","title":"Control Flow","abstract":[{"type":"text","text":"Swift provides a variety of control flow statements."},{"type":"text","text":" "},{"type":"text","text":"These include "},{"type":"codeVoice","code":"while"},{"type":"text","text":" loops to perform a task multiple times;"},{"type":"text","text":" "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", and "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statements"},{"type":"text","text":" "},{"type":"text","text":"to execute different branches of code based on certain conditions;"},{"type":"text","text":" "},{"type":"text","text":"and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" "},{"type":"text","text":"to transfer the flow of execution to another point in your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/controlflow"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance":{"role":"article","title":"Inheritance","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"type":"text","text":" methods, properties, and other characteristics"},{"type":"text","text":" "},{"type":"text","text":"from another class."},{"type":"text","text":" "},{"type":"text","text":"When one class inherits from another,"},{"type":"text","text":" "},{"type":"text","text":"the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Inheritance is a fundamental behavior that differentiates classes"},{"type":"text","text":" "},{"type":"text","text":"from other types in Swift."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/inheritance"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OptionalChaining":{"role":"article","title":"Optional Chaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling"},{"type":"text","text":" "},{"type":"text","text":"properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the optional contains a value,"},{"type":"text","text":" "},{"type":"text","text":"the property, method, or subscript call succeeds;"},{"type":"text","text":" "},{"type":"text","text":"if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Multiple queries can be chained together,"},{"type":"text","text":" "},{"type":"text","text":"and the entire chain fails gracefully if any link in the chain is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/optionalchaining"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/StringsAndCharacters":{"role":"article","title":"Strings e Characters","abstract":[{"type":"text","text":"Uma "},{"type":"emphasis","inlineContent":[{"type":"text","text":"string"}]},{"type":"text","text":" é uma série de caracteres,"},{"type":"text","text":" "},{"type":"text","text":"tal como "},{"type":"codeVoice","code":"\"olá, mundo\""},{"type":"text","text":" ou "},{"type":"codeVoice","code":"\"albatroz\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Strings em Swift são representadas pelo tipo "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"O conteúdo de uma "},{"type":"codeVoice","code":"String"},{"type":"text","text":" pode ser acessado de várias maneiras,"},{"type":"text","text":" "},{"type":"text","text":"incluindo como uma coleção de valores "},{"type":"codeVoice","code":"Character"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/stringsandcharacters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Escaping-Closures":{"abstract":[],"title":"Escaping Closures","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Escaping-Closures","url":"\/documentation\/the-swift-programming-language\/closures#Escaping-Closures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes":{"role":"article","title":"Opaque Types","abstract":[{"type":"text","text":"A function or method with an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"type":"text","text":"Instead of providing a concrete type as the function’s return type,"},{"type":"text","text":" "},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"type":"text","text":"Hiding type information"},{"type":"text","text":" "},{"type":"text","text":"is useful at boundaries between"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"type":"text","text":" "},{"type":"text","text":"because the underlying type of the return value can remain private."},{"type":"text","text":" "},{"type":"text","text":"Unlike returning a value whose type is a protocol type,"},{"type":"text","text":" "},{"type":"text","text":"opaque types preserve type identity —"},{"type":"text","text":" "},{"type":"text","text":"the compiler has access to the type information,"},{"type":"text","text":" "},{"type":"text","text":"but clients of the module don’t."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/opaquetypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"role":"article","title":"Operadores básicos","abstract":[{"type":"text","text":"Um operador é um símbolo ou frase que você pode usar para verificar, mudar ou combinar valores."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, o operador de adição ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") soma dois números,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"e o operador lógico E ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"AND"}]},{"type":"text","text":" - "},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combina dois valores booleanos,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/basicoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes":{"role":"article","title":"Tipos de Coleção","abstract":[{"type":"text","text":"Swift oferece três "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos de coleção"}]},{"type":"text","text":" primários, conhecidos como arrays, sets e dicionários, para armazenar coleções de valores. Arrays são coleções ordenadas de valores. Sets são coleções não ordenadas de valores únicos. Os dicionários são coleções não ordenadas de associações chave-valor."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/collectiontypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting":{"role":"article","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"type":"text","text":" (ARC)"},{"type":"text","text":" "},{"type":"text","text":"to track and manage your app’s memory usage."},{"type":"text","text":" "},{"type":"text","text":"In most cases, this means that memory management “just works” in Swift,"},{"type":"text","text":" "},{"type":"text","text":"and you don’t need to think about memory management yourself."},{"type":"text","text":" "},{"type":"text","text":"ARC automatically frees up the memory used by class instances"},{"type":"text","text":" "},{"type":"text","text":"when those instances are no longer needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators":{"role":"article","title":"Operadores Avançados","abstract":[{"type":"text","text":"Além dos operadores descritos no tópico "},{"type":"text","text":"doc:OperadoresBasicos"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"a linguagem Swift oferece o tópico Operadores Avançados que fazem manipulação de valores mais complexa."},{"type":"text","text":" "},{"type":"text","text":"Lá são incluídos operadores bit a bit e operadores com deslocamento que estamos familiarizados em C e Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/advancedoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization":{"role":"article","title":"Initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"type":"text","text":" is the process of preparing an instance of"},{"type":"text","text":" "},{"type":"text","text":"a class, structure, or enumeration for use."},{"type":"text","text":" "},{"type":"text","text":"This process involves setting an initial value for each stored property on that instance"},{"type":"text","text":" "},{"type":"text","text":"and performing any other setup or initialization that’s required"},{"type":"text","text":" "},{"type":"text","text":"before the new instance is ready for use."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"role":"article","title":"Generics","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types"},{"type":"text","text":" "},{"type":"text","text":"that can work with any type, subject to requirements that you define."},{"type":"text","text":" "},{"type":"text","text":"You can write code that avoids duplication"},{"type":"text","text":" "},{"type":"text","text":"and expresses its intent in a clear, abstracted manner."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics"}}}