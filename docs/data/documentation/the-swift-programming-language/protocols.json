{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition to specifying requirements that conforming types must implement,"},{"type":"text","text":" "},{"type":"text","text":"you can extend a protocol to implement some of these requirements"},{"type":"text","text":" "},{"type":"text","text":"or to implement additional functionality that conforming types can take advantage of."}]},{"anchor":"Protocol-Syntax","level":2,"type":"heading","text":"Protocol Syntax"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You define protocols in a very similar way to classes, structures, and enumerations:"}]},{"type":"codeListing","syntax":"swift","code":["protocol SomeProtocol {","   \/\/ protocol definition goes here","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Custom types state that they adopt a particular protocol"},{"type":"text","text":" "},{"type":"text","text":"by placing the protocol’s name after the type’s name,"},{"type":"text","text":" "},{"type":"text","text":"separated by a colon, as part of their definition."},{"type":"text","text":" "},{"type":"text","text":"Multiple protocols can be listed, and are separated by commas:"}]},{"type":"codeListing","syntax":"swift","code":["struct SomeStructure: FirstProtocol, AnotherProtocol {","   \/\/ structure definition goes here","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a class has a superclass, list the superclass name"},{"type":"text","text":" "},{"type":"text","text":"before any protocols it adopts, followed by a comma:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {","   \/\/ class definition goes here","}"]},{"anchor":"Property-Requirements","level":2,"type":"heading","text":"Property Requirements"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A protocol can require any conforming type to provide"},{"type":"text","text":" "},{"type":"text","text":"an instance property or type property with a particular name and type."},{"type":"text","text":" "},{"type":"text","text":"The protocol doesn’t specify whether the property should be"},{"type":"text","text":" "},{"type":"text","text":"a stored property or a computed property —"},{"type":"text","text":" "},{"type":"text","text":"it only specifies the required property name and type."},{"type":"text","text":" "},{"type":"text","text":"The protocol also specifies whether each property must be gettable"},{"type":"text","text":" "},{"type":"text","text":"or gettable "},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"type":"text","text":" settable."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a protocol requires a property to be gettable and settable,"},{"type":"text","text":" "},{"type":"text","text":"that property requirement can’t be fulfilled by"},{"type":"text","text":" "},{"type":"text","text":"a constant stored property or a read-only computed property."},{"type":"text","text":" "},{"type":"text","text":"If the protocol only requires a property to be gettable,"},{"type":"text","text":" "},{"type":"text","text":"the requirement can be satisfied by any kind of property,"},{"type":"text","text":" "},{"type":"text","text":"and it’s valid for the property to be also settable"},{"type":"text","text":" "},{"type":"text","text":"if this is useful for your own code."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Property requirements are always declared as variable properties,"},{"type":"text","text":" "},{"type":"text","text":"prefixed with the "},{"type":"codeVoice","code":"var"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"Gettable and settable properties are indicated by writing"},{"type":"text","text":" "},{"type":"codeVoice","code":"{ get set }"},{"type":"text","text":" after their type declaration,"},{"type":"text","text":" "},{"type":"text","text":"and gettable properties are indicated by writing "},{"type":"codeVoice","code":"{ get }"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["protocol SomeProtocol {","   var mustBeSettable: Int { get set }","   var doesNotNeedToBeSettable: Int { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Always prefix type property requirements with the "},{"type":"codeVoice","code":"static"},{"type":"text","text":" keyword"},{"type":"text","text":" "},{"type":"text","text":"when you define them in a protocol."},{"type":"text","text":" "},{"type":"text","text":"This rule pertains even though type property requirements can be prefixed with"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"class"},{"type":"text","text":" or "},{"type":"codeVoice","code":"static"},{"type":"text","text":" keyword when implemented by a class:"}]},{"type":"codeListing","syntax":"swift","code":["protocol AnotherProtocol {","   static var someTypeProperty: Int { get set }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a protocol with a single instance property requirement:"}]},{"type":"codeListing","syntax":"swift","code":["protocol FullyNamed {","   var fullName: String { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"FullyNamed"},{"type":"text","text":" protocol requires a conforming type to provide a fully qualified name."},{"type":"text","text":" "},{"type":"text","text":"The protocol doesn’t specify anything else about the nature of the conforming type —"},{"type":"text","text":" "},{"type":"text","text":"it only specifies that the type must be able to provide a full name for itself."},{"type":"text","text":" "},{"type":"text","text":"The protocol states that any "},{"type":"codeVoice","code":"FullyNamed"},{"type":"text","text":" type must have"},{"type":"text","text":" "},{"type":"text","text":"a gettable instance property called "},{"type":"codeVoice","code":"fullName"},{"type":"text","text":", which is of type "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a simple structure that adopts and conforms to"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"FullyNamed"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["struct Person: FullyNamed {","   var fullName: String","}","let john = Person(fullName: \"John Appleseed\")","\/\/ john.fullName is \"John Appleseed\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example defines a structure called "},{"type":"codeVoice","code":"Person"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which represents a specific named person."},{"type":"text","text":" "},{"type":"text","text":"It states that it adopts the "},{"type":"codeVoice","code":"FullyNamed"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"as part of the first line of its definition."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each instance of "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" has a single stored property called "},{"type":"codeVoice","code":"fullName"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which is of type "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This matches the single requirement of the "},{"type":"codeVoice","code":"FullyNamed"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"and means that "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" has correctly conformed to the protocol."},{"type":"text","text":" "},{"type":"text","text":"(Swift reports an error at compile time if a protocol requirement isn’t fulfilled.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a more complex class, which also adopts and conforms to the "},{"type":"codeVoice","code":"FullyNamed"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["class Starship: FullyNamed {","   var prefix: String?","   var name: String","   init(name: String, prefix: String? = nil) {","      self.name = name","      self.prefix = prefix","   }","   var fullName: String {","      return (prefix != nil ? prefix! + \" \" : \"\") + name","   }","}","var ncc1701 = Starship(name: \"Enterprise\", prefix: \"USS\")","\/\/ ncc1701.fullName is \"USS Enterprise\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This class implements the "},{"type":"codeVoice","code":"fullName"},{"type":"text","text":" property requirement as"},{"type":"text","text":" "},{"type":"text","text":"a computed read-only property for a starship."},{"type":"text","text":" "},{"type":"text","text":"Each "},{"type":"codeVoice","code":"Starship"},{"type":"text","text":" class instance stores a mandatory "},{"type":"codeVoice","code":"name"},{"type":"text","text":" and an optional "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"fullName"},{"type":"text","text":" property uses the "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":" value if it exists,"},{"type":"text","text":" "},{"type":"text","text":"and prepends it to the beginning of "},{"type":"codeVoice","code":"name"},{"type":"text","text":" to create a full name for the starship."}]},{"anchor":"Method-Requirements","level":2,"type":"heading","text":"Method Requirements"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocols can require specific instance methods and type methods"},{"type":"text","text":" "},{"type":"text","text":"to be implemented by conforming types."},{"type":"text","text":" "},{"type":"text","text":"These methods are written as part of the protocol’s definition"},{"type":"text","text":" "},{"type":"text","text":"in exactly the same way as for normal instance and type methods,"},{"type":"text","text":" "},{"type":"text","text":"but without curly braces or a method body."},{"type":"text","text":" "},{"type":"text","text":"Variadic parameters are allowed, subject to the same rules as for normal methods."},{"type":"text","text":" "},{"type":"text","text":"Default values, however, can’t be specified for method parameters within a protocol’s definition."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As with type property requirements,"},{"type":"text","text":" "},{"type":"text","text":"you always prefix type method requirements with the "},{"type":"codeVoice","code":"static"},{"type":"text","text":" keyword"},{"type":"text","text":" "},{"type":"text","text":"when they’re defined in a protocol."},{"type":"text","text":" "},{"type":"text","text":"This is true even though type method requirements are prefixed with"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"class"},{"type":"text","text":" or "},{"type":"codeVoice","code":"static"},{"type":"text","text":" keyword when implemented by a class:"}]},{"type":"codeListing","syntax":"swift","code":["protocol SomeProtocol {","   static func someTypeMethod()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example defines a protocol with a single instance method requirement:"}]},{"type":"codeListing","syntax":"swift","code":["protocol RandomNumberGenerator {","   func random() -> Double","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This protocol, "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":", requires any conforming type"},{"type":"text","text":" "},{"type":"text","text":"to have an instance method called "},{"type":"codeVoice","code":"random"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which returns a "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" value whenever it’s called."},{"type":"text","text":" "},{"type":"text","text":"Although it’s not specified as part of the protocol,"},{"type":"text","text":" "},{"type":"text","text":"it’s assumed that this value will be"},{"type":"text","text":" "},{"type":"text","text":"a number from "},{"type":"codeVoice","code":"0.0"},{"type":"text","text":" up to (but not including) "},{"type":"codeVoice","code":"1.0"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol doesn’t make any assumptions"},{"type":"text","text":" "},{"type":"text","text":"about how each random number will be generated —"},{"type":"text","text":" "},{"type":"text","text":"it simply requires the generator to provide a standard way"},{"type":"text","text":" "},{"type":"text","text":"to generate a new random number."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an implementation of a class that adopts and conforms to"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"This class implements a pseudorandom number generator algorithm known as"},{"type":"text","text":" "},{"type":"text","text":"a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"linear congruential generator"}]},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["class LinearCongruentialGenerator: RandomNumberGenerator {","   var lastRandom = 42.0","   let m = 139968.0","   let a = 3877.0","   let c = 29573.0","   func random() -> Double {","      lastRandom = ((lastRandom * a + c)","          .truncatingRemainder(dividingBy:m))","      return lastRandom \/ m","   }","}","let generator = LinearCongruentialGenerator()","print(\"Here's a random number: \\(generator.random())\")","\/\/ Prints \"Here's a random number: 0.3746499199817101\"","print(\"And another one: \\(generator.random())\")","\/\/ Prints \"And another one: 0.729023776863283\""]},{"anchor":"Mutating-Method-Requirements","level":2,"type":"heading","text":"Mutating Method Requirements"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s sometimes necessary for a method to modify (or "},{"type":"emphasis","inlineContent":[{"type":"text","text":"mutate"}]},{"type":"text","text":") the instance it belongs to."},{"type":"text","text":" "},{"type":"text","text":"For instance methods on value types (that is, structures and enumerations)"},{"type":"text","text":" "},{"type":"text","text":"you place the "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" keyword before a method’s "},{"type":"codeVoice","code":"func"},{"type":"text","text":" keyword"},{"type":"text","text":" "},{"type":"text","text":"to indicate that the method is allowed to modify the instance it belongs to"},{"type":"text","text":" "},{"type":"text","text":"and any properties of that instance."},{"type":"text","text":" "},{"type":"text","text":"This process is described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods#Modifying-Value-Types-from-Within-Instance-Methods"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you define a protocol instance method requirement"},{"type":"text","text":" "},{"type":"text","text":"that’s intended to mutate instances of any type that adopts the protocol,"},{"type":"text","text":" "},{"type":"text","text":"mark the method with the "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" keyword"},{"type":"text","text":" "},{"type":"text","text":"as part of the protocol’s definition."},{"type":"text","text":" "},{"type":"text","text":"This enables structures and enumerations to adopt the protocol"},{"type":"text","text":" "},{"type":"text","text":"and satisfy that method requirement."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you mark a protocol instance method requirement as "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"you don’t need to write the "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" keyword when writing"},{"type":"text","text":" "},{"type":"text","text":"an implementation of that method for a class."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" keyword is only used by structures and enumerations."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below defines a protocol called "},{"type":"codeVoice","code":"Togglable"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which defines a single instance method requirement called "},{"type":"codeVoice","code":"toggle"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"As its name suggests, the "},{"type":"codeVoice","code":"toggle()"},{"type":"text","text":" method is intended to"},{"type":"text","text":" "},{"type":"text","text":"toggle or invert the state of any conforming type,"},{"type":"text","text":" "},{"type":"text","text":"typically by modifying a property of that type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"toggle()"},{"type":"text","text":" method is marked with the "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" keyword"},{"type":"text","text":" "},{"type":"text","text":"as part of the "},{"type":"codeVoice","code":"Togglable"},{"type":"text","text":" protocol definition,"},{"type":"text","text":" "},{"type":"text","text":"to indicate that the method is expected to mutate the state of a conforming instance"},{"type":"text","text":" "},{"type":"text","text":"when it’s called:"}]},{"type":"codeListing","syntax":"swift","code":["protocol Togglable {","   mutating func toggle()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you implement the "},{"type":"codeVoice","code":"Togglable"},{"type":"text","text":" protocol for a structure or enumeration,"},{"type":"text","text":" "},{"type":"text","text":"that structure or enumeration can conform to the protocol"},{"type":"text","text":" "},{"type":"text","text":"by providing an implementation of the "},{"type":"codeVoice","code":"toggle()"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"that’s also marked as "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below defines an enumeration called "},{"type":"codeVoice","code":"OnOffSwitch"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This enumeration toggles between two states,"},{"type":"text","text":" "},{"type":"text","text":"indicated by the enumeration cases "},{"type":"codeVoice","code":"on"},{"type":"text","text":" and "},{"type":"codeVoice","code":"off"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The enumeration’s "},{"type":"codeVoice","code":"toggle"},{"type":"text","text":" implementation is marked as "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"to match the "},{"type":"codeVoice","code":"Togglable"},{"type":"text","text":" protocol’s requirements:"}]},{"type":"codeListing","syntax":"swift","code":["enum OnOffSwitch: Togglable {","   case off, on","   mutating func toggle() {","      switch self {","         case .off:","            self = .on","         case .on:","            self = .off","      }","   }","}","var lightSwitch = OnOffSwitch.off","lightSwitch.toggle()","\/\/ lightSwitch is now equal to .on"]},{"anchor":"Initializer-Requirements","level":2,"type":"heading","text":"Initializer Requirements"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocols can require specific initializers"},{"type":"text","text":" "},{"type":"text","text":"to be implemented by conforming types."},{"type":"text","text":" "},{"type":"text","text":"You write these initializers as part of the protocol’s definition"},{"type":"text","text":" "},{"type":"text","text":"in exactly the same way as for normal initializers,"},{"type":"text","text":" "},{"type":"text","text":"but without curly braces or an initializer body:"}]},{"type":"codeListing","syntax":"swift","code":["protocol SomeProtocol {","   init(someParameter: Int)","}"]},{"anchor":"Class-Implementations-of-Protocol-Initializer-Requirements","level":3,"type":"heading","text":"Class Implementations of Protocol Initializer Requirements"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can implement a protocol initializer requirement on a conforming class"},{"type":"text","text":" "},{"type":"text","text":"as either a designated initializer or a convenience initializer."},{"type":"text","text":" "},{"type":"text","text":"In both cases,"},{"type":"text","text":" "},{"type":"text","text":"you must mark the initializer implementation with the "},{"type":"codeVoice","code":"required"},{"type":"text","text":" modifier:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass: SomeProtocol {","   required init(someParameter: Int) {","      \/\/ initializer implementation goes here","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The use of the "},{"type":"codeVoice","code":"required"},{"type":"text","text":" modifier ensures that"},{"type":"text","text":" "},{"type":"text","text":"you provide an explicit or inherited implementation of the initializer requirement"},{"type":"text","text":" "},{"type":"text","text":"on all subclasses of the conforming class,"},{"type":"text","text":" "},{"type":"text","text":"such that they also conform to the protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information on required initializers,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Required-Initializers"},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You don’t need to mark protocol initializer implementations with the "},{"type":"codeVoice","code":"required"},{"type":"text","text":" modifier"},{"type":"text","text":" "},{"type":"text","text":"on classes that are marked with the "},{"type":"codeVoice","code":"final"},{"type":"text","text":" modifier,"},{"type":"text","text":" "},{"type":"text","text":"because final classes can’t subclassed."},{"type":"text","text":" "},{"type":"text","text":"For more about the "},{"type":"codeVoice","code":"final"},{"type":"text","text":" modifier, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance#Preventing-Overrides"},{"type":"text","text":"."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a subclass overrides a designated initializer from a superclass,"},{"type":"text","text":" "},{"type":"text","text":"and also implements a matching initializer requirement from a protocol,"},{"type":"text","text":" "},{"type":"text","text":"mark the initializer implementation with both the "},{"type":"codeVoice","code":"required"},{"type":"text","text":" and "},{"type":"codeVoice","code":"override"},{"type":"text","text":" modifiers:"}]},{"type":"codeListing","syntax":"swift","code":["protocol SomeProtocol {","   init()","}","","class SomeSuperClass {","   init() {","      \/\/ initializer implementation goes here","   }","}","","class SomeSubClass: SomeSuperClass, SomeProtocol {","   \/\/ \"required\" from SomeProtocol conformance; \"override\" from SomeSuperClass","   required override init() {","      \/\/ initializer implementation goes here","   }","}"]},{"anchor":"Failable-Initializer-Requirements","level":3,"type":"heading","text":"Failable Initializer Requirements"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocols can define failable initializer requirements for conforming types,"},{"type":"text","text":" "},{"type":"text","text":"as defined in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Failable-Initializers"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A failable initializer requirement can be satisfied by"},{"type":"text","text":" "},{"type":"text","text":"a failable or nonfailable initializer on a conforming type."},{"type":"text","text":" "},{"type":"text","text":"A nonfailable initializer requirement can be satisfied by"},{"type":"text","text":" "},{"type":"text","text":"a nonfailable initializer or an implicitly unwrapped failable initializer."}]},{"anchor":"Protocols-as-Types","level":2,"type":"heading","text":"Protocols as Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocols don’t actually implement any functionality themselves."},{"type":"text","text":" "},{"type":"text","text":"Nonetheless,"},{"type":"text","text":" "},{"type":"text","text":"you can use protocols as a fully fledged types in your code."},{"type":"text","text":" "},{"type":"text","text":"Using a protocol as a type is sometimes called an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"existential type"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which comes from the phrase"},{"type":"text","text":" "},{"type":"text","text":"“there exists a type "},{"type":"emphasis","inlineContent":[{"type":"text","text":"T"}]},{"type":"text","text":" such that "},{"type":"emphasis","inlineContent":[{"type":"text","text":"T"}]},{"type":"text","text":" conforms to the protocol”."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use a protocol in many places where other types are allowed, including:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As a parameter type or return type in a function, method, or initializer"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As the type of a constant, variable, or property"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As the type of items in an array, dictionary, or other container"}]}]}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Because protocols are types,"},{"type":"text","text":" "},{"type":"text","text":"begin their names with a capital letter"},{"type":"text","text":" "},{"type":"text","text":"(such as "},{"type":"codeVoice","code":"FullyNamed"},{"type":"text","text":" and "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"to match the names of other types in Swift"},{"type":"text","text":" "},{"type":"text","text":"(such as "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", "},{"type":"codeVoice","code":"String"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Double"},{"type":"text","text":")."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a protocol used as a type:"}]},{"type":"codeListing","syntax":"swift","code":["class Dice {","   let sides: Int","   let generator: RandomNumberGenerator","   init(sides: Int, generator: RandomNumberGenerator) {","      self.sides = sides","      self.generator = generator","   }","   func roll() -> Int {","      return Int(generator.random() * Double(sides)) + 1","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example defines a new class called "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which represents an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"n"}]},{"type":"text","text":"-sided dice for use in a board game."},{"type":"text","text":" "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" instances have an integer property called "},{"type":"codeVoice","code":"sides"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which represents how many sides they have,"},{"type":"text","text":" "},{"type":"text","text":"and a property called "},{"type":"codeVoice","code":"generator"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which provides a random number generator"},{"type":"text","text":" "},{"type":"text","text":"from which to create dice roll values."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"generator"},{"type":"text","text":" property is of type "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Therefore, you can set it to an instance of"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"type":"text","text":" type that adopts the "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"Nothing else is required of the instance you assign to this property,"},{"type":"text","text":" "},{"type":"text","text":"except that the instance must adopt the "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"Because its type is "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"code inside the "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" class can only interact with "},{"type":"codeVoice","code":"generator"},{"type":"text","text":" "},{"type":"text","text":"in ways that apply to all generators that conform to this protocol."},{"type":"text","text":" "},{"type":"text","text":"That means it can’t use any methods or properties"},{"type":"text","text":" "},{"type":"text","text":"that are defined by the underlying type of the generator."},{"type":"text","text":" "},{"type":"text","text":"However, you can downcast from a protocol type to an underlying type"},{"type":"text","text":" "},{"type":"text","text":"in the same way you can downcast from a superclass to a subclass,"},{"type":"text","text":" "},{"type":"text","text":"as discussed in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Dice"},{"type":"text","text":" also has an initializer, to set up its initial state."},{"type":"text","text":" "},{"type":"text","text":"This initializer has a parameter called "},{"type":"codeVoice","code":"generator"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which is also of type "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"You can pass a value of any conforming type in to this parameter"},{"type":"text","text":" "},{"type":"text","text":"when initializing a new "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" instance."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Dice"},{"type":"text","text":" provides one instance method, "},{"type":"codeVoice","code":"roll"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which returns an integer value between 1 and the number of sides on the dice."},{"type":"text","text":" "},{"type":"text","text":"This method calls the generator’s "},{"type":"codeVoice","code":"random()"},{"type":"text","text":" method to create"},{"type":"text","text":" "},{"type":"text","text":"a new random number between "},{"type":"codeVoice","code":"0.0"},{"type":"text","text":" and "},{"type":"codeVoice","code":"1.0"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and uses this random number to create a dice roll value within the correct range."},{"type":"text","text":" "},{"type":"text","text":"Because "},{"type":"codeVoice","code":"generator"},{"type":"text","text":" is known to adopt "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"it’s guaranteed to have a "},{"type":"codeVoice","code":"random()"},{"type":"text","text":" method to call."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how the "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" class can be used to create a six-sided dice"},{"type":"text","text":" "},{"type":"text","text":"with a "},{"type":"codeVoice","code":"LinearCongruentialGenerator"},{"type":"text","text":" instance as its random number generator:"}]},{"type":"codeListing","syntax":"swift","code":["var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())","for _ in 1...5 {","   print(\"Random dice roll is \\(d6.roll())\")","}","\/\/ Random dice roll is 3","\/\/ Random dice roll is 5","\/\/ Random dice roll is 4","\/\/ Random dice roll is 5","\/\/ Random dice roll is 4"]},{"anchor":"Delegation","level":2,"type":"heading","text":"Delegation"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Delegation"}]},{"type":"text","text":" is a design pattern that enables"},{"type":"text","text":" "},{"type":"text","text":"a class or structure to hand off (or "},{"type":"emphasis","inlineContent":[{"type":"text","text":"delegate"}]},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"some of its responsibilities to an instance of another type."},{"type":"text","text":" "},{"type":"text","text":"This design pattern is implemented by defining"},{"type":"text","text":" "},{"type":"text","text":"a protocol that encapsulates the delegated responsibilities,"},{"type":"text","text":" "},{"type":"text","text":"such that a conforming type (known as a delegate)"},{"type":"text","text":" "},{"type":"text","text":"is guaranteed to provide the functionality that has been delegated."},{"type":"text","text":" "},{"type":"text","text":"Delegation can be used to respond to a particular action,"},{"type":"text","text":" "},{"type":"text","text":"or to retrieve data from an external source without needing to know"},{"type":"text","text":" "},{"type":"text","text":"the underlying type of that source."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below defines two protocols for use with dice-based board games:"}]},{"type":"codeListing","syntax":"swift","code":["protocol DiceGame {","   var dice: Dice { get }","   func play()","}","protocol DiceGameDelegate: AnyObject {","   func gameDidStart(_ game: DiceGame)","   func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)","   func gameDidEnd(_ game: DiceGame)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":" protocol is a protocol that can be adopted"},{"type":"text","text":" "},{"type":"text","text":"by any game that involves dice."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":" protocol can be adopted"},{"type":"text","text":" "},{"type":"text","text":"to track the progress of a "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"To prevent strong reference cycles,"},{"type":"text","text":" "},{"type":"text","text":"delegates are declared as weak references."},{"type":"text","text":" "},{"type":"text","text":"For information about weak references,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Strong-Reference-Cycles-Between-Class-Instances"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Marking the protocol as class-only"},{"type":"text","text":" "},{"type":"text","text":"lets the "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" class later in this chapter"},{"type":"text","text":" "},{"type":"text","text":"declare that its delegate must use a weak reference."},{"type":"text","text":" "},{"type":"text","text":"A class-only protocol"},{"type":"text","text":" "},{"type":"text","text":"is marked by its inheritance from "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"as discussed in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Class-Only-Protocols"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a version of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Snakes and Ladders"}]},{"type":"text","text":" game originally introduced in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This version is adapted to use a "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" instance for its dice-rolls;"},{"type":"text","text":" "},{"type":"text","text":"to adopt the "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":" protocol;"},{"type":"text","text":" "},{"type":"text","text":"and to notify a "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":" about its progress:"}]},{"type":"codeListing","syntax":"swift","code":["class SnakesAndLadders: DiceGame {","   let finalSquare = 25","   let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())","   var square = 0","   var board: [Int]","   init() {","      board = Array(repeating: 0, count: finalSquare + 1)","      board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02","      board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08","   }","   weak var delegate: DiceGameDelegate?","   func play() {","      square = 0","      delegate?.gameDidStart(self)","      gameLoop: while square != finalSquare {","         let diceRoll = dice.roll()","         delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)","         switch square + diceRoll {","            case finalSquare:","               break gameLoop","            case let newSquare where newSquare > finalSquare:","               continue gameLoop","            default:","               square += diceRoll","               square += board[square]","         }","      }","      delegate?.gameDidEnd(self)","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For a description of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Snakes and Ladders"}]},{"type":"text","text":" gameplay,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow#Break"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This version of the game is wrapped up as a class called "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which adopts the "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"It provides a gettable "},{"type":"codeVoice","code":"dice"},{"type":"text","text":" property and a "},{"type":"codeVoice","code":"play()"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"in order to conform to the protocol."},{"type":"text","text":" "},{"type":"text","text":"(The "},{"type":"codeVoice","code":"dice"},{"type":"text","text":" property is declared as a constant property"},{"type":"text","text":" "},{"type":"text","text":"because it doesn’t need to change after initialization,"},{"type":"text","text":" "},{"type":"text","text":"and the protocol only requires that it must be gettable.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Snakes and Ladders"}]},{"type":"text","text":" game board setup takes place within"},{"type":"text","text":" "},{"type":"text","text":"the class’s "},{"type":"codeVoice","code":"init()"},{"type":"text","text":" initializer."},{"type":"text","text":" "},{"type":"text","text":"All game logic is moved into the protocol’s "},{"type":"codeVoice","code":"play"},{"type":"text","text":" method,"},{"type":"text","text":" "},{"type":"text","text":"which uses the protocol’s required "},{"type":"codeVoice","code":"dice"},{"type":"text","text":" property to provide its dice roll values."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is defined as an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"because a delegate isn’t required in order to play the game."},{"type":"text","text":" "},{"type":"text","text":"Because it’s of an optional type,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is automatically set to an initial value of "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Thereafter, the game instantiator has the option to set the property to a suitable delegate."},{"type":"text","text":" "},{"type":"text","text":"Because the "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":" protocol is class-only, you can declare the"},{"type":"text","text":" "},{"type":"text","text":"delegate to be "},{"type":"codeVoice","code":"weak"},{"type":"text","text":" to prevent reference cycles."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":" provides three methods for tracking the progress of a game."},{"type":"text","text":" "},{"type":"text","text":"These three methods have been incorporated into the game logic within"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"play()"},{"type":"text","text":" method above, and are called when"},{"type":"text","text":" "},{"type":"text","text":"a new game starts, a new turn begins, or the game ends."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"play()"},{"type":"text","text":" method uses optional chaining each time it calls a method on the delegate."},{"type":"text","text":" "},{"type":"text","text":"If the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is nil,"},{"type":"text","text":" "},{"type":"text","text":"these delegate calls fail gracefully and without error."},{"type":"text","text":" "},{"type":"text","text":"If the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is non-nil,"},{"type":"text","text":" "},{"type":"text","text":"the delegate methods are called,"},{"type":"text","text":" "},{"type":"text","text":"and are passed the "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" instance as a parameter."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This next example shows a class called "},{"type":"codeVoice","code":"DiceGameTracker"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which adopts the "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["class DiceGameTracker: DiceGameDelegate {","   var numberOfTurns = 0","   func gameDidStart(_ game: DiceGame) {","      numberOfTurns = 0","      if game is SnakesAndLadders {","         print(\"Started a new game of Snakes and Ladders\")","      }","      print(\"The game is using a \\(game.dice.sides)-sided dice\")","   }","   func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {","      numberOfTurns += 1","      print(\"Rolled a \\(diceRoll)\")","   }","   func gameDidEnd(_ game: DiceGame) {","      print(\"The game lasted for \\(numberOfTurns) turns\")","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"DiceGameTracker"},{"type":"text","text":" implements all three methods required by "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"It uses these methods to keep track of the number of turns a game has taken."},{"type":"text","text":" "},{"type":"text","text":"It resets a "},{"type":"codeVoice","code":"numberOfTurns"},{"type":"text","text":" property to zero when the game starts,"},{"type":"text","text":" "},{"type":"text","text":"increments it each time a new turn begins,"},{"type":"text","text":" "},{"type":"text","text":"and prints out the total number of turns once the game has ended."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The implementation of "},{"type":"codeVoice","code":"gameDidStart(_:)"},{"type":"text","text":" shown above uses the "},{"type":"codeVoice","code":"game"},{"type":"text","text":" parameter"},{"type":"text","text":" "},{"type":"text","text":"to print some introductory information about the game that’s about to be played."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"game"},{"type":"text","text":" parameter has a type of "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":", not "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and so "},{"type":"codeVoice","code":"gameDidStart(_:)"},{"type":"text","text":" can access and use only methods and properties that"},{"type":"text","text":" "},{"type":"text","text":"are implemented as part of the "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"However, the method is still able to use type casting to"},{"type":"text","text":" "},{"type":"text","text":"query the type of the underlying instance."},{"type":"text","text":" "},{"type":"text","text":"In this example, it checks whether "},{"type":"codeVoice","code":"game"},{"type":"text","text":" is actually"},{"type":"text","text":" "},{"type":"text","text":"an instance of "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" behind the scenes,"},{"type":"text","text":" "},{"type":"text","text":"and prints an appropriate message if so."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"gameDidStart(_:)"},{"type":"text","text":" method also accesses the "},{"type":"codeVoice","code":"dice"},{"type":"text","text":" property of the passed "},{"type":"codeVoice","code":"game"},{"type":"text","text":" parameter."},{"type":"text","text":" "},{"type":"text","text":"Because "},{"type":"codeVoice","code":"game"},{"type":"text","text":" is known to conform to the "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"it’s guaranteed to have a "},{"type":"codeVoice","code":"dice"},{"type":"text","text":" property,"},{"type":"text","text":" "},{"type":"text","text":"and so the "},{"type":"codeVoice","code":"gameDidStart(_:)"},{"type":"text","text":" method is able to access and print the dice’s "},{"type":"codeVoice","code":"sides"},{"type":"text","text":" property,"},{"type":"text","text":" "},{"type":"text","text":"regardless of what kind of game is being played."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how "},{"type":"codeVoice","code":"DiceGameTracker"},{"type":"text","text":" looks in action:"}]},{"type":"codeListing","syntax":"swift","code":["let tracker = DiceGameTracker()","let game = SnakesAndLadders()","game.delegate = tracker","game.play()","\/\/ Started a new game of Snakes and Ladders","\/\/ The game is using a 6-sided dice","\/\/ Rolled a 3","\/\/ Rolled a 5","\/\/ Rolled a 4","\/\/ Rolled a 5","\/\/ The game lasted for 4 turns"]},{"anchor":"Adding-Protocol-Conformance-with-an-Extension","level":2,"type":"heading","text":"Adding Protocol Conformance with an Extension"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can extend an existing type to adopt and conform to a new protocol,"},{"type":"text","text":" "},{"type":"text","text":"even if you don’t have access to the source code for the existing type."},{"type":"text","text":" "},{"type":"text","text":"Extensions can add new properties, methods, and subscripts to an existing type,"},{"type":"text","text":" "},{"type":"text","text":"and are therefore able to add any requirements that a protocol may demand."},{"type":"text","text":" "},{"type":"text","text":"For more about extensions, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions"},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Existing instances of a type automatically adopt and conform to a protocol"},{"type":"text","text":" "},{"type":"text","text":"when that conformance is added to the instance’s type in an extension."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, this protocol, called "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":", can be implemented by"},{"type":"text","text":" "},{"type":"text","text":"any type that has a way to be represented as text."},{"type":"text","text":" "},{"type":"text","text":"This might be a description of itself, or a text version of its current state:"}]},{"type":"codeListing","syntax":"swift","code":["protocol TextRepresentable {","   var textualDescription: String { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" class from above can be extended to adopt and conform to "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["extension Dice: TextRepresentable {","   var textualDescription: String {","      return \"A \\(sides)-sided dice\"","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This extension adopts the new protocol in exactly the same way"},{"type":"text","text":" "},{"type":"text","text":"as if "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" had provided it in its original implementation."},{"type":"text","text":" "},{"type":"text","text":"The protocol name is provided after the type name, separated by a colon,"},{"type":"text","text":" "},{"type":"text","text":"and an implementation of all requirements of the protocol"},{"type":"text","text":" "},{"type":"text","text":"is provided within the extension’s curly braces."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" instance can now be treated as "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())","print(d12.textualDescription)","\/\/ Prints \"A 12-sided dice\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Similarly, the "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" game class can be extended to"},{"type":"text","text":" "},{"type":"text","text":"adopt and conform to the "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["extension SnakesAndLadders: TextRepresentable {","   var textualDescription: String {","      return \"A game of Snakes and Ladders with \\(finalSquare) squares\"","   }","}","print(game.textualDescription)","\/\/ Prints \"A game of Snakes and Ladders with 25 squares\""]},{"anchor":"Conditionally-Conforming-to-a-Protocol","level":3,"type":"heading","text":"Conditionally Conforming to a Protocol"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A generic type may be able to satisfy the requirements of a protocol"},{"type":"text","text":" "},{"type":"text","text":"only under certain conditions,"},{"type":"text","text":" "},{"type":"text","text":"such as when the type’s generic parameter conforms to the protocol."},{"type":"text","text":" "},{"type":"text","text":"You can make a generic type conditionally conform to a protocol"},{"type":"text","text":" "},{"type":"text","text":"by listing constraints when extending the type."},{"type":"text","text":" "},{"type":"text","text":"Write these constraints after the name of the protocol you’re adopting"},{"type":"text","text":" "},{"type":"text","text":"by writing a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause."},{"type":"text","text":" "},{"type":"text","text":"For more about generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Where-Clauses"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following extension"},{"type":"text","text":" "},{"type":"text","text":"makes "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instances conform to the "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"whenever they store elements of a type that conforms to "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["extension Array: TextRepresentable where Element: TextRepresentable {","   var textualDescription: String {","      let itemsAsText = self.map { $0.textualDescription }","      return \"[\" + itemsAsText.joined(separator: \", \") + \"]\"","   }","}","let myDice = [d6, d12]","print(myDice.textualDescription)","\/\/ Prints \"[A 6-sided dice, A 12-sided dice]\""]},{"anchor":"Declaring-Protocol-Adoption-with-an-Extension","level":3,"type":"heading","text":"Declaring Protocol Adoption with an Extension"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a type already conforms to all of the requirements of a protocol,"},{"type":"text","text":" "},{"type":"text","text":"but hasn’t yet stated that it adopts that protocol,"},{"type":"text","text":" "},{"type":"text","text":"you can make it adopt the protocol with an empty extension:"}]},{"type":"codeListing","syntax":"swift","code":["struct Hamster {","   var name: String","   var textualDescription: String {","      return \"A hamster named \\(name)\"","   }","}","extension Hamster: TextRepresentable {}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instances of "},{"type":"codeVoice","code":"Hamster"},{"type":"text","text":" can now be used wherever "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" is the required type:"}]},{"type":"codeListing","syntax":"swift","code":["let simonTheHamster = Hamster(name: \"Simon\")","let somethingTextRepresentable: TextRepresentable = simonTheHamster","print(somethingTextRepresentable.textualDescription)","\/\/ Prints \"A hamster named Simon\""]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Types don’t automatically adopt a protocol just by satisfying its requirements."},{"type":"text","text":" "},{"type":"text","text":"They must always explicitly declare their adoption of the protocol."}]}],"type":"aside","name":"Note"},{"anchor":"Adopting-a-Protocol-Using-a-Synthesized-Implementation","level":2,"type":"heading","text":"Adopting a Protocol Using a Synthesized Implementation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift can automatically provide the protocol conformance"},{"type":"text","text":" "},{"type":"text","text":"for "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":", "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" "},{"type":"text","text":"in many simple cases."},{"type":"text","text":" "},{"type":"text","text":"Using this synthesized implementation"},{"type":"text","text":" "},{"type":"text","text":"means you don’t have to write repetitive boilerplate code"},{"type":"text","text":" "},{"type":"text","text":"to implement the protocol requirements yourself."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift provides a synthesized implementation of "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" "},{"type":"text","text":"for the following kinds of custom types:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Structures that have only stored properties that conform to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Enumerations that have only associated types that conform to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Enumerations that have no associated types"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To receive a synthesized implementation of "},{"type":"codeVoice","code":"=="},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"declare conformance to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" "},{"type":"text","text":"in the file that contains the original declaration,"},{"type":"text","text":" "},{"type":"text","text":"without implementing an "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator yourself."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol provides a default implementation of "},{"type":"codeVoice","code":"!="},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below defines a "},{"type":"codeVoice","code":"Vector3D"},{"type":"text","text":" structure"},{"type":"text","text":" "},{"type":"text","text":"for a three-dimensional position vector "},{"type":"codeVoice","code":"(x, y, z)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"similar to the "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" structure."},{"type":"text","text":" "},{"type":"text","text":"Because the "},{"type":"codeVoice","code":"x"},{"type":"text","text":", "},{"type":"codeVoice","code":"y"},{"type":"text","text":", and "},{"type":"codeVoice","code":"z"},{"type":"text","text":" properties are all of an "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" type,"},{"type":"text","text":" "},{"type":"codeVoice","code":"Vector3D"},{"type":"text","text":" receives synthesized implementations"},{"type":"text","text":" "},{"type":"text","text":"of the equivalence operators."}]},{"type":"codeListing","syntax":"swift","code":["struct Vector3D: Equatable {","   var x = 0.0, y = 0.0, z = 0.0","}","","let twoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)","let anotherTwoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)","if twoThreeFour == anotherTwoThreeFour {","    print(\"These two vectors are also equivalent.\")","}","\/\/ Prints \"These two vectors are also equivalent.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift provides a synthesized implementation of "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" "},{"type":"text","text":"for the following kinds of custom types:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Structures that have only stored properties that conform to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Enumerations that have only associated types that conform to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Enumerations that have no associated types"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To receive a synthesized implementation of "},{"type":"codeVoice","code":"hash(into:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"declare conformance to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" "},{"type":"text","text":"in the file that contains the original declaration,"},{"type":"text","text":" "},{"type":"text","text":"without implementing a "},{"type":"codeVoice","code":"hash(into:)"},{"type":"text","text":" method yourself."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift provides a synthesized implementation of "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" "},{"type":"text","text":"for enumerations that don’t have a raw value."},{"type":"text","text":" "},{"type":"text","text":"If the enumeration has associated types,"},{"type":"text","text":" "},{"type":"text","text":"they must all conform to the "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"To receive a synthesized implementation of "},{"type":"codeVoice","code":"<"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"declare conformance to "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" "},{"type":"text","text":"in the file that contains the original enumeration declaration,"},{"type":"text","text":" "},{"type":"text","text":"without implementing a "},{"type":"codeVoice","code":"<"},{"type":"text","text":" operator yourself."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" protocol’s default implementation"},{"type":"text","text":" "},{"type":"text","text":"of "},{"type":"codeVoice","code":"<="},{"type":"text","text":", "},{"type":"codeVoice","code":">"},{"type":"text","text":", and "},{"type":"codeVoice","code":">="},{"type":"text","text":" provides the remaining comparison operators."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below defines a "},{"type":"codeVoice","code":"SkillLevel"},{"type":"text","text":" enumeration"},{"type":"text","text":" "},{"type":"text","text":"with cases for beginners, intermediates, and experts."},{"type":"text","text":" "},{"type":"text","text":"Experts are additionally ranked by the number of stars they have."}]},{"type":"codeListing","syntax":"swift","code":["enum SkillLevel: Comparable {","    case beginner","    case intermediate","    case expert(stars: Int)","}","var levels = [SkillLevel.intermediate, SkillLevel.beginner,","              SkillLevel.expert(stars: 5), SkillLevel.expert(stars: 3)]","for level in levels.sorted() {","    print(level)","}","\/\/ Prints \"beginner\"","\/\/ Prints \"intermediate\"","\/\/ Prints \"expert(stars: 3)\"","\/\/ Prints \"expert(stars: 5)\""]},{"anchor":"Collections-of-Protocol-Types","level":2,"type":"heading","text":"Collections of Protocol Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A protocol can be used as the type to be stored in"},{"type":"text","text":" "},{"type":"text","text":"a collection such as an array or a dictionary,"},{"type":"text","text":" "},{"type":"text","text":"as mentioned in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Protocols-as-Types"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This example creates an array of "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" things:"}]},{"type":"codeListing","syntax":"swift","code":["let things: [TextRepresentable] = [game, d12, simonTheHamster]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s now possible to iterate over the items in the array,"},{"type":"text","text":" "},{"type":"text","text":"and print each item’s textual description:"}]},{"type":"codeListing","syntax":"swift","code":["for thing in things {","   print(thing.textualDescription)","}","\/\/ A game of Snakes and Ladders with 25 squares","\/\/ A 12-sided dice","\/\/ A hamster named Simon"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the "},{"type":"codeVoice","code":"thing"},{"type":"text","text":" constant is of type "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"It’s not of type "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":", or "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":", or "},{"type":"codeVoice","code":"Hamster"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"even if the actual instance behind the scenes is of one of those types."},{"type":"text","text":" "},{"type":"text","text":"Nonetheless, because it’s of type "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and anything that’s "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" is known to have a "},{"type":"codeVoice","code":"textualDescription"},{"type":"text","text":" property,"},{"type":"text","text":" "},{"type":"text","text":"it’s safe to access "},{"type":"codeVoice","code":"thing.textualDescription"},{"type":"text","text":" each time through the loop."}]},{"anchor":"Protocol-Inheritance","level":2,"type":"heading","text":"Protocol Inheritance"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A protocol can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"type":"text","text":" one or more other protocols"},{"type":"text","text":" "},{"type":"text","text":"and can add further requirements on top of the requirements it inherits."},{"type":"text","text":" "},{"type":"text","text":"The syntax for protocol inheritance is similar to the syntax for class inheritance,"},{"type":"text","text":" "},{"type":"text","text":"but with the option to list multiple inherited protocols, separated by commas:"}]},{"type":"codeListing","syntax":"swift","code":["protocol InheritingProtocol: SomeProtocol, AnotherProtocol {","   \/\/ protocol definition goes here","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a protocol that inherits"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" protocol from above:"}]},{"type":"codeListing","syntax":"swift","code":["protocol PrettyTextRepresentable: TextRepresentable {","   var prettyTextualDescription: String { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example defines a new protocol, "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which inherits from "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Anything that adopts "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" must satisfy all of the requirements"},{"type":"text","text":" "},{"type":"text","text":"enforced by "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"plus"}]},{"type":"text","text":" the additional requirements enforced by "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"In this example, "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" adds a single requirement"},{"type":"text","text":" "},{"type":"text","text":"to provide a gettable property called "},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" that returns a "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" class can be extended to adopt and conform to "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["extension SnakesAndLadders: PrettyTextRepresentable {","   var prettyTextualDescription: String {","      var output = textualDescription + \":\\n\"","      for index in 1...finalSquare {","         switch board[index] {","            case let ladder where ladder > 0:","               output += \"▲ \"","            case let snake where snake < 0:","               output += \"▼ \"","            default:","               output += \"○ \"","         }","      }","      return output","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This extension states that it adopts the "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"and provides an implementation of the "},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" property"},{"type":"text","text":" "},{"type":"text","text":"for the "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"Anything that’s "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" must also be "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and so the implementation of "},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" starts"},{"type":"text","text":" "},{"type":"text","text":"by accessing the "},{"type":"codeVoice","code":"textualDescription"},{"type":"text","text":" property"},{"type":"text","text":" "},{"type":"text","text":"from the "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" protocol to begin an output string."},{"type":"text","text":" "},{"type":"text","text":"It appends a colon and a line break,"},{"type":"text","text":" "},{"type":"text","text":"and uses this as the start of its pretty text representation."},{"type":"text","text":" "},{"type":"text","text":"It then iterates through the array of board squares,"},{"type":"text","text":" "},{"type":"text","text":"and appends a geometric shape to represent the contents of each square:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the square’s value is greater than "},{"type":"codeVoice","code":"0"},{"type":"text","text":", it’s the base of a ladder,"},{"type":"text","text":" "},{"type":"text","text":"and is represented by "},{"type":"codeVoice","code":"▲"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the square’s value is less than "},{"type":"codeVoice","code":"0"},{"type":"text","text":", it’s the head of a snake,"},{"type":"text","text":" "},{"type":"text","text":"and is represented by "},{"type":"codeVoice","code":"▼"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Otherwise, the square’s value is "},{"type":"codeVoice","code":"0"},{"type":"text","text":", and it’s a “free” square,"},{"type":"text","text":" "},{"type":"text","text":"represented by "},{"type":"codeVoice","code":"○"},{"type":"text","text":"."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" property can now be used to print a pretty text description"},{"type":"text","text":" "},{"type":"text","text":"of any "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" instance:"}]},{"type":"codeListing","syntax":"swift","code":["print(game.prettyTextualDescription)","\/\/ A game of Snakes and Ladders with 25 squares:","\/\/ ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○"]},{"anchor":"Class-Only-Protocols","level":2,"type":"heading","text":"Class-Only Protocols"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can limit protocol adoption to class types (and not structures or enumerations)"},{"type":"text","text":" "},{"type":"text","text":"by adding the "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" protocol to a protocol’s inheritance list."}]},{"type":"codeListing","syntax":"swift","code":["protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {","   \/\/ class-only protocol definition goes here","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above, "},{"type":"codeVoice","code":"SomeClassOnlyProtocol"},{"type":"text","text":" can only be adopted by class types."},{"type":"text","text":" "},{"type":"text","text":"It’s a compile-time error to write a structure or enumeration definition"},{"type":"text","text":" "},{"type":"text","text":"that tries to adopt "},{"type":"codeVoice","code":"SomeClassOnlyProtocol"},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use a class-only protocol when the behavior defined by that protocol’s requirements"},{"type":"text","text":" "},{"type":"text","text":"assumes or requires that a conforming type has"},{"type":"text","text":" "},{"type":"text","text":"reference semantics rather than value semantics."},{"type":"text","text":" "},{"type":"text","text":"For more about reference and value semantics,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"text","text":"doc:ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"text","text":"doc:ClassesAndStructures#Classes-Are-Reference-Types"},{"type":"text","text":"."}]}],"type":"aside","name":"Note"},{"anchor":"Protocol-Composition","level":2,"type":"heading","text":"Protocol Composition"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It can be useful to require a type to conform to multiple protocols at the same time."},{"type":"text","text":" "},{"type":"text","text":"You can combine multiple protocols into a single requirement"},{"type":"text","text":" "},{"type":"text","text":"with a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol composition"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Protocol compositions behave as if you"},{"type":"text","text":" "},{"type":"text","text":"defined a temporary local protocol that has the combined requirements"},{"type":"text","text":" "},{"type":"text","text":"of all protocols in the composition."},{"type":"text","text":" "},{"type":"text","text":"Protocol compositions don’t define any new protocol types."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocol compositions have the form "},{"type":"codeVoice","code":"SomeProtocol & AnotherProtocol"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"You can list as many protocols as you need,"},{"type":"text","text":" "},{"type":"text","text":"separating them with ampersands ("},{"type":"codeVoice","code":"&"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"In addition to its list of protocols,"},{"type":"text","text":" "},{"type":"text","text":"a protocol composition can also contain one class type,"},{"type":"text","text":" "},{"type":"text","text":"which you can use to specify a required superclass."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example that combines two protocols called "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Aged"},{"type":"text","text":" "},{"type":"text","text":"into a single protocol composition requirement on a function parameter:"}]},{"type":"codeListing","syntax":"swift","code":["protocol Named {","   var name: String { get }","}","protocol Aged {","   var age: Int { get }","}","struct Person: Named, Aged {","   var name: String","   var age: Int","}","func wishHappyBirthday(to celebrator: Named & Aged) {","   print(\"Happy birthday, \\(celebrator.name), you're \\(celebrator.age)!\")","}","let birthdayPerson = Person(name: \"Malcolm\", age: 21)","wishHappyBirthday(to: birthdayPerson)","\/\/ Prints \"Happy birthday, Malcolm, you're 21!\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"has a single requirement for a gettable "},{"type":"codeVoice","code":"String"},{"type":"text","text":" property called "},{"type":"codeVoice","code":"name"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Aged"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"has a single requirement for a gettable "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" property called "},{"type":"codeVoice","code":"age"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Both protocols are adopted by a structure called "},{"type":"codeVoice","code":"Person"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example also defines a "},{"type":"codeVoice","code":"wishHappyBirthday(to:)"},{"type":"text","text":" function."},{"type":"text","text":" "},{"type":"text","text":"The type of the "},{"type":"codeVoice","code":"celebrator"},{"type":"text","text":" parameter is "},{"type":"codeVoice","code":"Named & Aged"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which means “any type that conforms to both the "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Aged"},{"type":"text","text":" protocols.”"},{"type":"text","text":" "},{"type":"text","text":"It doesn’t matter which specific type is passed to the function,"},{"type":"text","text":" "},{"type":"text","text":"as long as it conforms to both of the required protocols."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example then creates a new "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" instance called "},{"type":"codeVoice","code":"birthdayPerson"},{"type":"text","text":" "},{"type":"text","text":"and passes this new instance to the "},{"type":"codeVoice","code":"wishHappyBirthday(to:)"},{"type":"text","text":" function."},{"type":"text","text":" "},{"type":"text","text":"Because "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" conforms to both protocols, this call is valid,"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"wishHappyBirthday(to:)"},{"type":"text","text":" function can print its birthday greeting."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example that combines"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" protocol from the previous example"},{"type":"text","text":" "},{"type":"text","text":"with a "},{"type":"codeVoice","code":"Location"},{"type":"text","text":" class:"}]},{"type":"codeListing","syntax":"swift","code":["class Location {","    var latitude: Double","    var longitude: Double","    init(latitude: Double, longitude: Double) {","        self.latitude = latitude","        self.longitude = longitude","    }","}","class City: Location, Named {","    var name: String","    init(name: String, latitude: Double, longitude: Double) {","        self.name = name","        super.init(latitude: latitude, longitude: longitude)","    }","}","func beginConcert(in location: Location & Named) {","    print(\"Hello, \\(location.name)!\")","}","","let seattle = City(name: \"Seattle\", latitude: 47.6, longitude: -122.3)","beginConcert(in: seattle)","\/\/ Prints \"Hello, Seattle!\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"beginConcert(in:)"},{"type":"text","text":" function takes"},{"type":"text","text":" "},{"type":"text","text":"a parameter of type "},{"type":"codeVoice","code":"Location & Named"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which means “any type that’s a subclass of "},{"type":"codeVoice","code":"Location"},{"type":"text","text":" "},{"type":"text","text":"and that conforms to the "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" protocol.”"},{"type":"text","text":" "},{"type":"text","text":"In this case, "},{"type":"codeVoice","code":"City"},{"type":"text","text":" satisfies both requirements."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Passing "},{"type":"codeVoice","code":"birthdayPerson"},{"type":"text","text":" to the "},{"type":"codeVoice","code":"beginConcert(in:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"is invalid because "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" isn’t a subclass of "},{"type":"codeVoice","code":"Location"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Likewise,"},{"type":"text","text":" "},{"type":"text","text":"if you made a subclass of "},{"type":"codeVoice","code":"Location"},{"type":"text","text":" "},{"type":"text","text":"that didn’t conform to the "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"calling "},{"type":"codeVoice","code":"beginConcert(in:)"},{"type":"text","text":" with an instance of that type"},{"type":"text","text":" "},{"type":"text","text":"is also invalid."}]},{"anchor":"Checking-for-Protocol-Conformance","level":2,"type":"heading","text":"Checking for Protocol Conformance"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use the "},{"type":"codeVoice","code":"is"},{"type":"text","text":" and "},{"type":"codeVoice","code":"as"},{"type":"text","text":" operators described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting"},{"type":"text","text":" "},{"type":"text","text":"to check for protocol conformance, and to cast to a specific protocol."},{"type":"text","text":" "},{"type":"text","text":"Checking for and casting to a protocol"},{"type":"text","text":" "},{"type":"text","text":"follows exactly the same syntax as checking for and casting to a type:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"is"},{"type":"text","text":" operator returns "},{"type":"codeVoice","code":"true"},{"type":"text","text":" if an instance conforms to a protocol"},{"type":"text","text":" "},{"type":"text","text":"and returns "},{"type":"codeVoice","code":"false"},{"type":"text","text":" if it doesn’t."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" version of the downcast operator returns"},{"type":"text","text":" "},{"type":"text","text":"an optional value of the protocol’s type,"},{"type":"text","text":" "},{"type":"text","text":"and this value is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" if the instance doesn’t conform to that protocol."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as!"},{"type":"text","text":" version of the downcast operator forces the downcast to the protocol type"},{"type":"text","text":" "},{"type":"text","text":"and triggers a runtime error if the downcast doesn’t succeed."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example defines a protocol called "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"with a single property requirement of a gettable "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" property called "},{"type":"codeVoice","code":"area"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["protocol HasArea {","   var area: Double { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here are two classes, "},{"type":"codeVoice","code":"Circle"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Country"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"both of which conform to the "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["class Circle: HasArea {","   let pi = 3.1415927","   var radius: Double","   var area: Double { return pi * radius * radius }","   init(radius: Double) { self.radius = radius }","}","class Country: HasArea {","   var area: Double","   init(area: Double) { self.area = area }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Circle"},{"type":"text","text":" class implements the "},{"type":"codeVoice","code":"area"},{"type":"text","text":" property requirement"},{"type":"text","text":" "},{"type":"text","text":"as a computed property, based on a stored "},{"type":"codeVoice","code":"radius"},{"type":"text","text":" property."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Country"},{"type":"text","text":" class implements the "},{"type":"codeVoice","code":"area"},{"type":"text","text":" requirement directly as a stored property."},{"type":"text","text":" "},{"type":"text","text":"Both classes correctly conform to the "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":" protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a class called "},{"type":"codeVoice","code":"Animal"},{"type":"text","text":", which doesn’t conform to the "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["class Animal {","   var legs: Int","   init(legs: Int) { self.legs = legs }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Circle"},{"type":"text","text":", "},{"type":"codeVoice","code":"Country"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Animal"},{"type":"text","text":" classes don’t have a shared base class."},{"type":"text","text":" "},{"type":"text","text":"Nonetheless, they’re all classes, and so instances of all three types"},{"type":"text","text":" "},{"type":"text","text":"can be used to initialize an array that stores values of type "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let objects: [AnyObject] = [","   Circle(radius: 2.0),","   Country(area: 243_610),","   Animal(legs: 4)","]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"objects"},{"type":"text","text":" array is initialized with an array literal containing"},{"type":"text","text":" "},{"type":"text","text":"a "},{"type":"codeVoice","code":"Circle"},{"type":"text","text":" instance with a radius of 2 units;"},{"type":"text","text":" "},{"type":"text","text":"a "},{"type":"codeVoice","code":"Country"},{"type":"text","text":" instance initialized with"},{"type":"text","text":" "},{"type":"text","text":"the surface area of the United Kingdom in square kilometers;"},{"type":"text","text":" "},{"type":"text","text":"and an "},{"type":"codeVoice","code":"Animal"},{"type":"text","text":" instance with four legs."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"objects"},{"type":"text","text":" array can now be iterated,"},{"type":"text","text":" "},{"type":"text","text":"and each object in the array can be checked to see if"},{"type":"text","text":" "},{"type":"text","text":"it conforms to the "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["for object in objects {","   if let objectWithArea = object as? HasArea {","      print(\"Area is \\(objectWithArea.area)\")","   } else {","      print(\"Something that doesn't have an area\")","   }","}","\/\/ Area is 12.5663708","\/\/ Area is 243610.0","\/\/ Something that doesn't have an area"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Whenever an object in the array conforms to the "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"the optional value returned by the "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" operator is unwrapped with optional binding"},{"type":"text","text":" "},{"type":"text","text":"into a constant called "},{"type":"codeVoice","code":"objectWithArea"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"objectWithArea"},{"type":"text","text":" constant is known to be of type "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and so its "},{"type":"codeVoice","code":"area"},{"type":"text","text":" property can be accessed and printed in a type-safe way."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the underlying objects aren’t changed by the casting process."},{"type":"text","text":" "},{"type":"text","text":"They continue to be a "},{"type":"codeVoice","code":"Circle"},{"type":"text","text":", a "},{"type":"codeVoice","code":"Country"},{"type":"text","text":" and an "},{"type":"codeVoice","code":"Animal"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"However, at the point that they’re stored in the "},{"type":"codeVoice","code":"objectWithArea"},{"type":"text","text":" constant,"},{"type":"text","text":" "},{"type":"text","text":"they’re only known to be of type "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and so only their "},{"type":"codeVoice","code":"area"},{"type":"text","text":" property can be accessed."}]},{"anchor":"Optional-Protocol-Requirements","level":2,"type":"heading","text":"Optional Protocol Requirements"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional requirements"}]},{"type":"text","text":" for protocols."},{"type":"text","text":" "},{"type":"text","text":"These requirements don’t have to be implemented by types that conform to the protocol."},{"type":"text","text":" "},{"type":"text","text":"Optional requirements are prefixed by the "},{"type":"codeVoice","code":"optional"},{"type":"text","text":" modifier"},{"type":"text","text":" "},{"type":"text","text":"as part of the protocol’s definition."},{"type":"text","text":" "},{"type":"text","text":"Optional requirements are available so that you can write code"},{"type":"text","text":" "},{"type":"text","text":"that interoperates with Objective-C."},{"type":"text","text":" "},{"type":"text","text":"Both the protocol and the optional requirement"},{"type":"text","text":" "},{"type":"text","text":"must be marked with the "},{"type":"codeVoice","code":"@objc"},{"type":"text","text":" attribute."},{"type":"text","text":" "},{"type":"text","text":"Note that "},{"type":"codeVoice","code":"@objc"},{"type":"text","text":" protocols can be adopted only by classes"},{"type":"text","text":" "},{"type":"text","text":"that inherit from Objective-C classes or other "},{"type":"codeVoice","code":"@objc"},{"type":"text","text":" classes."},{"type":"text","text":" "},{"type":"text","text":"They can’t be adopted by structures or enumerations."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you use a method or property in an optional requirement,"},{"type":"text","text":" "},{"type":"text","text":"its type automatically becomes an optional."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"a method of type "},{"type":"codeVoice","code":"(Int) -> String"},{"type":"text","text":" becomes "},{"type":"codeVoice","code":"((Int) -> String)?"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Note that the entire function type"},{"type":"text","text":" "},{"type":"text","text":"is wrapped in the optional,"},{"type":"text","text":" "},{"type":"text","text":"not the method’s return value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An optional protocol requirement can be called with optional chaining,"},{"type":"text","text":" "},{"type":"text","text":"to account for the possibility that the requirement was not implemented"},{"type":"text","text":" "},{"type":"text","text":"by a type that conforms to the protocol."},{"type":"text","text":" "},{"type":"text","text":"You check for an implementation of an optional method"},{"type":"text","text":" "},{"type":"text","text":"by writing a question mark after the name of the method when it’s called,"},{"type":"text","text":" "},{"type":"text","text":"such as "},{"type":"codeVoice","code":"someOptionalMethod?(someArgument)"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For information on optional chaining, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example defines an integer-counting class called "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which uses an external data source to provide its increment amount."},{"type":"text","text":" "},{"type":"text","text":"This data source is defined by the "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"which has two optional requirements:"}]},{"type":"codeListing","syntax":"swift","code":["@objc protocol CounterDataSource {","   @objc optional func increment(forCount count: Int) -> Int","   @objc optional var fixedIncrement: Int { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" protocol defines"},{"type":"text","text":" "},{"type":"text","text":"an optional method requirement called "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" "},{"type":"text","text":"and an optional property requirement called "},{"type":"codeVoice","code":"fixedIncrement"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"These requirements define two different ways for data sources to provide"},{"type":"text","text":" "},{"type":"text","text":"an appropriate increment amount for a "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" instance."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Strictly speaking, you can write a custom class"},{"type":"text","text":" "},{"type":"text","text":"that conforms to "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" without implementing"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"either"}]},{"type":"text","text":" protocol requirement."},{"type":"text","text":" "},{"type":"text","text":"They’re both optional, after all."},{"type":"text","text":" "},{"type":"text","text":"Although technically allowed, this wouldn’t make for a very good data source."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" class, defined below,"},{"type":"text","text":" "},{"type":"text","text":"has an optional "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" property of type "},{"type":"codeVoice","code":"CounterDataSource?"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["class Counter {","   var count = 0","   var dataSource: CounterDataSource?","   func increment() {","      if let amount = dataSource?.increment?(forCount: count) {","         count += amount","      } else if let amount = dataSource?.fixedIncrement {","         count += amount","      }","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" class stores its current value in a variable property called "},{"type":"codeVoice","code":"count"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" class also defines a method called "},{"type":"codeVoice","code":"increment"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which increments the "},{"type":"codeVoice","code":"count"},{"type":"text","text":" property every time the method is called."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"increment()"},{"type":"text","text":" method first tries to retrieve an increment amount"},{"type":"text","text":" "},{"type":"text","text":"by looking for an implementation of the "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" method on its data source."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"increment()"},{"type":"text","text":" method uses optional chaining to try to call "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and passes the current "},{"type":"codeVoice","code":"count"},{"type":"text","text":" value as the method’s single argument."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that "},{"type":"emphasis","inlineContent":[{"type":"text","text":"two"}]},{"type":"text","text":" levels of optional chaining are at play here."},{"type":"text","text":" "},{"type":"text","text":"First, it’s possible that "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" may be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and so "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" has a question mark after its name to indicate that"},{"type":"text","text":" "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" should be called only if "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" isn’t "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Second, even if "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"does"}]},{"type":"text","text":" exist,"},{"type":"text","text":" "},{"type":"text","text":"there’s no guarantee that it implements "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"because it’s an optional requirement."},{"type":"text","text":" "},{"type":"text","text":"Here, the possibility that "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" might not be implemented"},{"type":"text","text":" "},{"type":"text","text":"is also handled by optional chaining."},{"type":"text","text":" "},{"type":"text","text":"The call to "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" happens"},{"type":"text","text":" "},{"type":"text","text":"only if "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" exists —"},{"type":"text","text":" "},{"type":"text","text":"that is, if it isn’t "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This is why "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" is also written with a question mark after its name."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the call to "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" can fail for either of these two reasons,"},{"type":"text","text":" "},{"type":"text","text":"the call returns an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value."},{"type":"text","text":" "},{"type":"text","text":"This is true even though "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" is defined as returning"},{"type":"text","text":" "},{"type":"text","text":"a non-optional "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value in the definition of "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Even though there are two optional chaining operations,"},{"type":"text","text":" "},{"type":"text","text":"one after another,"},{"type":"text","text":" "},{"type":"text","text":"the result is still wrapped in a single optional."},{"type":"text","text":" "},{"type":"text","text":"For more information about using multiple optional chaining operations,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining#Linking-Multiple-Levels-of-Chaining"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"After calling "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":", the optional "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" that it returns"},{"type":"text","text":" "},{"type":"text","text":"is unwrapped into a constant called "},{"type":"codeVoice","code":"amount"},{"type":"text","text":", using optional binding."},{"type":"text","text":" "},{"type":"text","text":"If the optional "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" does contain a value —"},{"type":"text","text":" "},{"type":"text","text":"that is, if the delegate and method both exist,"},{"type":"text","text":" "},{"type":"text","text":"and the method returned a value —"},{"type":"text","text":" "},{"type":"text","text":"the unwrapped "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" is added onto the stored "},{"type":"codeVoice","code":"count"},{"type":"text","text":" property,"},{"type":"text","text":" "},{"type":"text","text":"and incrementation is complete."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If it’s "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" possible to retrieve a value from the "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" method —"},{"type":"text","text":" "},{"type":"text","text":"either because "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" is nil,"},{"type":"text","text":" "},{"type":"text","text":"or because the data source doesn’t implement "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" —"},{"type":"text","text":" "},{"type":"text","text":"then the "},{"type":"codeVoice","code":"increment()"},{"type":"text","text":" method tries to retrieve a value"},{"type":"text","text":" "},{"type":"text","text":"from the data source’s "},{"type":"codeVoice","code":"fixedIncrement"},{"type":"text","text":" property instead."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"fixedIncrement"},{"type":"text","text":" property is also an optional requirement,"},{"type":"text","text":" "},{"type":"text","text":"so its value is an optional "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value,"},{"type":"text","text":" "},{"type":"text","text":"even though "},{"type":"codeVoice","code":"fixedIncrement"},{"type":"text","text":" is defined as a non-optional "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" property"},{"type":"text","text":" "},{"type":"text","text":"as part of the "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" protocol definition."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a simple "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" implementation where the data source"},{"type":"text","text":" "},{"type":"text","text":"returns a constant value of "},{"type":"codeVoice","code":"3"},{"type":"text","text":" every time it’s queried."},{"type":"text","text":" "},{"type":"text","text":"It does this by implementing the optional "},{"type":"codeVoice","code":"fixedIncrement"},{"type":"text","text":" property requirement:"}]},{"type":"codeListing","syntax":"swift","code":["class ThreeSource: NSObject, CounterDataSource {","   let fixedIncrement = 3","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use an instance of "},{"type":"codeVoice","code":"ThreeSource"},{"type":"text","text":" as the data source for a new "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" instance:"}]},{"type":"codeListing","syntax":"swift","code":["var counter = Counter()","counter.dataSource = ThreeSource()","for _ in 1...4 {","   counter.increment()","   print(counter.count)","}","\/\/ 3","\/\/ 6","\/\/ 9","\/\/ 12"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code above creates a new "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" instance;"},{"type":"text","text":" "},{"type":"text","text":"sets its data source to be a new "},{"type":"codeVoice","code":"ThreeSource"},{"type":"text","text":" instance;"},{"type":"text","text":" "},{"type":"text","text":"and calls the counter’s "},{"type":"codeVoice","code":"increment()"},{"type":"text","text":" method four times."},{"type":"text","text":" "},{"type":"text","text":"As expected, the counter’s "},{"type":"codeVoice","code":"count"},{"type":"text","text":" property increases by three"},{"type":"text","text":" "},{"type":"text","text":"each time "},{"type":"codeVoice","code":"increment()"},{"type":"text","text":" is called."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a more complex data source called "},{"type":"codeVoice","code":"TowardsZeroSource"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which makes a "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" instance count up or down towards zero"},{"type":"text","text":" "},{"type":"text","text":"from its current "},{"type":"codeVoice","code":"count"},{"type":"text","text":" value:"}]},{"type":"codeListing","syntax":"swift","code":["class TowardsZeroSource: NSObject, CounterDataSource {","   func increment(forCount count: Int) -> Int {","      if count == 0 {","         return 0","      } else if count < 0 {","         return 1","      } else {","         return -1","      }","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"TowardsZeroSource"},{"type":"text","text":" class implements"},{"type":"text","text":" "},{"type":"text","text":"the optional "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" method from the "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"and uses the "},{"type":"codeVoice","code":"count"},{"type":"text","text":" argument value to work out which direction to count in."},{"type":"text","text":" "},{"type":"text","text":"If "},{"type":"codeVoice","code":"count"},{"type":"text","text":" is already zero, the method returns "},{"type":"codeVoice","code":"0"},{"type":"text","text":" "},{"type":"text","text":"to indicate that no further counting should take place."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use an instance of "},{"type":"codeVoice","code":"TowardsZeroSource"},{"type":"text","text":" with the existing "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" instance"},{"type":"text","text":" "},{"type":"text","text":"to count from "},{"type":"codeVoice","code":"-4"},{"type":"text","text":" to zero."},{"type":"text","text":" "},{"type":"text","text":"Once the counter reaches zero, no more counting takes place:"}]},{"type":"codeListing","syntax":"swift","code":["counter.count = -4","counter.dataSource = TowardsZeroSource()","for _ in 1...5 {","   counter.increment()","   print(counter.count)","}","\/\/ -3","\/\/ -2","\/\/ -1","\/\/ 0","\/\/ 0"]},{"anchor":"Protocol-Extensions","level":2,"type":"heading","text":"Protocol Extensions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocols can be extended to provide method,"},{"type":"text","text":" "},{"type":"text","text":"initializer, subscript, and computed property implementations"},{"type":"text","text":" "},{"type":"text","text":"to conforming types."},{"type":"text","text":" "},{"type":"text","text":"This allows you to define behavior on protocols themselves,"},{"type":"text","text":" "},{"type":"text","text":"rather than in each type’s individual conformance or in a global function."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol can be extended"},{"type":"text","text":" "},{"type":"text","text":"to provide a "},{"type":"codeVoice","code":"randomBool()"},{"type":"text","text":" method,"},{"type":"text","text":" "},{"type":"text","text":"which uses the result of the required "},{"type":"codeVoice","code":"random()"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"to return a random "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" value:"}]},{"type":"codeListing","syntax":"swift","code":["extension RandomNumberGenerator {","   func randomBool() -> Bool {","      return random() > 0.5","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By creating an extension on the protocol,"},{"type":"text","text":" "},{"type":"text","text":"all conforming types automatically gain this method implementation"},{"type":"text","text":" "},{"type":"text","text":"without any additional modification."}]},{"type":"codeListing","syntax":"swift","code":["let generator = LinearCongruentialGenerator()","print(\"Here's a random number: \\(generator.random())\")","\/\/ Prints \"Here's a random number: 0.3746499199817101\"","print(\"And here's a random Boolean: \\(generator.randomBool())\")","\/\/ Prints \"And here's a random Boolean: true\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocol extensions can add implementations to conforming types"},{"type":"text","text":" "},{"type":"text","text":"but can’t make a protocol extend or inherit from another protocol."},{"type":"text","text":" "},{"type":"text","text":"Protocol inheritance is always specified in the protocol declaration itself."}]},{"anchor":"Providing-Default-Implementations","level":3,"type":"heading","text":"Providing Default Implementations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use protocol extensions to provide a default implementation"},{"type":"text","text":" "},{"type":"text","text":"to any method or computed property requirement of that protocol."},{"type":"text","text":" "},{"type":"text","text":"If a conforming type provides its own implementation of a required method or property,"},{"type":"text","text":" "},{"type":"text","text":"that implementation will be used instead of the one provided by the extension."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocol requirements with default implementations provided by extensions"},{"type":"text","text":" "},{"type":"text","text":"are distinct from optional protocol requirements."},{"type":"text","text":" "},{"type":"text","text":"Although conforming types don’t have to provide their own implementation of either,"},{"type":"text","text":" "},{"type":"text","text":"requirements with default implementations can be called without optional chaining."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"which inherits the "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"can provide a default implementation of its required "},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" property"},{"type":"text","text":" "},{"type":"text","text":"to simply return the result of accessing the "},{"type":"codeVoice","code":"textualDescription"},{"type":"text","text":" property:"}]},{"type":"codeListing","syntax":"swift","code":["extension PrettyTextRepresentable  {","   var prettyTextualDescription: String {","      return textualDescription","   }","}"]},{"anchor":"Adding-Constraints-to-Protocol-Extensions","level":3,"type":"heading","text":"Adding Constraints to Protocol Extensions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you define a protocol extension,"},{"type":"text","text":" "},{"type":"text","text":"you can specify constraints that conforming types"},{"type":"text","text":" "},{"type":"text","text":"must satisfy before the methods and properties of the extension are available."},{"type":"text","text":" "},{"type":"text","text":"You write these constraints after the name of the protocol you’re extending"},{"type":"text","text":" "},{"type":"text","text":"by writing a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause."},{"type":"text","text":" "},{"type":"text","text":"For more about generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Where-Clauses"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"you can define an extension to the "},{"type":"codeVoice","code":"Collection"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"that applies to any collection whose elements conform"},{"type":"text","text":" "},{"type":"text","text":"to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"By constraining a collection’s elements to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"a part of the standard library,"},{"type":"text","text":" "},{"type":"text","text":"you can use the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" and "},{"type":"codeVoice","code":"!="},{"type":"text","text":" operators to check for equality and inequality between two elements."}]},{"type":"codeListing","syntax":"swift","code":["extension Collection where Element: Equatable {","    func allEqual() -> Bool {","        for element in self {","            if element != self.first {","                return false","            }","        }","        return true","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"allEqual()"},{"type":"text","text":" method returns "},{"type":"codeVoice","code":"true"},{"type":"text","text":" "},{"type":"text","text":"only if all the elements in the collection are equal."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Consider two arrays of integers,"},{"type":"text","text":" "},{"type":"text","text":"one where all the elements are the same,"},{"type":"text","text":" "},{"type":"text","text":"and one where they aren’t:"}]},{"type":"codeListing","syntax":"swift","code":["let equalNumbers = [100, 100, 100, 100, 100]","let differentNumbers = [100, 100, 200, 100, 200]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because arrays conform to "},{"type":"codeVoice","code":"Collection"},{"type":"text","text":" "},{"type":"text","text":"and integers conform to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"codeVoice","code":"equalNumbers"},{"type":"text","text":" and "},{"type":"codeVoice","code":"differentNumbers"},{"type":"text","text":" can use the "},{"type":"codeVoice","code":"allEqual()"},{"type":"text","text":" method:"}]},{"type":"codeListing","syntax":"swift","code":["print(equalNumbers.allEqual())","\/\/ Prints \"true\"","print(differentNumbers.allEqual())","\/\/ Prints \"false\""]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If a conforming type satisfies the requirements for multiple constrained extensions"},{"type":"text","text":" "},{"type":"text","text":"that provide implementations for the same method or property,"},{"type":"text","text":" "},{"type":"text","text":"Swift uses the implementation corresponding to the most specialized constraints."}]}],"type":"aside","name":"Note"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/protocols"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol"}]},{"type":"text","text":" defines a blueprint of"},{"type":"text","text":" "},{"type":"text","text":"methods, properties, and other requirements"},{"type":"text","text":" "},{"type":"text","text":"that suit a particular task or piece of functionality."},{"type":"text","text":" "},{"type":"text","text":"The protocol can then be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"adopted"}]},{"type":"text","text":" by a class, structure, or enumeration"},{"type":"text","text":" "},{"type":"text","text":"to provide an actual implementation of those requirements."},{"type":"text","text":" "},{"type":"text","text":"Any type that satisfies the requirements of a protocol is said to"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conform"}]},{"type":"text","text":" to that protocol."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Protocols","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Guide","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"],"generated":true}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OptionalChaining":{"role":"article","title":"Optional Chaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling"},{"type":"text","text":" "},{"type":"text","text":"properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the optional contains a value,"},{"type":"text","text":" "},{"type":"text","text":"the property, method, or subscript call succeeds;"},{"type":"text","text":" "},{"type":"text","text":"if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Multiple queries can be chained together,"},{"type":"text","text":" "},{"type":"text","text":"and the entire chain fails gracefully if any link in the chain is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/optionalchaining"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Methods#Modifying-Value-Types-from-Within-Instance-Methods":{"abstract":[],"title":"Modifying Value Types from Within Instance Methods","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods#Modifying-Value-Types-from-Within-Instance-Methods","url":"\/documentation\/the-swift-programming-language\/methods#Modifying-Value-Types-from-Within-Instance-Methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"role":"article","title":"Type Casting","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance,"},{"type":"text","text":" "},{"type":"text","text":"or to treat that instance as a different"},{"type":"text","text":" "},{"type":"text","text":"superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/StringsAndCharacters":{"role":"article","title":"Strings e Characters","abstract":[{"type":"text","text":"Uma "},{"type":"emphasis","inlineContent":[{"type":"text","text":"string"}]},{"type":"text","text":" é uma série de caracteres,"},{"type":"text","text":" "},{"type":"text","text":"tal como "},{"type":"codeVoice","code":"\"olá, mundo\""},{"type":"text","text":" ou "},{"type":"codeVoice","code":"\"albatroz\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Strings em Swift são representadas pelo tipo "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"O conteúdo de uma "},{"type":"codeVoice","code":"String"},{"type":"text","text":" pode ser acessado de várias maneiras,"},{"type":"text","text":" "},{"type":"text","text":"incluindo como uma coleção de valores "},{"type":"codeVoice","code":"Character"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/stringsandcharacters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics":{"role":"article","title":"O Básico","abstract":[{"type":"text","text":"Swift é uma linguagem de programação para desenvolvimento de aplicativos iOS, macOS, watchOS e tvOS. Se você tem experiência em desenvolvimento em C ou Objective-C, muitas partes do Swift serão familiares para você."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/thebasics"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization":{"role":"article","title":"Initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"type":"text","text":" is the process of preparing an instance of"},{"type":"text","text":" "},{"type":"text","text":"a class, structure, or enumeration for use."},{"type":"text","text":" "},{"type":"text","text":"This process involves setting an initial value for each stored property on that instance"},{"type":"text","text":" "},{"type":"text","text":"and performing any other setup or initialization that’s required"},{"type":"text","text":" "},{"type":"text","text":"before the new instance is ready for use."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow":{"role":"article","title":"Control Flow","abstract":[{"type":"text","text":"Swift provides a variety of control flow statements."},{"type":"text","text":" "},{"type":"text","text":"These include "},{"type":"codeVoice","code":"while"},{"type":"text","text":" loops to perform a task multiple times;"},{"type":"text","text":" "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", and "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statements"},{"type":"text","text":" "},{"type":"text","text":"to execute different branches of code based on certain conditions;"},{"type":"text","text":" "},{"type":"text","text":"and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" "},{"type":"text","text":"to transfer the flow of execution to another point in your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/controlflow"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting":{"role":"article","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"type":"text","text":" (ARC)"},{"type":"text","text":" "},{"type":"text","text":"to track and manage your app’s memory usage."},{"type":"text","text":" "},{"type":"text","text":"In most cases, this means that memory management “just works” in Swift,"},{"type":"text","text":" "},{"type":"text","text":"and you don’t need to think about memory management yourself."},{"type":"text","text":" "},{"type":"text","text":"ARC automatically frees up the memory used by class instances"},{"type":"text","text":" "},{"type":"text","text":"when those instances are no longer needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization#Required-Initializers":{"abstract":[],"title":"Required Initializers","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Required-Initializers","url":"\/documentation\/the-swift-programming-language\/initialization#Required-Initializers"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Deinitialization":{"role":"article","title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"deinitializer"}]},{"type":"text","text":" is called immediately before a class instance is deallocated."},{"type":"text","text":" "},{"type":"text","text":"You write deinitializers with the "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"similar to how initializers are written with the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"Deinitializers are only available on class types."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/deinitialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting#Strong-Reference-Cycles-Between-Class-Instances":{"abstract":[],"title":"Strong Reference Cycles Between Class Instances","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Strong-Reference-Cycles-Between-Class-Instances","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting#Strong-Reference-Cycles-Between-Class-Instances"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization#Failable-Initializers":{"abstract":[],"title":"Failable Initializers","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Failable-Initializers","url":"\/documentation\/the-swift-programming-language\/initialization#Failable-Initializers"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes":{"role":"article","title":"Opaque Types","abstract":[{"type":"text","text":"A function or method with an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"type":"text","text":"Instead of providing a concrete type as the function’s return type,"},{"type":"text","text":" "},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"type":"text","text":"Hiding type information"},{"type":"text","text":" "},{"type":"text","text":"is useful at boundaries between"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"type":"text","text":" "},{"type":"text","text":"because the underlying type of the return value can remain private."},{"type":"text","text":" "},{"type":"text","text":"Unlike returning a value whose type is a protocol type,"},{"type":"text","text":" "},{"type":"text","text":"opaque types preserve type identity —"},{"type":"text","text":" "},{"type":"text","text":"the compiler has access to the type information,"},{"type":"text","text":" "},{"type":"text","text":"but clients of the module don’t."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/opaquetypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting#Downcasting":{"abstract":[],"title":"Downcasting","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting","url":"\/documentation\/the-swift-programming-language\/typecasting#Downcasting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow#Break":{"abstract":[],"title":"Break","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow#Break","url":"\/documentation\/the-swift-programming-language\/controlflow#Break"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Methods":{"role":"article","title":"Methods","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Methods"}]},{"type":"text","text":" are functions that are associated with a particular type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can all define instance methods,"},{"type":"text","text":" "},{"type":"text","text":"which encapsulate specific tasks and functionality for working with an instance of a given type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can also define type methods,"},{"type":"text","text":" "},{"type":"text","text":"which are associated with the type itself."},{"type":"text","text":" "},{"type":"text","text":"Type methods are similar to class methods in Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes":{"role":"article","title":"Tipos de Coleção","abstract":[{"type":"text","text":"Swift oferece três "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos de coleção"}]},{"type":"text","text":" primários, conhecidos como arrays, sets e dicionários, para armazenar coleções de valores. Arrays são coleções ordenadas de valores. Sets são coleções não ordenadas de valores únicos. Os dicionários são coleções não ordenadas de associações chave-valor."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/collectiontypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"role":"article","title":"Error Handling","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Error handling"}]},{"type":"text","text":" is the process of responding to"},{"type":"text","text":" "},{"type":"text","text":"and recovering from error conditions in your program."},{"type":"text","text":" "},{"type":"text","text":"Swift provides first-class support for"},{"type":"text","text":" "},{"type":"text","text":"throwing, catching, propagating, and manipulating"},{"type":"text","text":" "},{"type":"text","text":"recoverable errors at runtime."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/errorhandling"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"role":"article","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task."},{"type":"text","text":" "},{"type":"text","text":"You give a function a name that identifies what it does,"},{"type":"text","text":" "},{"type":"text","text":"and this name is used to “call” the function to perform its task when needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance":{"role":"article","title":"Inheritance","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"type":"text","text":" methods, properties, and other characteristics"},{"type":"text","text":" "},{"type":"text","text":"from another class."},{"type":"text","text":" "},{"type":"text","text":"When one class inherits from another,"},{"type":"text","text":" "},{"type":"text","text":"the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Inheritance is a fundamental behavior that differentiates classes"},{"type":"text","text":" "},{"type":"text","text":"from other types in Swift."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/inheritance"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AccessControl":{"role":"article","title":"Access Control","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"type":"text","text":" restricts access to parts of your code"},{"type":"text","text":" "},{"type":"text","text":"from code in other source files and modules."},{"type":"text","text":" "},{"type":"text","text":"This feature enables you to hide the implementation details of your code,"},{"type":"text","text":" "},{"type":"text","text":"and to specify a preferred interface through which that code can be accessed and used."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/accesscontrol"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/MemorySafety":{"role":"article","title":"Memory Safety","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift ensures that variables are initialized before they’re used,"},{"type":"text","text":" "},{"type":"text","text":"memory isn’t accessed after it’s been deallocated,"},{"type":"text","text":" "},{"type":"text","text":"and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/memorysafety"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures":{"role":"article","title":"Closures","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closures"}]},{"type":"text","text":" are self-contained blocks of functionality"},{"type":"text","text":" "},{"type":"text","text":"that can be passed around and used in your code."},{"type":"text","text":" "},{"type":"text","text":"Closures in Swift are similar to blocks in C and Objective-C"},{"type":"text","text":" "},{"type":"text","text":"and to lambdas in other programming languages."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/closures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Generic-Where-Clauses":{"abstract":[],"title":"Generic Where Clauses","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Where-Clauses","url":"\/documentation\/the-swift-programming-language\/generics#Generic-Where-Clauses"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OptionalChaining#Linking-Multiple-Levels-of-Chaining":{"abstract":[],"title":"Linking Multiple Levels of Chaining","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining#Linking-Multiple-Levels-of-Chaining","url":"\/documentation\/the-swift-programming-language\/optionalchaining#Linking-Multiple-Levels-of-Chaining"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/NestedTypes":{"role":"article","title":"Tipos Aninhados","abstract":[{"type":"text","text":"Enumerações são frequentemente criadas para dar suporte a uma funcionalidade especifica de uma classe ou estrutura."},{"type":"text","text":" "},{"type":"text","text":"Similarmente, pode ser conveniente definir classes e estruturas de utilidade"},{"type":"text","text":" "},{"type":"text","text":"puramente para o uso dentro de um contexto de um tipo mais complexo."},{"type":"text","text":" "},{"type":"text","text":"Para fazer isso, o Swift permite que você defina "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipos aninhados"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"nos quais você aninha enumerações, classes e estruturas de suporte"},{"type":"text","text":" "},{"type":"text","text":"dentro da definição do tipo que elas suportam."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/nestedtypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Protocols-as-Types":{"abstract":[],"title":"Protocols as Types","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Protocols-as-Types","url":"\/documentation\/the-swift-programming-language\/protocols#Protocols-as-Types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"role":"article","title":"Generics","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types"},{"type":"text","text":" "},{"type":"text","text":"that can work with any type, subject to requirements that you define."},{"type":"text","text":" "},{"type":"text","text":"You can write code that avoids duplication"},{"type":"text","text":" "},{"type":"text","text":"and expresses its intent in a clear, abstracted manner."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance#Preventing-Overrides":{"abstract":[],"title":"Preventing Overrides","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance#Preventing-Overrides","url":"\/documentation\/the-swift-programming-language\/inheritance#Preventing-Overrides"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Extensions":{"role":"article","title":"Extensões","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensões"}]},{"type":"text","text":" adicionam novas funcionalidades a uma classe, estrutura, enumeração ou tipo de protocolo existente. Isso inclui a capacidade de estender tipos para os quais você não tem acesso ao código-fonte original (conhecido como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"modelagem retroativa"}]},{"type":"text","text":"). As extensões são semelhantes às categorias em Objective-C. (Ao contrário das categorias de Objective-C, as extensões Swift não têm nomes.)"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/extensions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Properties":{"role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Properties"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration."},{"type":"text","text":" "},{"type":"text","text":"Stored properties store constant and variable values as part of an instance,"},{"type":"text","text":" "},{"type":"text","text":"whereas computed properties calculate (rather than store) a value."},{"type":"text","text":" "},{"type":"text","text":"Computed properties are provided by classes, structures, and enumerations."},{"type":"text","text":" "},{"type":"text","text":"Stored properties are provided only by classes and structures."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/properties"},"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"role":"article","title":"Operadores básicos","abstract":[{"type":"text","text":"Um operador é um símbolo ou frase que você pode usar para verificar, mudar ou combinar valores."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, o operador de adição ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") soma dois números,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"e o operador lógico E ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"AND"}]},{"type":"text","text":" - "},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combina dois valores booleanos,"},{"type":"text","text":" "},{"type":"text","text":"como em "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/basicoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency":{"role":"article","title":"Concorrência","abstract":[{"type":"text","text":"Swift tem suporte por padrão para escrita de código assíncrono e paralelo"},{"type":"text","text":" "},{"type":"text","text":"de forma estruturada."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código assíncrono"}]},{"type":"text","text":" pode ser suspenso e retomado posteriormente,"},{"type":"text","text":" "},{"type":"text","text":"embora apenas uma parte do programa seja executada por vez."},{"type":"text","text":" "},{"type":"text","text":"Suspender e retomar código em seu programa"},{"type":"text","text":" "},{"type":"text","text":"permite que ele continue a progredir"},{"type":"text","text":" "},{"type":"text","text":"em operações de curto prazo, como atualizar a interface do usuário,"},{"type":"text","text":" "},{"type":"text","text":"enquanto continua a trabalhar em operações de longa duração"},{"type":"text","text":" "},{"type":"text","text":"como buscar dados pela rede ou analisar arquivos."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Código paralelo"}]},{"type":"text","text":" significa vários pedaços de código executando simultaneamente —"},{"type":"text","text":" "},{"type":"text","text":"por exemplo, um computador com um processador de quatro núcleos"},{"type":"text","text":" "},{"type":"text","text":"pode executar quatro pedaços de código ao mesmo tempo,"},{"type":"text","text":" "},{"type":"text","text":"com cada núcleo realizando uma das tarefas."},{"type":"text","text":" "},{"type":"text","text":"Um programa que usa código paralelo e assíncrono"},{"type":"text","text":" "},{"type":"text","text":"realiza várias operações ao mesmo tempo;"},{"type":"text","text":" "},{"type":"text","text":"suspende as operações que estão à espera de um sistema externo,"},{"type":"text","text":" "},{"type":"text","text":"e torna mais fácil escrever esse código de maneira segura para a memória ("},{"type":"emphasis","inlineContent":[{"type":"text","text":"memory-safe"}]},{"type":"text","text":")."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/concurrency"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators":{"role":"article","title":"Operadores Avançados","abstract":[{"type":"text","text":"Além dos operadores descritos no tópico "},{"type":"text","text":"doc:OperadoresBasicos"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"a linguagem Swift oferece o tópico Operadores Avançados que fazem manipulação de valores mais complexa."},{"type":"text","text":" "},{"type":"text","text":"Lá são incluídos operadores bit a bit e operadores com deslocamento que estamos familiarizados em C e Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/advancedoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Class-Only-Protocols":{"abstract":[],"title":"Class-Only Protocols","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Class-Only-Protocols","url":"\/documentation\/the-swift-programming-language\/protocols#Class-Only-Protocols"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Subscripts":{"role":"article","title":"Subscripts","abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscripts"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which are shortcuts for accessing the member elements of a collection, list, or sequence."},{"type":"text","text":" "},{"type":"text","text":"You use subscripts to set and retrieve values by index without needing"},{"type":"text","text":" "},{"type":"text","text":"separate methods for setting and retrieval."},{"type":"text","text":" "},{"type":"text","text":"For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" "},{"type":"text","text":"and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/subscripts"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Enumerations":{"role":"article","title":"Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values"},{"type":"text","text":" "},{"type":"text","text":"and enables you to work with those values in a type-safe way within your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/enumerations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures":{"role":"article","title":"Estruturas e Classes","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Estruturas"}]},{"type":"text","text":" e "},{"type":"emphasis","inlineContent":[{"type":"text","text":"classes"}]},{"type":"text","text":" são construções flexíveis de propósito geral que se tornam os blocos de construção do código do seu programa. Você define propriedades e métodos para adicionar funcionalidade às suas estruturas e classes usando a mesma sintaxe usada para definir constantes, variáveis e funções."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/classesandstructures"}}}