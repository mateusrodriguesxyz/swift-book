{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For an overview of generics in Swift, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics"},{"type":"text","text":"."}]},{"anchor":"Generic-Parameter-Clause","level":2,"type":"heading","text":"Generic Parameter Clause"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic parameter clause"}]},{"type":"text","text":" specifies the type parameters of a generic"},{"type":"text","text":" "},{"type":"text","text":"type or function, along with any associated constraints and requirements on those parameters."},{"type":"text","text":" "},{"type":"text","text":"A generic parameter clause is enclosed in angle brackets (<>)"},{"type":"text","text":" "},{"type":"text","text":"and has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<<#generic parameter list#>>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic parameter list"}]},{"type":"text","text":" is a comma-separated list of generic parameters,"},{"type":"text","text":" "},{"type":"text","text":"each of which has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#type parameter#>: <#constraint#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A generic parameter consists of a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type parameter"}]},{"type":"text","text":" followed by"},{"type":"text","text":" "},{"type":"text","text":"an optional "},{"type":"emphasis","inlineContent":[{"type":"text","text":"constraint"}]},{"type":"text","text":". A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type parameter"}]},{"type":"text","text":" is simply the name"},{"type":"text","text":" "},{"type":"text","text":"of a placeholder type"},{"type":"text","text":" "},{"type":"text","text":"(for example, "},{"type":"codeVoice","code":"T"},{"type":"text","text":", "},{"type":"codeVoice","code":"U"},{"type":"text","text":", "},{"type":"codeVoice","code":"V"},{"type":"text","text":", "},{"type":"codeVoice","code":"Key"},{"type":"text","text":", "},{"type":"codeVoice","code":"Value"},{"type":"text","text":", and so on)."},{"type":"text","text":" "},{"type":"text","text":"You have access to the type parameters (and any of their associated types) in the rest of the"},{"type":"text","text":" "},{"type":"text","text":"type, function, or initializer declaration, including in the signature of the function"},{"type":"text","text":" "},{"type":"text","text":"or initializer."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"constraint"}]},{"type":"text","text":" specifies that a type parameter inherits"},{"type":"text","text":" "},{"type":"text","text":"from a specific class or conforms to a protocol or protocol composition."},{"type":"text","text":" "},{"type":"text","text":"For example, in the generic function below, the generic parameter "},{"type":"codeVoice","code":"T: Comparable"},{"type":"text","text":" "},{"type":"text","text":"indicates that any type argument substituted"},{"type":"text","text":" "},{"type":"text","text":"for the type parameter "},{"type":"codeVoice","code":"T"},{"type":"text","text":" must conform to the "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" protocol."}]},{"type":"codeListing","syntax":"swift","code":["func simpleMax<T: Comparable>(_ x: T, _ y: T) -> T {","   if x < y {","      return y","   }","   return x","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Double"},{"type":"text","text":", for example, both conform to the "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"this function accepts arguments of either type. In contrast with generic types, you don’t"},{"type":"text","text":" "},{"type":"text","text":"specify a generic argument clause when you use a generic function or initializer."},{"type":"text","text":" "},{"type":"text","text":"The type arguments are instead inferred from the type of the arguments passed"},{"type":"text","text":" "},{"type":"text","text":"to the function or initializer."}]},{"type":"codeListing","syntax":"swift","code":["simpleMax(17, 42) \/\/ T is inferred to be Int","simpleMax(3.14159, 2.71828) \/\/ T is inferred to be Double"]},{"anchor":"Generic-Where-Clauses","level":3,"type":"heading","text":"Generic Where Clauses"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can specify additional requirements on type parameters and their associated types"},{"type":"text","text":" "},{"type":"text","text":"by including a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause right before the opening curly brace"},{"type":"text","text":" "},{"type":"text","text":"of a type or function’s body."},{"type":"text","text":" "},{"type":"text","text":"A generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause consists of the "},{"type":"codeVoice","code":"where"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"followed by a comma-separated list of one or more "},{"type":"emphasis","inlineContent":[{"type":"text","text":"requirements"}]},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["where <#requirements#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"requirements"}]},{"type":"text","text":" in a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause specify that a type parameter inherits from"},{"type":"text","text":" "},{"type":"text","text":"a class or conforms to a protocol or protocol composition."},{"type":"text","text":" "},{"type":"text","text":"Although the generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause provides syntactic"},{"type":"text","text":" "},{"type":"text","text":"sugar for expressing simple constraints on type parameters"},{"type":"text","text":" "},{"type":"text","text":"(for example, "},{"type":"codeVoice","code":"<T: Comparable>"},{"type":"text","text":" is equivalent to "},{"type":"codeVoice","code":"<T> where T: Comparable"},{"type":"text","text":" and so on),"},{"type":"text","text":" "},{"type":"text","text":"you can use it to provide more complex constraints on type parameters"},{"type":"text","text":" "},{"type":"text","text":"and their associated types. For example,"},{"type":"text","text":" "},{"type":"text","text":"you can constrain the associated types of type parameters to conform to protocols."},{"type":"text","text":" "},{"type":"text","text":"For example, "},{"type":"codeVoice","code":"<S: Sequence> where S.Iterator.Element: Equatable"},{"type":"text","text":" "},{"type":"text","text":"specifies that "},{"type":"codeVoice","code":"S"},{"type":"text","text":" conforms to the "},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"and that the associated type "},{"type":"codeVoice","code":"S.Iterator.Element"},{"type":"text","text":" "},{"type":"text","text":"conforms to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"This constraint ensures that each element of the sequence is equatable."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also specify the requirement that two types be identical,"},{"type":"text","text":" "},{"type":"text","text":"using the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator. For example,"},{"type":"text","text":" "},{"type":"codeVoice","code":"<S1: Sequence, S2: Sequence> where S1.Iterator.Element == S2.Iterator.Element"},{"type":"text","text":" "},{"type":"text","text":"expresses the constraints that "},{"type":"codeVoice","code":"S1"},{"type":"text","text":" and "},{"type":"codeVoice","code":"S2"},{"type":"text","text":" conform to the "},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"and that the elements of both sequences must be of the same type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any type argument substituted for a type parameter must"},{"type":"text","text":" "},{"type":"text","text":"meet all the constraints and requirements placed on the type parameter."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause can appear"},{"type":"text","text":" "},{"type":"text","text":"as part of a declaration that includes type parameters,"},{"type":"text","text":" "},{"type":"text","text":"or as part of a declaration"},{"type":"text","text":" "},{"type":"text","text":"that’s nested inside of a declaration that includes type parameters."},{"type":"text","text":" "},{"type":"text","text":"The generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause for a nested declaration"},{"type":"text","text":" "},{"type":"text","text":"can still refer to the type parameters of the enclosing declaration;"},{"type":"text","text":" "},{"type":"text","text":"however,"},{"type":"text","text":" "},{"type":"text","text":"the requirements from that "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause"},{"type":"text","text":" "},{"type":"text","text":"apply only to the declaration where it’s written."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the enclosing declaration also has a "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause,"},{"type":"text","text":" "},{"type":"text","text":"the requirements from both clauses are combined."},{"type":"text","text":" "},{"type":"text","text":"In the example below, "},{"type":"codeVoice","code":"startsWithZero()"},{"type":"text","text":" is available"},{"type":"text","text":" "},{"type":"text","text":"only if "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" conforms to both "},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Numeric"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["extension Collection where Element: SomeProtocol {","    func startsWithZero() -> Bool where Element: Numeric {","        return first == .zero","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can overload a generic function or initializer by providing different"},{"type":"text","text":" "},{"type":"text","text":"constraints, requirements, or both on the type parameters."},{"type":"text","text":" "},{"type":"text","text":"When you call an overloaded generic function or initializer,"},{"type":"text","text":" "},{"type":"text","text":"the compiler uses these constraints to resolve which overloaded function"},{"type":"text","text":" "},{"type":"text","text":"or initializer to invoke."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses and to see an example"},{"type":"text","text":" "},{"type":"text","text":"of one in a generic function declaration,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Where-Clauses"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a generic parameter clause","","generic-parameter-clause --> ``<`` generic-parameter-list ``>``","generic-parameter-list --> generic-parameter | generic-parameter ``,`` generic-parameter-list","generic-parameter --> type-name","generic-parameter --> type-name ``:`` type-identifier","generic-parameter --> type-name ``:`` protocol-composition-type","","generic-where-clause --> ``where`` requirement-list","requirement-list --> requirement | requirement ``,`` requirement-list","requirement --> conformance-requirement | same-type-requirement","","conformance-requirement --> type-identifier ``:`` type-identifier","conformance-requirement --> type-identifier ``:`` protocol-composition-type","same-type-requirement --> type-identifier ``==`` type"]},{"anchor":"Generic-Argument-Clause","level":2,"type":"heading","text":"Generic Argument Clause"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic argument clause"}]},{"type":"text","text":" specifies the type arguments of a generic"},{"type":"text","text":" "},{"type":"text","text":"type."},{"type":"text","text":" "},{"type":"text","text":"A generic argument clause is enclosed in angle brackets (<>)"},{"type":"text","text":" "},{"type":"text","text":"and has the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<<#generic argument list#>>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic argument list"}]},{"type":"text","text":" is a comma-separated list of type arguments."},{"type":"text","text":" "},{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type argument"}]},{"type":"text","text":" is the name of an actual concrete type that replaces"},{"type":"text","text":" "},{"type":"text","text":"a corresponding type parameter in the generic parameter clause of a generic type."},{"type":"text","text":" "},{"type":"text","text":"The result is a specialized version of that generic type."},{"type":"text","text":" "},{"type":"text","text":"The example below shows a simplified version of the Swift standard library’s"},{"type":"text","text":" "},{"type":"text","text":"generic dictionary type."}]},{"type":"codeListing","syntax":"swift","code":["struct Dictionary<Key: Hashable, Value>: Collection, ExpressibleByDictionaryLiteral {","    \/* ... *\/","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The specialized version of the generic "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" type, "},{"type":"codeVoice","code":"Dictionary<String, Int>"},{"type":"text","text":" "},{"type":"text","text":"is formed by replacing the generic parameters "},{"type":"codeVoice","code":"Key: Hashable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" "},{"type":"text","text":"with the concrete type arguments "},{"type":"codeVoice","code":"String"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Int"},{"type":"text","text":". Each type argument must satisfy"},{"type":"text","text":" "},{"type":"text","text":"all the constraints of the generic parameter it replaces, including any additional"},{"type":"text","text":" "},{"type":"text","text":"requirements specified in a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause. In the example above,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Key"},{"type":"text","text":" type parameter is constrained to conform to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"and therefore "},{"type":"codeVoice","code":"String"},{"type":"text","text":" must also conform to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also replace a type parameter with a type argument that’s itself"},{"type":"text","text":" "},{"type":"text","text":"a specialized version of a generic type (provided it satisfies the appropriate"},{"type":"text","text":" "},{"type":"text","text":"constraints and requirements). For example, you can replace the type parameter"},{"type":"text","text":" "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" in "},{"type":"codeVoice","code":"Array<Element>"},{"type":"text","text":" with a specialized version of an array, "},{"type":"codeVoice","code":"Array<Int>"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"to form an array whose elements are themselves arrays of integers."}]},{"type":"codeListing","syntax":"swift","code":["let arrayOfArrays: Array<Array<Int>> = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As mentioned in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/GenericParametersAndArguments#Generic-Parameter-Clause"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"you don’t use a generic argument clause to specify the type arguments"},{"type":"text","text":" "},{"type":"text","text":"of a generic function or initializer."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a generic argument clause","","generic-argument-clause --> ``<`` generic-argument-list ``>``","generic-argument-list --> generic-argument | generic-argument ``,`` generic-argument-list","generic-argument --> type"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/genericparametersandarguments"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/GenericParametersAndArguments","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"This chapter describes parameters and arguments for generic types, functions, and"},{"type":"text","text":" "},{"type":"text","text":"initializers. When you declare a generic type, function, subscript, or initializer,"},{"type":"text","text":" "},{"type":"text","text":"you specify the type parameters that the generic type, function, or initializer"},{"type":"text","text":" "},{"type":"text","text":"can work with. These type parameters act as placeholders that"},{"type":"text","text":" "},{"type":"text","text":"are replaced by actual concrete type arguments when an instance of a generic type is"},{"type":"text","text":" "},{"type":"text","text":"created or a generic function or initializer is called."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Generic Parameters and Arguments","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Reference","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AboutTheLanguageReference","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Types","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Statements","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns"],"generated":true}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Patterns":{"role":"article","title":"Patterns","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" represents the structure of a single value"},{"type":"text","text":" "},{"type":"text","text":"or a composite value."},{"type":"text","text":" "},{"type":"text","text":"For example, the structure of a tuple "},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" is a comma-separated list of two"},{"type":"text","text":" "},{"type":"text","text":"elements. Because patterns represent the structure of a value rather than any"},{"type":"text","text":" "},{"type":"text","text":"one particular value, you can match them with a variety of values."},{"type":"text","text":" "},{"type":"text","text":"For instance, the pattern "},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":" matches the tuple "},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" and any other"},{"type":"text","text":" "},{"type":"text","text":"two-element tuple. In addition to matching a pattern with a value,"},{"type":"text","text":" "},{"type":"text","text":"you can extract part or all of a composite value and bind each part"},{"type":"text","text":" "},{"type":"text","text":"to a constant or variable name."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/patterns"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes":{"role":"article","title":"Attributes","abstract":[{"type":"text","text":"There are two kinds of attributes in Swift —"},{"type":"text","text":" "},{"type":"text","text":"those that apply to declarations and those that apply to types."},{"type":"text","text":" "},{"type":"text","text":"An attribute provides additional information about the declaration or type."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"discardableResult"},{"type":"text","text":" attribute on a function declaration indicates that,"},{"type":"text","text":" "},{"type":"text","text":"although the function returns a value,"},{"type":"text","text":" "},{"type":"text","text":"the compiler shouldn’t generate a warning if the return value is unused."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/attributes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"role":"article","title":"Generics","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types"},{"type":"text","text":" "},{"type":"text","text":"that can work with any type, subject to requirements that you define."},{"type":"text","text":" "},{"type":"text","text":"You can write code that avoids duplication"},{"type":"text","text":" "},{"type":"text","text":"and expresses its intent in a clear, abstracted manner."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions":{"role":"article","title":"Expressions","abstract":[{"type":"text","text":"In Swift, there are four kinds of expressions:"},{"type":"text","text":" "},{"type":"text","text":"prefix expressions, infix expressions, primary expressions, and postfix expressions."},{"type":"text","text":" "},{"type":"text","text":"Evaluating an expression returns a value,"},{"type":"text","text":" "},{"type":"text","text":"causes a side effect, or both."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/expressions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Statements":{"role":"article","title":"Statements","abstract":[{"type":"text","text":"In Swift, there are three kinds of statements: simple statements, compiler control statements,"},{"type":"text","text":" "},{"type":"text","text":"and control flow statements."},{"type":"text","text":" "},{"type":"text","text":"Simple statements are the most common and consist of either an expression or a declaration."},{"type":"text","text":" "},{"type":"text","text":"Compiler control statements allow the program to change aspects of the compiler’s behavior"},{"type":"text","text":" "},{"type":"text","text":"and include a conditional compilation block and a line control statement."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Statements","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/statements"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/LexicalStructure":{"role":"article","title":"Lexical Structure","abstract":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"lexical structure"}]},{"type":"text","text":" of Swift describes what sequence of characters"},{"type":"text","text":" "},{"type":"text","text":"form valid tokens of the language."},{"type":"text","text":" "},{"type":"text","text":"These valid tokens form the lowest-level building blocks of the language"},{"type":"text","text":" "},{"type":"text","text":"and are used to describe the rest of the language in subsequent chapters."},{"type":"text","text":" "},{"type":"text","text":"A token consists of an identifier, keyword, punctuation, literal, or operator."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/lexicalstructure"},"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Generic-Where-Clauses":{"abstract":[],"title":"Generic Where Clauses","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Where-Clauses","url":"\/documentation\/the-swift-programming-language\/generics#Generic-Where-Clauses"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Types":{"role":"article","title":"Tipos","abstract":[{"type":"text","text":"Em Swift, existem dois tipos de dados: tipos nomeados e tipos compostos."},{"type":"text","text":" "},{"type":"text","text":"Um "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipo nomeado"}]},{"type":"text","text":" é um tipo que pode receber um nome específico quando é definido."},{"type":"text","text":" "},{"type":"text","text":"Tipos nomeados incluem classes, structs, enums, e protocolos."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, instâncias de uma classe definida pelo usuário chamada "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":"  tem o tipo "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Além dos tipos nomeados definidos pelo usuário, a biblioteca padrão do Swift define muitos tipos nomeados que são usados com mais frequência, incluindo aqueles que representam arrays, dicionários, e valores opcionais."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Types","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations":{"role":"article","title":"Declarations","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"declaration"}]},{"type":"text","text":" introduces a new name or construct into your program."},{"type":"text","text":" "},{"type":"text","text":"For example, you use declarations to introduce functions and methods,"},{"type":"text","text":" "},{"type":"text","text":"to introduce variables and constants,"},{"type":"text","text":" "},{"type":"text","text":"and to define enumeration, structure, class, and protocol types."},{"type":"text","text":" "},{"type":"text","text":"You can also use a declaration to extend the behavior"},{"type":"text","text":" "},{"type":"text","text":"of an existing named type and to import symbols into your program that are declared elsewhere."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/declarations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/GenericParametersAndArguments#Generic-Parameter-Clause":{"abstract":[],"title":"Generic Parameter Clause","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/GenericParametersAndArguments#Generic-Parameter-Clause","url":"\/documentation\/the-swift-programming-language\/genericparametersandarguments#Generic-Parameter-Clause"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AboutTheLanguageReference":{"role":"article","title":"About the Language Reference","abstract":[{"type":"text","text":"This part of the book describes the formal grammar of the Swift programming language."},{"type":"text","text":" "},{"type":"text","text":"The grammar described here is intended to help you understand the language in more"},{"type":"text","text":" "},{"type":"text","text":"detail, rather than to allow you to directly implement a parser or compiler."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AboutTheLanguageReference","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/aboutthelanguagereference"}}}