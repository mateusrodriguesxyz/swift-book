{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Tipos de dados que são normalmente considerados básicos ou primitivos em outras linguagens— tal como os tipos que representam números, caracteres, e strings— são na verdade tipos nomeados, definidos e implementados na biblioteca padrão do Swift como structs."},{"type":"text","text":" "},{"type":"text","text":"Porque eles são tipos nomeados, você pode extender seus comportamentos para atender as necessidades do seu programa, usando uma declaração de extension, discutida em "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions"},{"type":"text","text":" e "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Extension-Declaration"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Um "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipo composto"}]},{"type":"text","text":" é um tipo sem uma nome, definido na própria linguagem Swift."},{"type":"text","text":" "},{"type":"text","text":"Existem dois tipos compostos: tipos de função e tipos de tuplas."},{"type":"text","text":" "},{"type":"text","text":"Um tipo composto pode conter tipos nomeados e outros tipos compostos."},{"type":"text","text":" "},{"type":"text","text":"Por examplo, o tipo de tupla "},{"type":"codeVoice","code":"(Int, (Int, Int))"},{"type":"text","text":" contém dois elementos: O primeiro é o tipo nomeado "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", e o segundo é  outro tipo composto "},{"type":"codeVoice","code":"(Int, Int)"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Você pode colocar parênteses ao redor de um tipo nomeado ou de um tipo composto."},{"type":"text","text":" "},{"type":"text","text":"No entanto, adicionar parênteses ao redor de um tipo nomeado não tem nenhum efeito."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, "},{"type":"codeVoice","code":"(Int)"},{"type":"text","text":" é equivalente a "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Este capítulo discute os tipos definidos na própria linguagem Swift e descreve o comportamento de inferência de tipo do Swift."}]},{"type":"codeListing","syntax":"markdown","code":["Gramática de um tipo","","type --> function-type","type --> array-type","type --> dictionary-type","type --> type-identifier","type --> tuple-type","type --> optional-type","type --> implicitly-unwrapped-optional-type","type --> protocol-composition-type","type --> opaque-type","type --> metatype-type","type --> any-type","type --> self-type","type --> ``(`` type ``)``"]},{"anchor":"Type-Annotation","level":2,"type":"heading","text":"Type Annotation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Uma "},{"type":"emphasis","inlineContent":[{"type":"text","text":"anotação de tipo"}]},{"type":"text","text":" especifica explicitamente o tipo de uma variável ou expressão."},{"type":"text","text":" "},{"type":"text","text":"Anotações de tipo começam com dois pontos ("},{"type":"codeVoice","code":":"},{"type":"text","text":") e terminam com um tipo, como mostram os exemplos a seguir:"}]},{"type":"codeListing","syntax":"swift","code":["let someTuple: (Double, Double) = (3.14159, 2.71828)","func someFunction(a: Int) { \/* ... *\/ }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"No primeiro exemplo, a expressão "},{"type":"codeVoice","code":"someTuple"},{"type":"text","text":" é especificada para ter o tipo de tupla "},{"type":"codeVoice","code":"(Double, Double)"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"No segundo exemplo, o parâmetro "},{"type":"codeVoice","code":"a"},{"type":"text","text":" na função "},{"type":"codeVoice","code":"someFunction"},{"type":"text","text":" é especificado para ter o tipo "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Anotações de tipo podem conter uma lista opcional de atributos de tipos antes do tipo."}]},{"type":"codeListing","syntax":"markdown","code":["Gramática de uma anotação de tipo","","type-annotation --> ``:`` attributes-OPT ``inout``-OPT type"]},{"anchor":"Type-Identifier","level":2,"type":"heading","text":"Type Identifier"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type identifier"}]},{"type":"text","text":" refers to either a named type"},{"type":"text","text":" "},{"type":"text","text":"or a type alias of a named or compound type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most of the time, a type identifier directly refers to a named type"},{"type":"text","text":" "},{"type":"text","text":"with the same name as the identifier."},{"type":"text","text":" "},{"type":"text","text":"For example, "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" is a type identifier that directly refers to the named type "},{"type":"codeVoice","code":"Int"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the type identifier "},{"type":"codeVoice","code":"Dictionary<String, Int>"},{"type":"text","text":" directly refers"},{"type":"text","text":" "},{"type":"text","text":"to the named type "},{"type":"codeVoice","code":"Dictionary<String, Int>"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are two cases in which a type identifier doesn’t refer to a type with the same name."},{"type":"text","text":" "},{"type":"text","text":"In the first case, a type identifier refers to a type alias of a named or compound type."},{"type":"text","text":" "},{"type":"text","text":"For instance, in the example below,"},{"type":"text","text":" "},{"type":"text","text":"the use of "},{"type":"codeVoice","code":"Point"},{"type":"text","text":" in the type annotation refers to the tuple type "},{"type":"codeVoice","code":"(Int, Int)"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["typealias Point = (Int, Int)","let origin: Point = (0, 0)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the second case, a type identifier uses dot ("},{"type":"codeVoice","code":"."},{"type":"text","text":") syntax to refer to named types"},{"type":"text","text":" "},{"type":"text","text":"declared in other modules or nested within other types."},{"type":"text","text":" "},{"type":"text","text":"For example, the type identifier in the following code references the named type "},{"type":"codeVoice","code":"MyType"},{"type":"text","text":" "},{"type":"text","text":"that’s declared in the "},{"type":"codeVoice","code":"ExampleModule"},{"type":"text","text":" module."}]},{"type":"codeListing","syntax":"swift","code":["var someValue: ExampleModule.MyType"]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a type identifier","","type-identifier --> type-name generic-argument-clause-OPT | type-name generic-argument-clause-OPT ``.`` type-identifier","type-name --> identifier"]},{"anchor":"Tuple-Type","level":2,"type":"heading","text":"Tuple Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple type"}]},{"type":"text","text":" is a comma-separated list of types, enclosed in parentheses."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use a tuple type as the return type of a function"},{"type":"text","text":" "},{"type":"text","text":"to enable the function to return a single tuple containing multiple values."},{"type":"text","text":" "},{"type":"text","text":"You can also name the elements of a tuple type and use those names to refer to"},{"type":"text","text":" "},{"type":"text","text":"the values of the individual elements. An element name consists of an identifier"},{"type":"text","text":" "},{"type":"text","text":"followed immediately by a colon (:). For an example that demonstrates both of"},{"type":"text","text":" "},{"type":"text","text":"these features, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Functions-with-Multiple-Return-Values"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When an element of a tuple type has a name,"},{"type":"text","text":" "},{"type":"text","text":"that name is part of the type."}]},{"type":"codeListing","syntax":"swift","code":["var someTuple = (top: 10, bottom: 12)  \/\/ someTuple is of type (top: Int, bottom: Int)","someTuple = (top: 4, bottom: 42) \/\/ OK: names match","someTuple = (9, 99)              \/\/ OK: names are inferred","someTuple = (left: 5, right: 5)  \/\/ Error: names don't match"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All tuple types contain two or more types,"},{"type":"text","text":" "},{"type":"text","text":"except for "},{"type":"codeVoice","code":"Void"},{"type":"text","text":" which is a type alias for the empty tuple type, "},{"type":"codeVoice","code":"()"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a tuple type","","tuple-type --> ``(`` ``)`` | ``(`` tuple-type-element ``,`` tuple-type-element-list ``)``","tuple-type-element-list --> tuple-type-element | tuple-type-element ``,`` tuple-type-element-list","tuple-type-element --> element-name type-annotation | type","element-name --> identifier"]},{"anchor":"Function-Type","level":2,"type":"heading","text":"Function Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function type"}]},{"type":"text","text":" represents the type of a function, method, or closure"},{"type":"text","text":" "},{"type":"text","text":"and consists of a parameter and return type separated by an arrow ("},{"type":"codeVoice","code":"->"},{"type":"text","text":"):"}]},{"type":"codeListing","syntax":"markdown","code":["(<#parameter type#>) -> <#return type#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"parameter type"}]},{"type":"text","text":" is comma-separated list of types."},{"type":"text","text":" "},{"type":"text","text":"Because the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"return type"}]},{"type":"text","text":" can be a tuple type,"},{"type":"text","text":" "},{"type":"text","text":"function types support functions and methods"},{"type":"text","text":" "},{"type":"text","text":"that return multiple values."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter of the function type "},{"type":"codeVoice","code":"() -> T"},{"type":"text","text":" "},{"type":"text","text":"(where "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is any type)"},{"type":"text","text":" "},{"type":"text","text":"can apply the "},{"type":"codeVoice","code":"autoclosure"},{"type":"text","text":" attribute"},{"type":"text","text":" "},{"type":"text","text":"to implicitly create a closure at its call sites."},{"type":"text","text":" "},{"type":"text","text":"This provides a syntactically convenient way"},{"type":"text","text":" "},{"type":"text","text":"to defer the evaluation of an expression"},{"type":"text","text":" "},{"type":"text","text":"without needing to write an explicit closure"},{"type":"text","text":" "},{"type":"text","text":"when you call the function."},{"type":"text","text":" "},{"type":"text","text":"For an example of an autoclosure function type parameter,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Autoclosures"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A function type can have variadic parameters in its "},{"type":"emphasis","inlineContent":[{"type":"text","text":"parameter type"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Syntactically,"},{"type":"text","text":" "},{"type":"text","text":"a variadic parameter consists of a base type name followed immediately by three dots ("},{"type":"codeVoice","code":"..."},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"as in "},{"type":"codeVoice","code":"Int..."},{"type":"text","text":". A variadic parameter is treated as an array that contains elements"},{"type":"text","text":" "},{"type":"text","text":"of the base type name. For instance, the variadic parameter "},{"type":"codeVoice","code":"Int..."},{"type":"text","text":" is treated"},{"type":"text","text":" "},{"type":"text","text":"as "},{"type":"codeVoice","code":"[Int]"},{"type":"text","text":". For an example that uses a variadic parameter,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Variadic-Parameters"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To specify an in-out parameter, prefix the parameter type with the "},{"type":"codeVoice","code":"inout"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"You can’t mark a variadic parameter or a return type with the "},{"type":"codeVoice","code":"inout"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"In-out parameters are discussed in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a function type has only one parameter"},{"type":"text","text":" "},{"type":"text","text":"and that parameter’s type is a tuple type,"},{"type":"text","text":" "},{"type":"text","text":"then the tuple type must be parenthesized when writing the function’s type."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"codeVoice","code":"((Int, Int)) -> Void"},{"type":"text","text":" "},{"type":"text","text":"is the type of a function that takes a single parameter"},{"type":"text","text":" "},{"type":"text","text":"of the tuple type "},{"type":"codeVoice","code":"(Int, Int)"},{"type":"text","text":" "},{"type":"text","text":"and doesn’t return any value."},{"type":"text","text":" "},{"type":"text","text":"In contrast, without parentheses,"},{"type":"text","text":" "},{"type":"codeVoice","code":"(Int, Int) -> Void"},{"type":"text","text":" is the type"},{"type":"text","text":" "},{"type":"text","text":"of a function that takes two "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" parameters"},{"type":"text","text":" "},{"type":"text","text":"and doesn’t return any value."},{"type":"text","text":" "},{"type":"text","text":"Likewise, because "},{"type":"codeVoice","code":"Void"},{"type":"text","text":" is a type alias for "},{"type":"codeVoice","code":"()"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the function type "},{"type":"codeVoice","code":"(Void) -> Void"},{"type":"text","text":" "},{"type":"text","text":"is the same as "},{"type":"codeVoice","code":"(()) -> ()"},{"type":"text","text":" —"},{"type":"text","text":" "},{"type":"text","text":"a function that takes a single argument that’s an empty tuple."},{"type":"text","text":" "},{"type":"text","text":"These types aren’t the same as "},{"type":"codeVoice","code":"() -> ()"},{"type":"text","text":" —"},{"type":"text","text":" "},{"type":"text","text":"a function that takes no arguments."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Argument names in functions and methods"},{"type":"text","text":" "},{"type":"text","text":"aren’t part of the corresponding function type."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["func someFunction(left: Int, right: Int) {}","func anotherFunction(left: Int, right: Int) {}","func functionWithDifferentLabels(top: Int, bottom: Int) {}","","var f = someFunction \/\/ The type of f is (Int, Int) -> Void, not (left: Int, right: Int) -> Void.","f = anotherFunction              \/\/ OK","f = functionWithDifferentLabels  \/\/ OK","","func functionWithDifferentArgumentTypes(left: Int, right: String) {}","f = functionWithDifferentArgumentTypes     \/\/ Error","","func functionWithDifferentNumberOfArguments(left: Int, right: Int, top: Int) {}","f = functionWithDifferentNumberOfArguments \/\/ Error"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because argument labels aren’t part of a function’s type,"},{"type":"text","text":" "},{"type":"text","text":"you omit them when writing a function type."}]},{"type":"codeListing","syntax":"swift","code":["var operation: (lhs: Int, rhs: Int) -> Int     \/\/ Error","var operation: (_ lhs: Int, _ rhs: Int) -> Int \/\/ OK","var operation: (Int, Int) -> Int               \/\/ OK"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a function type includes more than a single arrow ("},{"type":"codeVoice","code":"->"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"the function types are grouped from right to left."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the function type "},{"type":"codeVoice","code":"(Int) -> (Int) -> Int"},{"type":"text","text":" is understood as "},{"type":"codeVoice","code":"(Int) -> ((Int) -> Int)"},{"type":"text","text":" —"},{"type":"text","text":" "},{"type":"text","text":"that is, a function that takes an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" and returns"},{"type":"text","text":" "},{"type":"text","text":"another function that takes and returns an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Function types for functions"},{"type":"text","text":" "},{"type":"text","text":"that can throw or rethrow an error must be marked with the "},{"type":"codeVoice","code":"throws"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"throws"},{"type":"text","text":" keyword is part of a function’s type,"},{"type":"text","text":" "},{"type":"text","text":"and nonthrowing functions are subtypes of throwing functions."},{"type":"text","text":" "},{"type":"text","text":"As a result, you can use a nonthrowing function in the same places as a throwing one."},{"type":"text","text":" "},{"type":"text","text":"Throwing and rethrowing functions are described in"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Throwing-Functions-and-Methods"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Rethrowing-Functions-and-Methods"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Function types for asynchronous functions"},{"type":"text","text":" "},{"type":"text","text":"must be marked with the "},{"type":"codeVoice","code":"async"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"async"},{"type":"text","text":" keyword is part of a function’s type,"},{"type":"text","text":" "},{"type":"text","text":"and synchronous functions are subtypes of asynchronous functions."},{"type":"text","text":" "},{"type":"text","text":"As a result, you can use a synchronous function"},{"type":"text","text":" "},{"type":"text","text":"in the same places as an asynchronous one."},{"type":"text","text":" "},{"type":"text","text":"For information about asynchronous functions,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Asynchronous-Functions-and-Methods"},{"type":"text","text":"."}]},{"anchor":"Restrictions-for-Nonescaping-Closures","level":3,"type":"heading","text":"Restrictions for Nonescaping Closures"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter that’s a nonescaping function"},{"type":"text","text":" "},{"type":"text","text":"can’t be stored in a property, variable, or constant of type "},{"type":"codeVoice","code":"Any"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"because that might allow the value to escape."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter that’s a nonescaping function"},{"type":"text","text":" "},{"type":"text","text":"can’t be passed as an argument to another nonescaping function parameter."},{"type":"text","text":" "},{"type":"text","text":"This restriction helps Swift perform"},{"type":"text","text":" "},{"type":"text","text":"more of its checks for conflicting access to memory"},{"type":"text","text":" "},{"type":"text","text":"at compile time instead of at runtime."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["let external: (() -> Void) -> Void = { _ in () }","func takesTwoFunctions(first: (() -> Void) -> Void, second: (() -> Void) -> Void) {","    first { first {} }       \/\/ Error","    second { second {}  }    \/\/ Error","","    first { second {} }      \/\/ Error","    second { first {} }      \/\/ Error","","    first { external {} }    \/\/ OK","    external { first {} }    \/\/ OK","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above,"},{"type":"text","text":" "},{"type":"text","text":"both of the parameters to "},{"type":"codeVoice","code":"takesTwoFunctions(first:second:)"},{"type":"text","text":" are functions."},{"type":"text","text":" "},{"type":"text","text":"Neither parameter is marked "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"so they’re both nonescaping as a result."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The four function calls marked “Error” in the example above"},{"type":"text","text":" "},{"type":"text","text":"cause compiler errors."},{"type":"text","text":" "},{"type":"text","text":"Because the "},{"type":"codeVoice","code":"first"},{"type":"text","text":" and "},{"type":"codeVoice","code":"second"},{"type":"text","text":" parameters"},{"type":"text","text":" "},{"type":"text","text":"are nonescaping functions,"},{"type":"text","text":" "},{"type":"text","text":"they can’t be passed as arguments to another nonescaping function parameter."},{"type":"text","text":" "},{"type":"text","text":"In contrast,"},{"type":"text","text":" "},{"type":"text","text":"the two function calls marked “OK” don’t cause a compiler error."},{"type":"text","text":" "},{"type":"text","text":"These function calls don’t violate the restriction"},{"type":"text","text":" "},{"type":"text","text":"because "},{"type":"codeVoice","code":"external"},{"type":"text","text":" isn’t one of the parameters of "},{"type":"codeVoice","code":"takesTwoFunctions(first:second:)"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you need to avoid this restriction, mark one of the parameters as escaping,"},{"type":"text","text":" "},{"type":"text","text":"or temporarily convert one of the nonescaping function parameters to an escaping function"},{"type":"text","text":" "},{"type":"text","text":"by using the "},{"type":"codeVoice","code":"withoutActuallyEscaping(_:do:)"},{"type":"text","text":" function."},{"type":"text","text":" "},{"type":"text","text":"For information about avoiding conflicting access to memory,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a function type","","function-type --> attributes-OPT function-type-argument-clause ``async``-OPT ``throws``-OPT ``->`` type","","function-type-argument-clause --> ``(`` ``)``","function-type-argument-clause --> ``(`` function-type-argument-list ``...``-OPT ``)``","","function-type-argument-list --> function-type-argument | function-type-argument ``,`` function-type-argument-list","function-type-argument --> attributes-OPT ``inout``-OPT type | argument-label type-annotation","argument-label --> identifier"]},{"anchor":"Array-Type","level":2,"type":"heading","text":"Array Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Swift language provides the following syntactic sugar for the Swift standard library"},{"type":"text","text":" "},{"type":"codeVoice","code":"Array<Element>"},{"type":"text","text":" type:"}]},{"type":"codeListing","syntax":"markdown","code":["[<#type#>]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In other words, the following two declarations are equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["let someArray: Array<String> = [\"Alex\", \"Brian\", \"Dave\"]","let someArray: [String] = [\"Alex\", \"Brian\", \"Dave\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In both cases, the constant "},{"type":"codeVoice","code":"someArray"},{"type":"text","text":" "},{"type":"text","text":"is declared as an array of strings. The elements of an array can be accessed"},{"type":"text","text":" "},{"type":"text","text":"through subscripting by specifying a valid index value in square brackets:"},{"type":"text","text":" "},{"type":"codeVoice","code":"someArray[0]"},{"type":"text","text":" refers to the element at index 0, "},{"type":"codeVoice","code":"\"Alex\""},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can create multidimensional arrays by nesting pairs of square brackets,"},{"type":"text","text":" "},{"type":"text","text":"where the name of the base type of the elements is contained in the innermost"},{"type":"text","text":" "},{"type":"text","text":"pair of square brackets."},{"type":"text","text":" "},{"type":"text","text":"For example, you can create"},{"type":"text","text":" "},{"type":"text","text":"a three-dimensional array of integers using three sets of square brackets:"}]},{"type":"codeListing","syntax":"swift","code":["var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When accessing the elements in a multidimensional array,"},{"type":"text","text":" "},{"type":"text","text":"the left-most subscript index refers to the element at that index in the outermost"},{"type":"text","text":" "},{"type":"text","text":"array. The next subscript index to the right refers to the element"},{"type":"text","text":" "},{"type":"text","text":"at that index in the array that’s nested one level in. And so on. This means that in"},{"type":"text","text":" "},{"type":"text","text":"the example above, "},{"type":"codeVoice","code":"array3D[0]"},{"type":"text","text":" refers to "},{"type":"codeVoice","code":"[[1, 2], [3, 4]]"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"codeVoice","code":"array3D[0][1]"},{"type":"text","text":" refers to "},{"type":"codeVoice","code":"[3, 4]"},{"type":"text","text":", and "},{"type":"codeVoice","code":"array3D[0][1][1]"},{"type":"text","text":" refers to the value 4."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For a detailed discussion of the Swift standard library "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" type,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Arrays"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an array type","","array-type --> ``[`` type ``]``"]},{"anchor":"Dictionary-Type","level":2,"type":"heading","text":"Dictionary Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Swift language provides the following syntactic sugar for the Swift standard library"},{"type":"text","text":" "},{"type":"codeVoice","code":"Dictionary<Key, Value>"},{"type":"text","text":" type:"}]},{"type":"codeListing","syntax":"markdown","code":["[<#key type#>: <#value type#>]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In other words, the following two declarations are equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["let someDictionary: [String: Int] = [\"Alex\": 31, \"Paul\": 39]","let someDictionary: Dictionary<String, Int> = [\"Alex\": 31, \"Paul\": 39]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In both cases, the constant "},{"type":"codeVoice","code":"someDictionary"},{"type":"text","text":" "},{"type":"text","text":"is declared as a dictionary with strings as keys and integers as values."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The values of a dictionary can be accessed through subscripting"},{"type":"text","text":" "},{"type":"text","text":"by specifying the corresponding key in"},{"type":"text","text":" "},{"type":"text","text":"square brackets: "},{"type":"codeVoice","code":"someDictionary[\"Alex\"]"},{"type":"text","text":" refers to the value associated"},{"type":"text","text":" "},{"type":"text","text":"with the key "},{"type":"codeVoice","code":"\"Alex\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The subscript returns an optional value of the dictionary’s value type."},{"type":"text","text":" "},{"type":"text","text":"If the specified key isn’t contained in the dictionary,"},{"type":"text","text":" "},{"type":"text","text":"the subscript returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The key type of a dictionary must conform to the Swift standard library "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For a detailed discussion of the Swift standard library "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" type,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Dictionaries"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a dictionary type","","dictionary-type --> ``[`` type ``:`` type ``]``"]},{"anchor":"Optional-Type","level":2,"type":"heading","text":"Optional Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Swift language defines the postfix "},{"type":"codeVoice","code":"?"},{"type":"text","text":" as syntactic sugar for"},{"type":"text","text":" "},{"type":"text","text":"the named type "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":", which is defined in the Swift standard library."},{"type":"text","text":" "},{"type":"text","text":"In other words, the following two declarations are equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["var optionalInteger: Int?","var optionalInteger: Optional<Int>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In both cases, the variable "},{"type":"codeVoice","code":"optionalInteger"},{"type":"text","text":" "},{"type":"text","text":"is declared to have the type of an optional integer."},{"type":"text","text":" "},{"type":"text","text":"Note that no whitespace may appear between the type and the "},{"type":"codeVoice","code":"?"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The type "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" is an enumeration with two cases, "},{"type":"codeVoice","code":"none"},{"type":"text","text":" and "},{"type":"codeVoice","code":"some(Wrapped)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which are used to represent values that may or may not be present."},{"type":"text","text":" "},{"type":"text","text":"Any type can be explicitly declared to be (or implicitly converted to) an optional type."},{"type":"text","text":" "},{"type":"text","text":"If you don’t provide an initial value when you declare an"},{"type":"text","text":" "},{"type":"text","text":"optional variable or property, its value automatically defaults to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If an instance of an optional type contains a value,"},{"type":"text","text":" "},{"type":"text","text":"you can access that value using the postfix operator "},{"type":"codeVoice","code":"!"},{"type":"text","text":", as shown below:"}]},{"type":"codeListing","syntax":"swift","code":["optionalInteger = 42","optionalInteger! \/\/ 42"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using the "},{"type":"codeVoice","code":"!"},{"type":"text","text":" operator to unwrap an optional"},{"type":"text","text":" "},{"type":"text","text":"that has a value of "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" results in a runtime error."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also use optional chaining and optional binding to conditionally perform an"},{"type":"text","text":" "},{"type":"text","text":"operation on an optional expression. If the value is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"no operation is performed and therefore no runtime error is produced."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information and to see examples that show how to use optional types,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics#Optionals"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an optional type","","optional-type --> type ``?``"]},{"anchor":"Implicitly-Unwrapped-Optional-Type","level":2,"type":"heading","text":"Implicitly Unwrapped Optional Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Swift language defines the postfix "},{"type":"codeVoice","code":"!"},{"type":"text","text":" as syntactic sugar for"},{"type":"text","text":" "},{"type":"text","text":"the named type "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":", which is defined in the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"with the additional behavior that"},{"type":"text","text":" "},{"type":"text","text":"it’s automatically unwrapped when it’s accessed."},{"type":"text","text":" "},{"type":"text","text":"If you try to use an implicitly unwrapped optional that has a value of "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"you’ll get a runtime error."},{"type":"text","text":" "},{"type":"text","text":"With the exception of the implicit unwrapping behavior,"},{"type":"text","text":" "},{"type":"text","text":"the following two declarations are equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["var implicitlyUnwrappedString: String!","var explicitlyUnwrappedString: Optional<String>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that no whitespace may appear between the type and the "},{"type":"codeVoice","code":"!"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because implicit unwrapping"},{"type":"text","text":" "},{"type":"text","text":"changes the meaning of the declaration that contains that type,"},{"type":"text","text":" "},{"type":"text","text":"optional types that are nested inside a tuple type or a generic type"},{"type":"text","text":" "},{"type":"text","text":"— such as the element types of a dictionary or array —"},{"type":"text","text":" "},{"type":"text","text":"can’t be marked as implicitly unwrapped."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["let tupleOfImplicitlyUnwrappedElements: (Int!, Int!)  \/\/ Error","let implicitlyUnwrappedTuple: (Int, Int)!             \/\/ OK","","let arrayOfImplicitlyUnwrappedElements: [Int!]        \/\/ Error","let implicitlyUnwrappedArray: [Int]!                  \/\/ OK"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because implicitly unwrapped optionals"},{"type":"text","text":" "},{"type":"text","text":"have the same "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" type as optional values,"},{"type":"text","text":" "},{"type":"text","text":"you can use implicitly unwrapped optionals"},{"type":"text","text":" "},{"type":"text","text":"in all the same places in your code"},{"type":"text","text":" "},{"type":"text","text":"that you can use optionals."},{"type":"text","text":" "},{"type":"text","text":"For example, you can assign values of implicitly unwrapped"},{"type":"text","text":" "},{"type":"text","text":"optionals to variables, constants, and properties of optionals, and vice versa."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As with optionals, if you don’t provide an initial value when you declare an"},{"type":"text","text":" "},{"type":"text","text":"implicitly unwrapped optional variable or property,"},{"type":"text","text":" "},{"type":"text","text":"its value automatically defaults to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use optional chaining to conditionally perform an"},{"type":"text","text":" "},{"type":"text","text":"operation on an implicitly unwrapped optional expression."},{"type":"text","text":" "},{"type":"text","text":"If the value is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"no operation is performed and therefore no runtime error is produced."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about implicitly unwrapped optional types,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics#Implicitly-Unwrapped-Optionals"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an implicitly unwrapped optional type","","implicitly-unwrapped-optional-type --> type ``!``"]},{"anchor":"Protocol-Composition-Type","level":2,"type":"heading","text":"Protocol Composition Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol composition type"}]},{"type":"text","text":" defines a type that conforms to each protocol"},{"type":"text","text":" "},{"type":"text","text":"in a list of specified protocols,"},{"type":"text","text":" "},{"type":"text","text":"or a type that’s a subclass of a given class"},{"type":"text","text":" "},{"type":"text","text":"and conforms to each protocol in a list of specified protocols."},{"type":"text","text":" "},{"type":"text","text":"Protocol composition types may be used only when specifying a type"},{"type":"text","text":" "},{"type":"text","text":"in type annotations,"},{"type":"text","text":" "},{"type":"text","text":"in generic parameter clauses,"},{"type":"text","text":" "},{"type":"text","text":"and in generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocol composition types have the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["<#Protocol 1#> & <#Protocol 2#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A protocol composition type allows you to specify a value whose type conforms to the requirements"},{"type":"text","text":" "},{"type":"text","text":"of multiple protocols without explicitly defining a new, named protocol"},{"type":"text","text":" "},{"type":"text","text":"that inherits from each protocol you want the type to conform to."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"you can use the protocol composition type "},{"type":"codeVoice","code":"ProtocolA & ProtocolB & ProtocolC"},{"type":"text","text":" "},{"type":"text","text":"instead of declaring a new protocol"},{"type":"text","text":" "},{"type":"text","text":"that inherits from "},{"type":"codeVoice","code":"ProtocolA"},{"type":"text","text":", "},{"type":"codeVoice","code":"ProtocolB"},{"type":"text","text":", and "},{"type":"codeVoice","code":"ProtocolC"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Likewise, you can use "},{"type":"codeVoice","code":"SuperClass & ProtocolA"},{"type":"text","text":" "},{"type":"text","text":"instead of declaring a new protocol"},{"type":"text","text":" "},{"type":"text","text":"that’s a subclass of "},{"type":"codeVoice","code":"SuperClass"},{"type":"text","text":" and conforms to "},{"type":"codeVoice","code":"ProtocolA"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each item in a protocol composition list is one of the following;"},{"type":"text","text":" "},{"type":"text","text":"the list can contain at most one class:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The name of a class"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The name of a protocol"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A type alias whose underlying type"},{"type":"text","text":" "},{"type":"text","text":"is a protocol composition type, a protocol, or a class."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When a protocol composition type contains type aliases,"},{"type":"text","text":" "},{"type":"text","text":"it’s possible for the same protocol to appear"},{"type":"text","text":" "},{"type":"text","text":"more than once in the definitions —"},{"type":"text","text":" "},{"type":"text","text":"duplicates are ignored."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the definition of "},{"type":"codeVoice","code":"PQR"},{"type":"text","text":" in the code below"},{"type":"text","text":" "},{"type":"text","text":"is equivalent to "},{"type":"codeVoice","code":"P & Q & R"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["typealias PQ = P & Q","typealias PQR = PQ & Q & R"]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a protocol composition type","","protocol-composition-type --> type-identifier ``&`` protocol-composition-continuation","protocol-composition-continuation --> type-identifier | protocol-composition-type"]},{"anchor":"Opaque-Type","level":2,"type":"heading","text":"Opaque Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"opaque type"}]},{"type":"text","text":" defines a type"},{"type":"text","text":" "},{"type":"text","text":"that conforms to a protocol or protocol composition,"},{"type":"text","text":" "},{"type":"text","text":"without specifying the underlying concrete type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Opaque types appear as the return type of a function or subscript,"},{"type":"text","text":" "},{"type":"text","text":"or the type of a property."},{"type":"text","text":" "},{"type":"text","text":"Opaque types can’t appear as part of a tuple type or a generic type,"},{"type":"text","text":" "},{"type":"text","text":"such as the element type of an array or the wrapped type of an optional."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Opaque types have the following form:"}]},{"type":"codeListing","syntax":"markdown","code":["some <#constraint#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"constraint"}]},{"type":"text","text":" is a class type,"},{"type":"text","text":" "},{"type":"text","text":"protocol type,"},{"type":"text","text":" "},{"type":"text","text":"protocol composition type,"},{"type":"text","text":" "},{"type":"text","text":"or "},{"type":"codeVoice","code":"Any"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"A value can be used as an instance of the opaque type"},{"type":"text","text":" "},{"type":"text","text":"only if it’s an instance of a type"},{"type":"text","text":" "},{"type":"text","text":"that conforms to the listed protocol or protocol composition,"},{"type":"text","text":" "},{"type":"text","text":"or inherits from the listed class."},{"type":"text","text":" "},{"type":"text","text":"Code that interacts with an opaque value"},{"type":"text","text":" "},{"type":"text","text":"can use the value only in ways"},{"type":"text","text":" "},{"type":"text","text":"that are part of the interface defined by the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"constraint"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocol declarations can’t include opaque types."},{"type":"text","text":" "},{"type":"text","text":"Classes can’t use an opaque type as the return type of a nonfinal method."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A function that uses an opaque type as its return type"},{"type":"text","text":" "},{"type":"text","text":"must return values that share a single underlying type."},{"type":"text","text":" "},{"type":"text","text":"The return type can include types"},{"type":"text","text":" "},{"type":"text","text":"that are part of the function’s generic type parameters."},{"type":"text","text":" "},{"type":"text","text":"For example, a function "},{"type":"codeVoice","code":"someFunction<T>()"},{"type":"text","text":" "},{"type":"text","text":"could return a value of type "},{"type":"codeVoice","code":"T"},{"type":"text","text":" or "},{"type":"codeVoice","code":"Dictionary<String, T>"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an opaque type","","opaque-type --> ``some`` type"]},{"anchor":"Metatype-Type","level":2,"type":"heading","text":"Metatype Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"metatype type"}]},{"type":"text","text":" refers to the type of any type,"},{"type":"text","text":" "},{"type":"text","text":"including class types, structure types, enumeration types, and protocol types."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The metatype of a class, structure, or enumeration type is"},{"type":"text","text":" "},{"type":"text","text":"the name of that type followed by "},{"type":"codeVoice","code":".Type"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The metatype of a protocol type — not the concrete type that"},{"type":"text","text":" "},{"type":"text","text":"conforms to the protocol at runtime —"},{"type":"text","text":" "},{"type":"text","text":"is the name of that protocol followed by "},{"type":"codeVoice","code":".Protocol"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For example, the metatype of the class type "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" is "},{"type":"codeVoice","code":"SomeClass.Type"},{"type":"text","text":" "},{"type":"text","text":"and the metatype of the protocol "},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":" is "},{"type":"codeVoice","code":"SomeProtocol.Protocol"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use the postfix "},{"type":"codeVoice","code":"self"},{"type":"text","text":" expression to access a type as a value."},{"type":"text","text":" "},{"type":"text","text":"For example, "},{"type":"codeVoice","code":"SomeClass.self"},{"type":"text","text":" returns "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" itself,"},{"type":"text","text":" "},{"type":"text","text":"not an instance of "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"And "},{"type":"codeVoice","code":"SomeProtocol.self"},{"type":"text","text":" returns "},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":" itself,"},{"type":"text","text":" "},{"type":"text","text":"not an instance of a type that conforms to "},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":" at runtime."},{"type":"text","text":" "},{"type":"text","text":"You can call the "},{"type":"codeVoice","code":"type(of:)"},{"type":"text","text":" function with an instance of a type"},{"type":"text","text":" "},{"type":"text","text":"to access that instance’s dynamic, runtime type as a value,"},{"type":"text","text":" "},{"type":"text","text":"as the following example shows:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeBaseClass {","    class func printClassName() {","        print(\"SomeBaseClass\")","    }","}","class SomeSubClass: SomeBaseClass {","    override class func printClassName() {","        print(\"SomeSubClass\")","    }","}","let someInstance: SomeBaseClass = SomeSubClass()","\/\/ The compile-time type of someInstance is SomeBaseClass,","\/\/ and the runtime type of someInstance is SomeSubClass","type(of: someInstance).printClassName()","\/\/ Prints \"SomeSubClass\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type"},{"type":"text","text":" "},{"type":"text","text":"in the Swift standard library."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use an initializer expression to construct an instance of a type"},{"type":"text","text":" "},{"type":"text","text":"from that type’s metatype value."},{"type":"text","text":" "},{"type":"text","text":"For class instances,"},{"type":"text","text":" "},{"type":"text","text":"the initializer that’s called must be marked with the "},{"type":"codeVoice","code":"required"},{"type":"text","text":" keyword"},{"type":"text","text":" "},{"type":"text","text":"or the entire class marked with the "},{"type":"codeVoice","code":"final"},{"type":"text","text":" keyword."}]},{"type":"codeListing","syntax":"swift","code":["class AnotherSubClass: SomeBaseClass {","   let string: String","   required init(string: String) {","      self.string = string","   }","   override class func printClassName() {","      print(\"AnotherSubClass\")","   }","}","let metatype: AnotherSubClass.Type = AnotherSubClass.self","let anotherInstance = metatype.init(string: \"some string\")"]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a metatype type","","metatype-type --> type ``.`` ``Type`` | type ``.`` ``Protocol``"]},{"anchor":"Any-Type","level":2,"type":"heading","text":"Any Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" type can contain values from all other types."},{"type":"text","text":" "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" can be used as the concrete type"},{"type":"text","text":" "},{"type":"text","text":"for an instance of any of the following types:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A class, structure, or enumeration"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A metatype, such as "},{"type":"codeVoice","code":"Int.self"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A tuple with any types of components"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure or function type"}]}]}]},{"type":"codeListing","syntax":"swift","code":["let mixed: [Any] = [\"one\", 2, true, (4, 5.3), { () -> Int in return 6 }]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you use "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" as a concrete type for an instance,"},{"type":"text","text":" "},{"type":"text","text":"you need to cast the instance to a known type"},{"type":"text","text":" "},{"type":"text","text":"before you can access its properties or methods."},{"type":"text","text":" "},{"type":"text","text":"Instances with a concrete type of "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" "},{"type":"text","text":"maintain their original dynamic type"},{"type":"text","text":" "},{"type":"text","text":"and can be cast to that type using one of the type-cast operators —"},{"type":"text","text":" "},{"type":"codeVoice","code":"as"},{"type":"text","text":", "},{"type":"codeVoice","code":"as?"},{"type":"text","text":", or "},{"type":"codeVoice","code":"as!"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"use "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" to conditionally downcast the first object in a heterogeneous array"},{"type":"text","text":" "},{"type":"text","text":"to a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" as follows:"}]},{"type":"codeListing","syntax":"swift","code":["if let first = mixed.first as? String {","    print(\"The first item, '\\(first)', is a string.\")","}","\/\/ Prints \"The first item, 'one', is a string.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about casting, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" protocol is similar to the "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"All classes implicitly conform to "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Unlike "},{"type":"codeVoice","code":"Any"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which is defined by the language,"},{"type":"text","text":" "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" is defined by the Swift standard library."},{"type":"text","text":" "},{"type":"text","text":"For more information, see"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Class-Only-Protocols"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of an Any type","","any-type --> ``Any``"]},{"anchor":"Self-Type","level":2,"type":"heading","text":"Self Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" type isn’t a specific type,"},{"type":"text","text":" "},{"type":"text","text":"but rather lets you conveniently refer to the current type"},{"type":"text","text":" "},{"type":"text","text":"without repeating or knowing that type’s name."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In a protocol declaration or a protocol member declaration,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" type refers to the eventual type that conforms to the protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In a structure, class, or enumeration declaration,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" type refers to the type introduced by the declaration."},{"type":"text","text":" "},{"type":"text","text":"Inside the declaration for a member of a type,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" type refers to that type."},{"type":"text","text":" "},{"type":"text","text":"In the members of a class declaration,"},{"type":"text","text":" "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" can appear only as follows:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As the return type of a method"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As the return type of a read-only subscript"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As the type of a read-only computed property"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In the body of a method"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the code below shows an instance method "},{"type":"codeVoice","code":"f"},{"type":"text","text":" "},{"type":"text","text":"whose return type is "},{"type":"codeVoice","code":"Self"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["class Superclass {","    func f() -> Self { return self }","}","let x = Superclass()","print(type(of: x.f()))","\/\/ Prints \"Superclass\"","","class Subclass: Superclass { }","let y = Subclass()","print(type(of: y.f()))","\/\/ Prints \"Subclass\"","","let z: Superclass = Subclass()","print(type(of: z.f()))","\/\/ Prints \"Subclass\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The last part of the example above shows that"},{"type":"text","text":" "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" refers to the runtime type "},{"type":"codeVoice","code":"Subclass"},{"type":"text","text":" of the value of "},{"type":"codeVoice","code":"z"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"not the compile-time type "},{"type":"codeVoice","code":"Superclass"},{"type":"text","text":" of the variable itself."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Inside a nested type declaration,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" type refers to the type"},{"type":"text","text":" "},{"type":"text","text":"introduced by the innermost type declaration."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" type refers to the same type"},{"type":"text","text":" "},{"type":"text","text":"as the "},{"overridingTitleInlineContent":[{"type":"text","text":"type(of:)"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","overridingTitle":"type(of:)"},{"type":"text","text":" "},{"type":"text","text":"function in the Swift standard library."},{"type":"text","text":" "},{"type":"text","text":"Writing "},{"type":"codeVoice","code":"Self.someStaticMember"},{"type":"text","text":" to access a member of the current type"},{"type":"text","text":" "},{"type":"text","text":"is the same as writing "},{"type":"codeVoice","code":"type(of: self).someStaticMember"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a Self type","","self-type --> ``Self``"]},{"anchor":"Type-Inheritance-Clause","level":2,"type":"heading","text":"Type Inheritance Clause"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type inheritance clause"}]},{"type":"text","text":" is used to specify which class a named type inherits from"},{"type":"text","text":" "},{"type":"text","text":"and which protocols a named type conforms to."},{"type":"text","text":" "},{"type":"text","text":"A type inheritance clause begins with a colon ("},{"type":"codeVoice","code":":"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"followed by a list of type identifiers."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Class types can inherit from a single superclass and conform to any number of protocols."},{"type":"text","text":" "},{"type":"text","text":"When defining a class,"},{"type":"text","text":" "},{"type":"text","text":"the name of the superclass must appear first in the list of type identifiers,"},{"type":"text","text":" "},{"type":"text","text":"followed by any number of protocols the class must conform to."},{"type":"text","text":" "},{"type":"text","text":"If the class doesn’t inherit from another class,"},{"type":"text","text":" "},{"type":"text","text":"the list can begin with a protocol instead."},{"type":"text","text":" "},{"type":"text","text":"For an extended discussion and several examples of class inheritance,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Other named types can only inherit from or conform to a list of protocols."},{"type":"text","text":" "},{"type":"text","text":"Protocol types can inherit from any number of other protocols."},{"type":"text","text":" "},{"type":"text","text":"When a protocol type inherits from other protocols,"},{"type":"text","text":" "},{"type":"text","text":"the set of requirements from those other protocols are aggregated together,"},{"type":"text","text":" "},{"type":"text","text":"and any type that inherits from the current protocol must conform to all of those requirements."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A type inheritance clause in an enumeration definition can be either a list of protocols,"},{"type":"text","text":" "},{"type":"text","text":"or in the case of an enumeration that assigns raw values to its cases,"},{"type":"text","text":" "},{"type":"text","text":"a single, named type that specifies the type of those raw values."},{"type":"text","text":" "},{"type":"text","text":"For an example of an enumeration definition that uses a type inheritance clause"},{"type":"text","text":" "},{"type":"text","text":"to specify the type of its raw values, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations#Raw-Values"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"markdown","code":["Grammar of a type inheritance clause","","type-inheritance-clause --> ``:`` type-inheritance-list","type-inheritance-list --> attributes-OPT type-identifier | attributes-OPT type-identifier ``,`` type-inheritance-list"]},{"anchor":"Type-Inference","level":2,"type":"heading","text":"Type Inference"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type inference"}]},{"type":"text","text":" extensively,"},{"type":"text","text":" "},{"type":"text","text":"allowing you to omit the type or part of the type of many variables and expressions in your code."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"instead of writing "},{"type":"codeVoice","code":"var x: Int = 0"},{"type":"text","text":", you can write "},{"type":"codeVoice","code":"var x = 0"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"omitting the type completely —"},{"type":"text","text":" "},{"type":"text","text":"the compiler correctly infers that "},{"type":"codeVoice","code":"x"},{"type":"text","text":" names a value of type "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Similarly, you can omit part of a type when the full type can be inferred from context."},{"type":"text","text":" "},{"type":"text","text":"For example, if you write "},{"type":"codeVoice","code":"let dict: Dictionary = [\"A\": 1]"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the compiler infers that "},{"type":"codeVoice","code":"dict"},{"type":"text","text":" has the type "},{"type":"codeVoice","code":"Dictionary<String, Int>"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In both of the examples above,"},{"type":"text","text":" "},{"type":"text","text":"the type information is passed up from the leaves of the expression tree to its root."},{"type":"text","text":" "},{"type":"text","text":"That is,"},{"type":"text","text":" "},{"type":"text","text":"the type of "},{"type":"codeVoice","code":"x"},{"type":"text","text":" in "},{"type":"codeVoice","code":"var x: Int = 0"},{"type":"text","text":" is inferred by first checking the type of "},{"type":"codeVoice","code":"0"},{"type":"text","text":" "},{"type":"text","text":"and then passing this type information up to the root (the variable "},{"type":"codeVoice","code":"x"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, type information can also flow in the opposite direction—from the root down to the leaves."},{"type":"text","text":" "},{"type":"text","text":"In the following example, for instance,"},{"type":"text","text":" "},{"type":"text","text":"the explicit type annotation ("},{"type":"codeVoice","code":": Float"},{"type":"text","text":") on the constant "},{"type":"codeVoice","code":"eFloat"},{"type":"text","text":" "},{"type":"text","text":"causes the numeric literal "},{"type":"codeVoice","code":"2.71828"},{"type":"text","text":" to have an inferred type of "},{"type":"codeVoice","code":"Float"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"Double"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["let e = 2.71828 \/\/ The type of e is inferred to be Double.","let eFloat: Float = 2.71828 \/\/ The type of eFloat is Float."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Type inference in Swift operates at the level of a single expression or statement."},{"type":"text","text":" "},{"type":"text","text":"This means that all of the information needed to infer an omitted type or part of a type"},{"type":"text","text":" "},{"type":"text","text":"in an expression must be accessible from type-checking"},{"type":"text","text":" "},{"type":"text","text":"the expression or one of its subexpressions."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/types"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Types","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Em Swift, existem dois tipos de dados: tipos nomeados e tipos compostos."},{"type":"text","text":" "},{"type":"text","text":"Um "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tipo nomeado"}]},{"type":"text","text":" é um tipo que pode receber um nome específico quando é definido."},{"type":"text","text":" "},{"type":"text","text":"Tipos nomeados incluem classes, structs, enums, e protocolos."},{"type":"text","text":" "},{"type":"text","text":"Por exemplo, instâncias de uma classe definida pelo usuário chamada "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":"  tem o tipo "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Além dos tipos nomeados definidos pelo usuário, a biblioteca padrão do Swift define muitos tipos nomeados que são usados com mais frequência, incluindo aqueles que representam arrays, dicionários, e valores opcionais."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Tipos","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Reference","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AboutTheLanguageReference","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Statements","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/GenericParametersAndArguments"],"generated":true}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Throwing-Functions-and-Methods":{"abstract":[],"title":"Throwing Functions and Methods","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Throwing-Functions-and-Methods","url":"\/documentation\/the-swift-programming-language\/declarations#Throwing-Functions-and-Methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#Variadic-Parameters":{"abstract":[],"title":"Variadic Parameters","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Variadic-Parameters","url":"\/documentation\/the-swift-programming-language\/functions#Variadic-Parameters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Class-Only-Protocols":{"abstract":[],"title":"Class-Only Protocols","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Class-Only-Protocols","url":"\/documentation\/the-swift-programming-language\/protocols#Class-Only-Protocols"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/LexicalStructure":{"role":"article","title":"Lexical Structure","abstract":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"lexical structure"}]},{"type":"text","text":" of Swift describes what sequence of characters"},{"type":"text","text":" "},{"type":"text","text":"form valid tokens of the language."},{"type":"text","text":" "},{"type":"text","text":"These valid tokens form the lowest-level building blocks of the language"},{"type":"text","text":" "},{"type":"text","text":"and are used to describe the rest of the language in subsequent chapters."},{"type":"text","text":" "},{"type":"text","text":"A token consists of an identifier, keyword, punctuation, literal, or operator."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/lexicalstructure"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#In-Out-Parameters":{"abstract":[],"title":"In-Out Parameters","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters","url":"\/documentation\/the-swift-programming-language\/functions#In-Out-Parameters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Rethrowing-Functions-and-Methods":{"abstract":[],"title":"Rethrowing Functions and Methods","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Rethrowing-Functions-and-Methods","url":"\/documentation\/the-swift-programming-language\/declarations#Rethrowing-Functions-and-Methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance":{"role":"article","title":"Inheritance","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"type":"text","text":" methods, properties, and other characteristics"},{"type":"text","text":" "},{"type":"text","text":"from another class."},{"type":"text","text":" "},{"type":"text","text":"When one class inherits from another,"},{"type":"text","text":" "},{"type":"text","text":"the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Inheritance is a fundamental behavior that differentiates classes"},{"type":"text","text":" "},{"type":"text","text":"from other types in Swift."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/inheritance"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Asynchronous-Functions-and-Methods":{"abstract":[],"title":"Asynchronous Functions and Methods","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Asynchronous-Functions-and-Methods","url":"\/documentation\/the-swift-programming-language\/declarations#Asynchronous-Functions-and-Methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions":{"role":"article","title":"Expressions","abstract":[{"type":"text","text":"In Swift, there are four kinds of expressions:"},{"type":"text","text":" "},{"type":"text","text":"prefix expressions, infix expressions, primary expressions, and postfix expressions."},{"type":"text","text":" "},{"type":"text","text":"Evaluating an expression returns a value,"},{"type":"text","text":" "},{"type":"text","text":"causes a side effect, or both."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/expressions"},"https://developer.apple.com/documentation/swift/anyobject":{"title":"AnyObject","titleInlineContent":[{"type":"text","text":"AnyObject"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject","url":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject"},"https://developer.apple.com/documentation/swift/2885064-type":{"title":"type(of:)","titleInlineContent":[{"type":"text","text":"type(of:)"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","url":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Autoclosures":{"abstract":[],"title":"Autoclosures","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Autoclosures","url":"\/documentation\/the-swift-programming-language\/closures#Autoclosures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations":{"role":"article","title":"Declarations","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"declaration"}]},{"type":"text","text":" introduces a new name or construct into your program."},{"type":"text","text":" "},{"type":"text","text":"For example, you use declarations to introduce functions and methods,"},{"type":"text","text":" "},{"type":"text","text":"to introduce variables and constants,"},{"type":"text","text":" "},{"type":"text","text":"and to define enumeration, structure, class, and protocol types."},{"type":"text","text":" "},{"type":"text","text":"You can also use a declaration to extend the behavior"},{"type":"text","text":" "},{"type":"text","text":"of an existing named type and to import symbols into your program that are declared elsewhere."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/declarations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#Functions-with-Multiple-Return-Values":{"abstract":[],"title":"Functions with Multiple Return Values","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Functions-with-Multiple-Return-Values","url":"\/documentation\/the-swift-programming-language\/functions#Functions-with-Multiple-Return-Values"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"role":"article","title":"Type Casting","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance,"},{"type":"text","text":" "},{"type":"text","text":"or to treat that instance as a different"},{"type":"text","text":" "},{"type":"text","text":"superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Enumerations#Raw-Values":{"abstract":[],"title":"Raw Values","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations#Raw-Values","url":"\/documentation\/the-swift-programming-language\/enumerations#Raw-Values"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Patterns":{"role":"article","title":"Patterns","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" represents the structure of a single value"},{"type":"text","text":" "},{"type":"text","text":"or a composite value."},{"type":"text","text":" "},{"type":"text","text":"For example, the structure of a tuple "},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" is a comma-separated list of two"},{"type":"text","text":" "},{"type":"text","text":"elements. Because patterns represent the structure of a value rather than any"},{"type":"text","text":" "},{"type":"text","text":"one particular value, you can match them with a variety of values."},{"type":"text","text":" "},{"type":"text","text":"For instance, the pattern "},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":" matches the tuple "},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" and any other"},{"type":"text","text":" "},{"type":"text","text":"two-element tuple. In addition to matching a pattern with a value,"},{"type":"text","text":" "},{"type":"text","text":"you can extract part or all of a composite value and bind each part"},{"type":"text","text":" "},{"type":"text","text":"to a constant or variable name."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/patterns"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes#Arrays":{"abstract":[],"title":"Arrays","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Arrays","url":"\/documentation\/the-swift-programming-language\/collectiontypes#Arrays"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/MemorySafety":{"role":"article","title":"Memory Safety","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift ensures that variables are initialized before they’re used,"},{"type":"text","text":" "},{"type":"text","text":"memory isn’t accessed after it’s been deallocated,"},{"type":"text","text":" "},{"type":"text","text":"and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/memorysafety"},"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AboutTheLanguageReference":{"role":"article","title":"About the Language Reference","abstract":[{"type":"text","text":"This part of the book describes the formal grammar of the Swift programming language."},{"type":"text","text":" "},{"type":"text","text":"The grammar described here is intended to help you understand the language in more"},{"type":"text","text":" "},{"type":"text","text":"detail, rather than to allow you to directly implement a parser or compiler."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AboutTheLanguageReference","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/aboutthelanguagereference"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes":{"role":"article","title":"Attributes","abstract":[{"type":"text","text":"There are two kinds of attributes in Swift —"},{"type":"text","text":" "},{"type":"text","text":"those that apply to declarations and those that apply to types."},{"type":"text","text":" "},{"type":"text","text":"An attribute provides additional information about the declaration or type."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"discardableResult"},{"type":"text","text":" attribute on a function declaration indicates that,"},{"type":"text","text":" "},{"type":"text","text":"although the function returns a value,"},{"type":"text","text":" "},{"type":"text","text":"the compiler shouldn’t generate a warning if the return value is unused."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/attributes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Statements":{"role":"article","title":"Statements","abstract":[{"type":"text","text":"In Swift, there are three kinds of statements: simple statements, compiler control statements,"},{"type":"text","text":" "},{"type":"text","text":"and control flow statements."},{"type":"text","text":" "},{"type":"text","text":"Simple statements are the most common and consist of either an expression or a declaration."},{"type":"text","text":" "},{"type":"text","text":"Compiler control statements allow the program to change aspects of the compiler’s behavior"},{"type":"text","text":" "},{"type":"text","text":"and include a conditional compilation block and a line control statement."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Statements","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/statements"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Extensions":{"role":"article","title":"Extensões","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensões"}]},{"type":"text","text":" adicionam novas funcionalidades a uma classe, estrutura, enumeração ou tipo de protocolo existente. Isso inclui a capacidade de estender tipos para os quais você não tem acesso ao código-fonte original (conhecido como "},{"type":"emphasis","inlineContent":[{"type":"text","text":"modelagem retroativa"}]},{"type":"text","text":"). As extensões são semelhantes às categorias em Objective-C. (Ao contrário das categorias de Objective-C, as extensões Swift não têm nomes.)"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/extensions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics#Implicitly-Unwrapped-Optionals":{"abstract":[],"title":"Implicitly Unwrapped Optionals","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics#Implicitly-Unwrapped-Optionals","url":"\/documentation\/the-swift-programming-language\/thebasics#Implicitly-Unwrapped-Optionals"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics#Optionals":{"abstract":[],"title":"Optionals","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics#Optionals","url":"\/documentation\/the-swift-programming-language\/thebasics#Optionals"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Extension-Declaration":{"abstract":[],"title":"Extension Declaration","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Extension-Declaration","url":"\/documentation\/the-swift-programming-language\/declarations#Extension-Declaration"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes#Dictionaries":{"abstract":[],"title":"Dictionaries","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Dictionaries","url":"\/documentation\/the-swift-programming-language\/collectiontypes#Dictionaries"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/GenericParametersAndArguments":{"role":"article","title":"Generic Parameters and Arguments","abstract":[{"type":"text","text":"This chapter describes parameters and arguments for generic types, functions, and"},{"type":"text","text":" "},{"type":"text","text":"initializers. When you declare a generic type, function, subscript, or initializer,"},{"type":"text","text":" "},{"type":"text","text":"you specify the type parameters that the generic type, function, or initializer"},{"type":"text","text":" "},{"type":"text","text":"can work with. These type parameters act as placeholders that"},{"type":"text","text":" "},{"type":"text","text":"are replaced by actual concrete type arguments when an instance of a generic type is"},{"type":"text","text":" "},{"type":"text","text":"created or a generic function or initializer is called."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/GenericParametersAndArguments","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/genericparametersandarguments"}}}